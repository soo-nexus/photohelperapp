import { meridiemForDateTime as D, monthForDateTime as M, weekdayForDateTime as F, eraForDateTime as S } from "./shared26.js";
import { DATE_SHORT as _, DATE_MED as p, DATE_FULL as w, DATE_HUGE as L, TIME_SIMPLE as I, TIME_WITH_SECONDS as k, TIME_WITH_SHORT_OFFSET as O, TIME_WITH_LONG_OFFSET as g, TIME_24_SIMPLE as Z, TIME_24_WITH_SECONDS as H, TIME_24_WITH_SHORT_OFFSET as d, TIME_24_WITH_LONG_OFFSET as W, DATETIME_SHORT as A, DATETIME_MED as G, DATETIME_FULL as N, DATETIME_HUGE as C, DATETIME_SHORT_WITH_SECONDS as v, DATETIME_MED_WITH_SECONDS as U, DATETIME_FULL_WITH_SECONDS as b, DATETIME_HUGE_WITH_SECONDS as q } from "./shared19.js";
import { padStart as z } from "./shared13.js";
function T(E, e) {
  let t = "";
  for (const r of E)
    r.literal ? t += r.val : t += e(r.val);
  return t;
}
const R = {
  D: _,
  DD: p,
  DDD: w,
  DDDD: L,
  t: I,
  tt: k,
  ttt: O,
  tttt: g,
  T: Z,
  TT: H,
  TTT: d,
  TTTT: W,
  f: A,
  ff: G,
  fff: N,
  ffff: C,
  F: v,
  FF: U,
  FFF: b,
  FFFF: q
};
class h {
  static create(e, t = {}) {
    return new h(e, t);
  }
  static parseFormat(e) {
    let t = null, r = "", a = !1;
    const s = [];
    for (let c = 0; c < e.length; c++) {
      const i = e.charAt(c);
      i === "'" ? (r.length > 0 && s.push({ literal: a, val: r }), t = null, r = "", a = !a) : a || i === t ? r += i : (r.length > 0 && s.push({ literal: !1, val: r }), r = i, t = i);
    }
    return r.length > 0 && s.push({ literal: a, val: r }), s;
  }
  static macroTokenToFormatOpts(e) {
    return R[e];
  }
  constructor(e, t) {
    this.opts = t, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, t) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format();
  }
  formatDateTime(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t }).format();
  }
  formatDateTimeParts(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t }).formatToParts();
  }
  resolvedOptions(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t }).resolvedOptions();
  }
  num(e, t = 0) {
    if (this.opts.forceSimple)
      return z(e, t);
    const r = { ...this.opts };
    return t > 0 && (r.padTo = t), this.loc.numberFormatter(r).format(e);
  }
  formatDateTimeFromString(e, t) {
    const r = this.loc.listingMode() === "en", a = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", s = (n, m) => this.loc.extract(e, n, m), c = (n) => e.isOffsetFixed && e.offset === 0 && n.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, n.format) : "", i = () => r ? D(e) : s({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), o = (n, m) => r ? M(e, n) : s(m ? { month: n } : { month: n, day: "numeric" }, "month"), u = (n, m) => r ? F(e, n) : s(
      m ? { weekday: n } : { weekday: n, month: "long", day: "numeric" },
      "weekday"
    ), l = (n) => {
      const m = h.macroTokenToFormatOpts(n);
      return m ? this.formatWithSystemDefault(e, m) : n;
    }, f = (n) => r ? S(e, n) : s({ era: n }, "era"), y = (n) => {
      switch (n) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return c({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return c({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return c({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return i();
        case "d":
          return a ? s({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return a ? s({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return u("short", !0);
        case "cccc":
          return u("long", !0);
        case "ccccc":
          return u("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return u("short", !1);
        case "EEEE":
          return u("long", !1);
        case "EEEEE":
          return u("narrow", !1);
        case "L":
          return a ? s({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return a ? s({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return o("short", !0);
        case "LLLL":
          return o("long", !0);
        case "LLLLL":
          return o("narrow", !0);
        case "M":
          return a ? s({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return a ? s({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return o("short", !1);
        case "MMMM":
          return o("long", !1);
        case "MMMMM":
          return o("narrow", !1);
        case "y":
          return a ? s({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return a ? s({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return a ? s({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return a ? s({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return f("short");
        case "GG":
          return f("long");
        case "GGGGG":
          return f("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return l(n);
      }
    };
    return T(h.parseFormat(t), y);
  }
  formatDurationFromString(e, t) {
    const r = (o) => {
      switch (o[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, a = (o) => (u) => {
      const l = r(u);
      return l ? this.num(o.get(l), u.length) : u;
    }, s = h.parseFormat(t), c = s.reduce(
      (o, { literal: u, val: l }) => u ? o : o.concat(l),
      []
    ), i = e.shiftTo(...c.map(r).filter((o) => o));
    return T(s, a(i));
  }
}
export {
  h as default
};
