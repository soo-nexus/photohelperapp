import { hasOwnProperty as k, isUndefined as p, parseMillis as Z, signedOffset as $, untruncateYear as S } from "./shared13.js";
import w from "./shared10.js";
import P from "./shared11.js";
import q from "./shared22.js";
import z from "./shared5.js";
import { parseDigits as D, digitRegex as c } from "./shared27.js";
import { ConflictingSpecificationError as I } from "./shared20.js";
const N = "missing Intl.DateTimeFormat.formatToParts support";
function s(e, r = (t) => t) {
  return { regex: e, deser: ([t]) => r(D(t)) };
}
const C = "Â ", F = `[ ${C}]`, L = /* @__PURE__ */ new RegExp(F, "g");
function b(e) {
  return e.replace(/\./g, "\\.?").replace(L, F);
}
function v(e) {
  return e.replace(/\./g, "").replace(L, " ").toLowerCase();
}
function f(e, r) {
  return e === null ? null : {
    regex: RegExp(e.map(b).join("|")),
    deser: ([t]) => e.findIndex((n) => v(t) === v(n)) + r
  };
}
function R(e, r) {
  return { regex: e, deser: ([, t, n]) => $(t, n), groups: r };
}
function T(e) {
  return { regex: e, deser: ([r]) => r };
}
function G(e) {
  return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function H(e, r) {
  const t = c(r), n = c(r, "{2}"), o = c(r, "{3}"), i = c(r, "{4}"), u = c(r, "{6}"), a = c(r, "{1,2}"), l = c(r, "{1,3}"), M = c(r, "{1,6}"), d = c(r, "{1,9}"), y = c(r, "{2,4}"), x = c(r, "{4,6}"), g = (m) => ({ regex: RegExp(G(m.val)), deser: ([O]) => O, literal: !0 }), h = ((m) => {
    if (e.literal)
      return g(m);
    switch (m.val) {
      case "G":
        return f(r.eras("short", !1), 0);
      case "GG":
        return f(r.eras("long", !1), 0);
      case "y":
        return s(M);
      case "yy":
        return s(y, S);
      case "yyyy":
        return s(i);
      case "yyyyy":
        return s(x);
      case "yyyyyy":
        return s(u);
      case "M":
        return s(a);
      case "MM":
        return s(n);
      case "MMM":
        return f(r.months("short", !0, !1), 1);
      case "MMMM":
        return f(r.months("long", !0, !1), 1);
      case "L":
        return s(a);
      case "LL":
        return s(n);
      case "LLL":
        return f(r.months("short", !1, !1), 1);
      case "LLLL":
        return f(r.months("long", !1, !1), 1);
      case "d":
        return s(a);
      case "dd":
        return s(n);
      case "o":
        return s(l);
      case "ooo":
        return s(o);
      case "HH":
        return s(n);
      case "H":
        return s(a);
      case "hh":
        return s(n);
      case "h":
        return s(a);
      case "mm":
        return s(n);
      case "m":
        return s(a);
      case "q":
        return s(a);
      case "qq":
        return s(n);
      case "s":
        return s(a);
      case "ss":
        return s(n);
      case "S":
        return s(l);
      case "SSS":
        return s(o);
      case "u":
        return T(d);
      case "uu":
        return T(a);
      case "uuu":
        return s(t);
      case "a":
        return f(r.meridiems(), 0);
      case "kkkk":
        return s(i);
      case "kk":
        return s(y, S);
      case "W":
        return s(a);
      case "WW":
        return s(n);
      case "E":
      case "c":
        return s(t);
      case "EEE":
        return f(r.weekdays("short", !1, !1), 1);
      case "EEEE":
        return f(r.weekdays("long", !1, !1), 1);
      case "ccc":
        return f(r.weekdays("short", !0, !1), 1);
      case "cccc":
        return f(r.weekdays("long", !0, !1), 1);
      case "Z":
      case "ZZ":
        return R(new RegExp(`([+-]${a.source})(?::(${n.source}))?`), 2);
      case "ZZZ":
        return R(new RegExp(`([+-]${a.source})(${n.source})?`), 2);
      case "z":
        return T(/[a-z_+-/]{1,256}?/i);
      default:
        return g(m);
    }
  })(e) || {
    invalidReason: N
  };
  return h.token = e, h;
}
const W = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};
function j(e, r, t) {
  const { type: n, value: o } = e;
  if (n === "literal")
    return {
      literal: !0,
      val: o
    };
  const i = t[n];
  let u = W[n];
  if (typeof u == "object" && (u = u[i]), u)
    return {
      literal: !1,
      val: u
    };
}
function A(e) {
  return [`^${e.map((t) => t.regex).reduce((t, n) => `${t}(${n.source})`, "")}$`, e];
}
function B(e, r, t) {
  const n = e.match(r);
  if (n) {
    const o = {};
    let i = 1;
    for (const u in t)
      if (k(t, u)) {
        const a = t[u], l = a.groups ? a.groups + 1 : 1;
        !a.literal && a.token && (o[a.token.val[0]] = a.deser(n.slice(i, i + l))), i += l;
      }
    return [n, o];
  } else
    return [n, {}];
}
function U(e) {
  const r = (i) => {
    switch (i) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let t = null, n;
  return p(e.z) || (t = q.create(e.z)), p(e.Z) || (t || (t = new P(e.Z)), n = e.Z), p(e.q) || (e.M = (e.q - 1) * 3 + 1), p(e.h) || (e.h < 12 && e.a === 1 ? e.h += 12 : e.h === 12 && e.a === 0 && (e.h = 0)), e.G === 0 && e.y && (e.y = -e.y), p(e.u) || (e.S = Z(e.u)), [Object.keys(e).reduce((i, u) => {
    const a = r(u);
    return a && (i[a] = e[u]), i;
  }, {}), t, n];
}
let E = null;
function Y() {
  return E || (E = z.fromMillis(1555555555555)), E;
}
function _(e, r) {
  if (e.literal)
    return e;
  const t = w.macroTokenToFormatOpts(e.val);
  if (!t)
    return e;
  const i = w.create(r, t).formatDateTimeParts(Y()).map((u) => j(u, r, t));
  return i.includes(void 0) ? e : i;
}
function V(e, r) {
  return Array.prototype.concat(...e.map((t) => _(t, r)));
}
function J(e, r, t) {
  const n = V(w.parseFormat(t), e), o = n.map((u) => H(u, e)), i = o.find((u) => u.invalidReason);
  if (i)
    return { input: r, tokens: n, invalidReason: i.invalidReason };
  {
    const [u, a] = A(o), l = RegExp(u, "i"), [M, d] = B(r, l, a), [y, x, g] = d ? U(d) : [null, null, void 0];
    if (k(d, "a") && k(d, "H"))
      throw new I(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: r, tokens: n, regex: l, rawMatches: M, matches: d, result: y, zone: x, specificOffset: g };
  }
}
function ae(e, r, t) {
  const { result: n, zone: o, specificOffset: i, invalidReason: u } = J(e, r, t);
  return [n, o, i, u];
}
export {
  J as explainFromTokens,
  ae as parseFromTokens
};
