import { parseZoneInfo as g, formatOffset as T, objToLocalTS as C, isUndefined as D } from "./shared13.js";
import N from "./shared23.js";
let u = {};
function O(n) {
  return u[n] || (u[n] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: n,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), u[n];
}
const S = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function Z(n, t) {
  const e = n.format(t).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(e), [, a, i, o, s, f, c, l] = r;
  return [o, a, i, s, f, c, l];
}
function v(n, t) {
  const e = n.formatToParts(t), r = [];
  for (let a = 0; a < e.length; a++) {
    const { type: i, value: o } = e[a], s = S[i];
    i === "era" ? r[s] = o : D(s) || (r[s] = parseInt(o, 10));
  }
  return r;
}
let d = {};
class p extends N {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(t) {
    return d[t] || (d[t] = new p(t)), d[t];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    d = {}, u = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(t) {
    return this.isValidZone(t);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(t) {
    if (!t)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: t }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(t) {
    super(), this.zoneName = t, this.valid = p.isValidZone(t);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: e, locale: r }) {
    return g(t, e, r, this.name);
  }
  /** @override **/
  formatOffset(t, e) {
    return T(this.offset(t), e);
  }
  /** @override **/
  offset(t) {
    const e = new Date(t);
    if (isNaN(e)) return NaN;
    const r = O(this.name);
    let [a, i, o, s, f, c, l] = r.formatToParts ? v(r, e) : Z(r, e);
    s === "BC" && (a = -Math.abs(a) + 1);
    const y = C({
      year: a,
      month: i,
      day: o,
      hour: f === 24 ? 0 : f,
      minute: c,
      second: l,
      millisecond: 0
    });
    let m = +e;
    const h = m % 1e3;
    return m -= h >= 0 ? h : 1e3 + h, (y - m) / (60 * 1e3);
  }
  /** @override **/
  equals(t) {
    return t.type === "iana" && t.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
export {
  p as default
};
