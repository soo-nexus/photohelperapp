import { roundTo as b, padStart as g, hasRelative as N } from "./shared13.js";
import { formatRelativeTime as O, months as w, weekdays as F, meridiems as S, eras as k } from "./shared26.js";
import h from "./shared8.js";
import u from "./shared5.js";
import v from "./shared22.js";
let C = {};
function D(r, t = {}) {
  const e = JSON.stringify([r, t]);
  let s = C[e];
  return s || (s = new Intl.ListFormat(r, t), C[e] = s), s;
}
let c = {};
function d(r, t = {}) {
  const e = JSON.stringify([r, t]);
  let s = c[e];
  return s || (s = new Intl.DateTimeFormat(r, t), c[e] = s), s;
}
let y = {};
function E(r, t = {}) {
  const e = JSON.stringify([r, t]);
  let s = y[e];
  return s || (s = new Intl.NumberFormat(r, t), y[e] = s), s;
}
let p = {};
function I(r, t = {}) {
  const { base: e, ...s } = t, i = JSON.stringify([r, s]);
  let n = p[i];
  return n || (n = new Intl.RelativeTimeFormat(r, t), p[i] = n), n;
}
let l = null;
function x() {
  return l || (l = new Intl.DateTimeFormat().resolvedOptions().locale, l);
}
function L(r) {
  const t = r.indexOf("-u-");
  if (t === -1)
    return [r];
  {
    let e;
    const s = r.substring(0, t);
    try {
      e = d(r).resolvedOptions();
    } catch {
      e = d(s).resolvedOptions();
    }
    const { numberingSystem: i, calendar: n } = e;
    return [s, i, n];
  }
}
function P(r, t, e) {
  return (e || t) && (r += "-u", e && (r += `-ca-${e}`), t && (r += `-nu-${t}`)), r;
}
function R(r) {
  const t = [];
  for (let e = 1; e <= 12; e++) {
    const s = u.utc(2016, e, 1);
    t.push(r(s));
  }
  return t;
}
function M(r) {
  const t = [];
  for (let e = 1; e <= 7; e++) {
    const s = u.utc(2016, 11, 13 + e);
    t.push(r(s));
  }
  return t;
}
function m(r, t, e, s, i) {
  const n = r.listingMode(e);
  return n === "error" ? null : n === "en" ? s(t) : i(t);
}
function J(r) {
  return r.numberingSystem && r.numberingSystem !== "latn" ? !1 : r.numberingSystem === "latn" || !r.locale || r.locale.startsWith("en") || new Intl.DateTimeFormat(r.intl).resolvedOptions().numberingSystem === "latn";
}
class z {
  constructor(t, e, s) {
    this.padTo = s.padTo || 0, this.floor = s.floor || !1;
    const { padTo: i, floor: n, ...a } = s;
    if (!e || Object.keys(a).length > 0) {
      const o = { useGrouping: !1, ...s };
      s.padTo > 0 && (o.minimumIntegerDigits = s.padTo), this.inf = E(t, o);
    }
  }
  format(t) {
    if (this.inf) {
      const e = this.floor ? Math.floor(t) : t;
      return this.inf.format(e);
    } else {
      const e = this.floor ? Math.floor(t) : b(t, 3);
      return g(e, this.padTo);
    }
  }
}
class W {
  constructor(t, e, s) {
    this.opts = s;
    let i;
    if (t.zone.isUniversal) {
      const a = -1 * (t.offset / 60), o = a >= 0 ? `Etc/GMT+${a}` : `Etc/GMT${a}`;
      t.offset !== 0 && v.create(o).valid ? (i = o, this.dt = t) : (i = "UTC", s.timeZoneName ? this.dt = t : this.dt = t.offset === 0 ? t : u.fromMillis(t.ts + t.offset * 60 * 1e3));
    } else t.zone.type === "system" ? this.dt = t : (this.dt = t, i = t.zone.name);
    const n = { ...this.opts };
    i && (n.timeZone = i), this.dtf = d(e, n);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class Z {
  constructor(t, e, s) {
    this.opts = { style: "long", ...s }, !e && N() && (this.rtf = I(t, s));
  }
  format(t, e) {
    return this.rtf ? this.rtf.format(t, e) : O(e, t, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t, e) {
    return this.rtf ? this.rtf.formatToParts(t, e) : [];
  }
}
class f {
  static fromOpts(t) {
    return f.create(t.locale, t.numberingSystem, t.outputCalendar, t.defaultToEN);
  }
  static create(t, e, s, i = !1) {
    const n = t || h.defaultLocale, a = n || (i ? "en-US" : x()), o = e || h.defaultNumberingSystem, T = s || h.defaultOutputCalendar;
    return new f(a, o, T, n);
  }
  static resetCache() {
    l = null, c = {}, y = {}, p = {};
  }
  static fromObject({ locale: t, numberingSystem: e, outputCalendar: s } = {}) {
    return f.create(t, e, s);
  }
  constructor(t, e, s, i) {
    const [n, a, o] = L(t);
    this.locale = n, this.numberingSystem = e || a || null, this.outputCalendar = s || o || null, this.intl = P(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = i, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = J(this)), this.fastNumbersCached;
  }
  listingMode() {
    const t = this.isEnglish(), e = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return t && e ? "en" : "intl";
  }
  clone(t) {
    return !t || Object.getOwnPropertyNames(t).length === 0 ? this : f.create(
      t.locale || this.specifiedLocale,
      t.numberingSystem || this.numberingSystem,
      t.outputCalendar || this.outputCalendar,
      t.defaultToEN || !1
    );
  }
  redefaultToEN(t = {}) {
    return this.clone({ ...t, defaultToEN: !0 });
  }
  redefaultToSystem(t = {}) {
    return this.clone({ ...t, defaultToEN: !1 });
  }
  months(t, e = !1, s = !0) {
    return m(this, t, s, w, () => {
      const i = e ? { month: t, day: "numeric" } : { month: t }, n = e ? "format" : "standalone";
      return this.monthsCache[n][t] || (this.monthsCache[n][t] = R((a) => this.extract(a, i, "month"))), this.monthsCache[n][t];
    });
  }
  weekdays(t, e = !1, s = !0) {
    return m(this, t, s, F, () => {
      const i = e ? { weekday: t, year: "numeric", month: "long", day: "numeric" } : { weekday: t }, n = e ? "format" : "standalone";
      return this.weekdaysCache[n][t] || (this.weekdaysCache[n][t] = M(
        (a) => this.extract(a, i, "weekday")
      )), this.weekdaysCache[n][t];
    });
  }
  meridiems(t = !0) {
    return m(
      this,
      void 0,
      t,
      () => S,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [u.utc(2016, 11, 13, 9), u.utc(2016, 11, 13, 19)].map(
            (s) => this.extract(s, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(t, e = !0) {
    return m(this, t, e, k, () => {
      const s = { era: t };
      return this.eraCache[t] || (this.eraCache[t] = [u.utc(-40, 1, 1), u.utc(2017, 1, 1)].map(
        (i) => this.extract(i, s, "era")
      )), this.eraCache[t];
    });
  }
  extract(t, e, s) {
    const i = this.dtFormatter(t, e), n = i.formatToParts(), a = n.find((o) => o.type.toLowerCase() === s);
    return a ? a.value : null;
  }
  numberFormatter(t = {}) {
    return new z(this.intl, t.forceSimple || this.fastNumbers, t);
  }
  dtFormatter(t, e = {}) {
    return new W(t, this.intl, e);
  }
  relFormatter(t = {}) {
    return new Z(this.intl, this.isEnglish(), t);
  }
  listFormatter(t = {}) {
    return D(this.intl, t);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(t) {
    return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar;
  }
}
export {
  f as default
};
