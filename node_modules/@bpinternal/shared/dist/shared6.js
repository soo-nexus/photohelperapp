import { InvalidArgumentError as v, InvalidDurationError as N, InvalidUnitError as k } from "./shared20.js";
import I from "./shared10.js";
import w from "./shared21.js";
import g from "./shared12.js";
import { parseISODuration as x, parseISOTimeOnly as M } from "./shared16.js";
import { normalizeObject as O, isNumber as y, isUndefined as V, roundTo as q, hasOwnProperty as p, asNumber as j } from "./shared13.js";
import A from "./shared8.js";
const T = "Invalid Duration", b = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, z = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...b
}, o = 146097 / 400, m = 146097 / 4800, U = {
  years: {
    quarters: 4,
    months: 12,
    weeks: o / 7,
    days: o,
    hours: o * 24,
    minutes: o * 24 * 60,
    seconds: o * 24 * 60 * 60,
    milliseconds: o * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: o / 28,
    days: o / 4,
    hours: o * 24 / 4,
    minutes: o * 24 * 60 / 4,
    seconds: o * 24 * 60 * 60 / 4,
    milliseconds: o * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: m / 7,
    days: m,
    hours: m * 24,
    minutes: m * 24 * 60,
    seconds: m * 24 * 60 * 60,
    milliseconds: m * 24 * 60 * 60 * 1e3
  },
  ...b
}, c = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], F = /* @__PURE__ */ c.slice(0).reverse();
function u(a, s, e = !1) {
  const t = {
    values: e ? s.values : { ...a.values, ...s.values || {} },
    loc: a.loc.clone(s.loc),
    conversionAccuracy: s.conversionAccuracy || a.conversionAccuracy
  };
  return new n(t);
}
function P(a) {
  return a < 0 ? Math.floor(a) : Math.ceil(a);
}
function S(a, s, e, t, i) {
  const l = a[i][e], r = s[e] / l, h = Math.sign(r) === Math.sign(t[i]), f = !h && t[i] !== 0 && Math.abs(r) <= 1 ? P(r) : Math.trunc(r);
  t[i] += f, s[e] -= f * l;
}
function $(a, s) {
  F.reduce((e, t) => V(s[t]) ? e : (e && S(a, s, e, s, t), t), null);
}
class n {
  /**
   * @private
   */
  constructor(s) {
    const e = s.conversionAccuracy === "longterm" || !1;
    this.values = s.values, this.loc = s.loc || g.create(), this.conversionAccuracy = e ? "longterm" : "casual", this.invalid = s.invalid || null, this.matrix = e ? U : z, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(s, e) {
    return n.fromObject({ milliseconds: s }, e);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromObject(s, e = {}) {
    if (s == null || typeof s != "object")
      throw new v(
        `Duration.fromObject: argument expected to be an object, got ${s === null ? "null" : typeof s}`
      );
    return new n({
      values: O(s, n.normalizeUnit),
      loc: g.fromObject(e),
      conversionAccuracy: e.conversionAccuracy
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(s) {
    if (y(s))
      return n.fromMillis(s);
    if (n.isDuration(s))
      return s;
    if (typeof s == "object")
      return n.fromObject(s);
    throw new v(
      `Unknown duration argument ${s} of type ${typeof s}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(s, e) {
    const [t] = x(s);
    return t ? n.fromObject(t, e) : n.invalid("unparsable", `the input "${s}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(s, e) {
    const [t] = M(s);
    return t ? n.fromObject(t, e) : n.invalid("unparsable", `the input "${s}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(s, e = null) {
    if (!s)
      throw new v("need to specify a reason the Duration is invalid");
    const t = s instanceof w ? s : new w(s, e);
    if (A.throwOnInvalid)
      throw new N(t);
    return new n({ invalid: t });
  }
  /**
   * @private
   */
  static normalizeUnit(s) {
    const e = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[s && s.toLowerCase()];
    if (!e) throw new k(s);
    return e;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(s) {
    return s && s.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(s, e = {}) {
    const t = {
      ...e,
      floor: e.round !== !1 && e.floor !== !1
    };
    return this.isValid ? I.create(this.loc, t).formatDurationFromString(this, s) : T;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(s = {}) {
    const e = c.map((t) => {
      const i = this.values[t];
      return V(i) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...s, unit: t.slice(0, -1) }).format(i);
    }).filter((t) => t);
    return this.loc.listFormatter({ type: "conjunction", style: s.listStyle || "narrow", ...s }).format(e);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s = "P";
    return this.years !== 0 && (s += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (s += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (s += this.weeks + "W"), this.days !== 0 && (s += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (s += "T"), this.hours !== 0 && (s += this.hours + "H"), this.minutes !== 0 && (s += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (s += q(this.seconds + this.milliseconds / 1e3, 3) + "S"), s === "P" && (s += "T0S"), s;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(s = {}) {
    if (!this.isValid) return null;
    const e = this.toMillis();
    if (e < 0 || e >= 864e5) return null;
    s = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...s
    };
    const t = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let i = s.format === "basic" ? "hhmm" : "hh:mm";
    (!s.suppressSeconds || t.seconds !== 0 || t.milliseconds !== 0) && (i += s.format === "basic" ? "ss" : ":ss", (!s.suppressMilliseconds || t.milliseconds !== 0) && (i += ".SSS"));
    let l = t.toFormat(i);
    return s.includePrefix && (l = "T" + l), l;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(s) {
    if (!this.isValid) return this;
    const e = n.fromDurationLike(s), t = {};
    for (const i of c)
      (p(e.values, i) || p(this.values, i)) && (t[i] = e.get(i) + this.get(i));
    return u(this, { values: t }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(s) {
    if (!this.isValid) return this;
    const e = n.fromDurationLike(s);
    return this.plus(e.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(s) {
    if (!this.isValid) return this;
    const e = {};
    for (const t of Object.keys(this.values))
      e[t] = j(s(this.values[t], t));
    return u(this, { values: e }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(s) {
    return this[n.normalizeUnit(s)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(s) {
    if (!this.isValid) return this;
    const e = { ...this.values, ...O(s, n.normalizeUnit) };
    return u(this, { values: e });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: s, numberingSystem: e, conversionAccuracy: t } = {}) {
    const i = this.loc.clone({ locale: s, numberingSystem: e }), l = { loc: i };
    return t && (l.conversionAccuracy = t), u(this, l);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(s) {
    return this.isValid ? this.shiftTo(s).get(s) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const s = this.toObject();
    return $(this.matrix, s), u(this, { values: s }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...s) {
    if (!this.isValid) return this;
    if (s.length === 0)
      return this;
    s = s.map((r) => n.normalizeUnit(r));
    const e = {}, t = {}, i = this.toObject();
    let l;
    for (const r of c)
      if (s.indexOf(r) >= 0) {
        l = r;
        let h = 0;
        for (const d in t)
          h += this.matrix[d][r] * t[d], t[d] = 0;
        y(i[r]) && (h += i[r]);
        const f = Math.trunc(h);
        e[r] = f, t[r] = (h * 1e3 - f * 1e3) / 1e3;
        for (const d in i)
          c.indexOf(d) > c.indexOf(r) && S(this.matrix, i, d, e, r);
      } else y(i[r]) && (t[r] = i[r]);
    for (const r in t)
      t[r] !== 0 && (e[l] += r === l ? t[r] : t[r] / this.matrix[l][r]);
    return u(this, { values: e }, !0).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const s = {};
    for (const e of Object.keys(this.values))
      s[e] = this.values[e] === 0 ? 0 : -this.values[e];
    return u(this, { values: s }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(s) {
    if (!this.isValid || !s.isValid || !this.loc.equals(s.loc))
      return !1;
    function e(t, i) {
      return t === void 0 || t === 0 ? i === void 0 || i === 0 : t === i;
    }
    for (const t of c)
      if (!e(this.values[t], s.values[t]))
        return !1;
    return !0;
  }
}
export {
  U as accurateMatrix,
  z as casualMatrix,
  m as daysInMonthAccurate,
  o as daysInYearAccurate,
  n as default,
  b as lowOrderMatrix
};
