import type * as ClientTypes from '../gen/client'
import * as sdk from '../gen/client/sdk.gen'
import { client as baseClient } from '../gen/client/client.gen'
import { EventSource } from 'eventsource'
import type { Signal } from './types/signals'
import { EventEmitter } from './eventEmitter'

type ConversationIdParam = {
  conversationId: string
}

type NextTokenParam = {
  nextToken?: string
}

type UserIdParam = {
  userId: string
}

type MessageIdParam = {
  messageId: string
}

type EventIdParam = {
  eventId: string
}

const extractData = <T>(res: { data: T }): T => res.data

type Event =
  | Signal
  | {
      type: 'error'
      data: any
    }
  | {
      type: 'open'
      data: any
    }

export type Client = {
  createConversation: () => Promise<ClientTypes.CreateConversationResponse>
  getConversation: (params: ConversationIdParam) => Promise<ClientTypes.GetConversationResponse>
  deleteConversation: (params: ConversationIdParam) => Promise<ClientTypes.DeleteConversationResponse>
  listConversations: (params: NextTokenParam) => Promise<ClientTypes.ListConversationsResponse>
  listConversationMessages: (
    params: ConversationIdParam & NextTokenParam
  ) => Promise<ClientTypes.ListConversationMessagesResponse>
  addParticipant: (params: ConversationIdParam & UserIdParam) => Promise<ClientTypes.AddParticipantResponse>
  removeParticipant: (params: ConversationIdParam & UserIdParam) => Promise<ClientTypes.RemoveParticipantResponse>
  getParticipant: (params: ConversationIdParam & UserIdParam) => Promise<ClientTypes.GetParticipantResponse>
  listParticipants: (params: ConversationIdParam & NextTokenParam) => Promise<ClientTypes.ListParticipantsResponse>
  createMessage: (params: ClientTypes.CreateMessageBody) => Promise<ClientTypes.CreateMessageResponse>
  updateMessage: (params: MessageIdParam & ClientTypes.UpdateMessageBody) => Promise<ClientTypes.UpdateMessageResponse>
  getMessage: (params: MessageIdParam) => Promise<ClientTypes.GetMessageResponse>
  deleteMessage: (params: MessageIdParam) => Promise<ClientTypes.DeleteMessageResponse>
  createFile: (params: ClientTypes.CreateFileBody) => Promise<ClientTypes.CreateFileResponse>
  createUser: (params: ClientTypes.CreateUserBody) => Promise<ClientTypes.CreateUserResponse>
  getUser: (params: UserIdParam) => Promise<ClientTypes.GetUserResponse>
  updateUser: (params: ClientTypes.CreateUserBody) => Promise<ClientTypes.UpdateUserResponse>
  deleteUser: (params: UserIdParam) => Promise<ClientTypes.DeleteUserResponse>
  createEvent: (params: ClientTypes.CreateEventBody) => Promise<ClientTypes.CreateEventResponse>
  getEvent: (params: EventIdParam) => Promise<ClientTypes.GetEventResponse>
  listenConversation: (params: ConversationIdParam) => EventEmitter<Record<Event['type'], Event['data']>>['on']
}
const baseConfigs = {
  throwOnError: true,
} as const satisfies sdk.Options

export const createUser = ({ clientId, apiUrl }: { clientId: string; apiUrl?: string }) => {
  const baseUrl = `${apiUrl || baseClient.getConfig().baseUrl}/${clientId}`

  const configs = {
    ...baseConfigs,
    baseUrl,
  }
  return sdk.createUser({ ...configs, body: {} }).then(extractData)
}

export const createClient = ({
  userKey,
  clientId,
  apiUrl,
}: {
  userKey: string
  clientId: string
  apiUrl?: string
}): Client => {
  const headers = {
    'x-user-key': userKey,
  }

  const baseUrl = `${apiUrl || baseClient.getConfig().baseUrl}/${clientId}`
  const configs = {
    ...baseConfigs,
    baseUrl,
  }

  return {
    createConversation: () => sdk.createConversation({ ...configs, headers, body: {} }).then(extractData),
    getConversation: ({ conversationId }) =>
      sdk.getConversation({ ...configs, headers, path: { id: conversationId } }).then(extractData),
    deleteConversation: ({ conversationId }) =>
      sdk.deleteConversation({ ...configs, headers, path: { id: conversationId } }).then(extractData),
    listConversations: ({ nextToken }) =>
      sdk.listConversations({ ...configs, headers, query: { nextToken } }).then(extractData),
    listConversationMessages: ({ conversationId, nextToken }) =>
      sdk
        .listConversationMessages({
          ...configs,
          headers,
          path: { id: conversationId },
          query: { nextToken },
        })
        .then(extractData),
    addParticipant: ({ conversationId, userId }) =>
      sdk.addParticipant({ ...configs, headers, path: { id: conversationId }, body: { userId } }).then(extractData),
    removeParticipant: ({ conversationId, userId }) =>
      sdk.removeParticipant({ ...configs, headers, path: { id: conversationId, userId } }).then(extractData),
    getParticipant: ({ conversationId, userId }) =>
      sdk.getParticipant({ ...configs, headers, path: { id: conversationId, userId } }).then(extractData),
    listParticipants: ({ conversationId, nextToken }) =>
      sdk
        .listParticipants({ ...configs, headers, path: { id: conversationId }, query: { nextToken } })
        .then(extractData),
    createMessage: (body) => sdk.createMessage({ ...configs, headers, body }).then(extractData),
    updateMessage: ({ messageId, ...body }) =>
      sdk.updateMessage({ ...configs, headers, path: { id: messageId }, body }).then(extractData),
    getMessage: ({ messageId }) => sdk.getMessage({ ...configs, headers, path: { id: messageId } }).then(extractData),
    deleteMessage: ({ messageId }) =>
      sdk.deleteMessage({ ...configs, headers, path: { id: messageId } }).then(extractData),
    createFile: (body) => sdk.createFile({ ...configs, headers, body }).then(extractData),
    createUser: (body) => sdk.createUser({ ...configs, headers, body }).then(extractData),
    getUser: () => sdk.getUser({ ...configs, headers }).then(extractData),
    updateUser: (body) => sdk.updateUser({ ...configs, headers, body }).then(extractData),
    deleteUser: () => sdk.deleteUser({ ...configs, headers }).then(extractData),
    createEvent: (body) => sdk.createEvent({ ...configs, headers, body }).then(extractData),
    getEvent: ({ eventId }) => sdk.getEvent({ ...configs, headers, path: { id: eventId } }).then(extractData),
    listenConversation: ({ conversationId }) => {
      const MAX_RETRIES = 10
      const RETRY_INTERVAL = 3000 // ms
      let retryCount = 0
      let eventSource: EventSource | null = null
      const eventEmitter = new EventEmitter<Record<Event['type'], Event['data']>>()

      const connect = () => {
        if (eventSource) {
          eventSource.close()
        }

        const url = `${baseUrl}/conversations/${conversationId}/listen`

        eventSource = new EventSource(url, {
          fetch: (input, init) =>
            fetch(input, {
              ...init,
              headers: {
                ...init?.headers,
                ...headers,
                timeout: '60_000',
              },
            }),
        })

        eventSource.onopen = () => eventEmitter.emit('open')
        eventSource.onerror = (err) => {
          eventEmitter.emit('error', err)

          if (retryCount < MAX_RETRIES) {
            retryCount++
            setTimeout(() => connect(), RETRY_INTERVAL)
          }
        }
        eventSource.onmessage = (ev) => {
          const event = safeJsonParse(ev.data) as Signal
          eventEmitter.emit(event.type, event.data)
        }
      }
      connect()
      return eventEmitter.on.bind(eventEmitter)
    },
  }
}

const safeJsonParse = (data: any) => {
  try {
    return JSON.parse(data)
  } catch {
    return data
  }
}
