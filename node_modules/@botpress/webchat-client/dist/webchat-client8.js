class E extends Error {
  constructor(d, s) {
    super(d), this.name = "ParseError", this.type = s.type, this.field = s.field, this.value = s.value, this.line = s.line;
  }
}
function x(n) {
}
function I(n) {
  if (typeof n == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: d = x, onError: s = x, onRetry: r = x, onComment: a } = n;
  let i = "", o = !0, f, c = "", p = "";
  function b(e) {
    const t = o ? e.replace(/^\xEF\xBB\xBF/, "") : e, [l, u] = w(`${i}${t}`);
    for (const h of l)
      y(h);
    i = u, o = !1;
  }
  function y(e) {
    if (e === "") {
      v();
      return;
    }
    if (e.startsWith(":")) {
      a && a(e.slice(e.startsWith(": ") ? 2 : 1));
      return;
    }
    const t = e.indexOf(":");
    if (t !== -1) {
      const l = e.slice(0, t), u = e[t + 1] === " " ? 2 : 1, h = e.slice(t + u);
      m(l, h, e);
      return;
    }
    m(e, "", e);
  }
  function m(e, t, l) {
    switch (e) {
      case "event":
        p = t;
        break;
      case "data":
        c = `${c}${t}
`;
        break;
      case "id":
        f = t.includes("\0") ? void 0 : t;
        break;
      case "retry":
        /^\d+$/.test(t) ? r(parseInt(t, 10)) : s(
          new E(`Invalid \`retry\` value: "${t}"`, {
            type: "invalid-retry",
            value: t,
            line: l
          })
        );
        break;
      default:
        s(
          new E(
            `Unknown field "${e.length > 20 ? `${e.slice(0, 20)}â€¦` : e}"`,
            { type: "unknown-field", field: e, value: t, line: l }
          )
        );
        break;
    }
  }
  function v() {
    c.length > 0 && d({
      id: f,
      event: p || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: c.endsWith(`
`) ? c.slice(0, -1) : c
    }), f = void 0, c = "", p = "";
  }
  function $(e = {}) {
    i && e.consume && y(i), o = !0, f = void 0, c = "", p = "", i = "";
  }
  return { feed: b, reset: $ };
}
function w(n) {
  const d = [];
  let s = "", r = 0;
  for (; r < n.length; ) {
    const a = n.indexOf("\r", r), i = n.indexOf(`
`, r);
    let o = -1;
    if (a !== -1 && i !== -1 ? o = Math.min(a, i) : a !== -1 ? o = a : i !== -1 && (o = i), o === -1) {
      s = n.slice(r);
      break;
    } else {
      const f = n.slice(r, o);
      d.push(f), r = o + 1, n[r - 1] === "\r" && n[r] === `
` && r++;
    }
  }
  return [d, s];
}
export {
  E as ParseError,
  I as createParser
};
