import { createParser as X } from "./webchat-client8.js";
class q extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(e, i) {
    var r, c;
    super(e), this.code = (r = i == null ? void 0 : i.code) != null ? r : void 0, this.message = (c = i == null ? void 0 : i.message) != null ? c : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](e, i, r) {
    return r(B(this), i);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](e, i) {
    return e(B(this), i);
  }
}
function Y(t) {
  const e = globalThis.DOMException;
  return typeof e == "function" ? new e(t, "SyntaxError") : new SyntaxError(t);
}
function T(t) {
  return t instanceof Error ? "errors" in t && Array.isArray(t.errors) ? t.errors.map(T).join(", ") : "cause" in t && t.cause instanceof Error ? `${t}: ${T(t.cause)}` : t.message : `${t}`;
}
function B(t) {
  return {
    type: t.type,
    message: t.message,
    code: t.code,
    defaultPrevented: t.defaultPrevented,
    cancelable: t.cancelable,
    timeStamp: t.timeStamp
  };
}
var z = (t) => {
  throw TypeError(t);
}, D = (t, e, i) => e.has(t) || z("Cannot " + i), s = (t, e, i) => (D(t, e, "read from private field"), i ? i.call(t) : e.get(t)), a = (t, e, i) => e.has(t) ? z("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, i), n = (t, e, i, r) => (D(t, e, "write to private field"), e.set(t, i), i), d = (t, e, i) => (D(t, e, "access private method"), i), h, u, E, W, O, M, _, N, p, f, g, w, C, l, L, b, R, H, x, I, y, U, A;
class S extends EventTarget {
  constructor(e, i) {
    var r, c;
    super(), a(this, l), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, a(this, h), a(this, u), a(this, E), a(this, W), a(this, O), a(this, M), a(this, _), a(this, N, null), a(this, p), a(this, f), a(this, g, null), a(this, w, null), a(this, C, null), a(this, b, async (o) => {
      var m;
      s(this, f).reset();
      const { body: k, redirected: J, status: v, headers: K } = o;
      if (v === 204) {
        d(this, l, y).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (J ? n(this, E, new URL(o.url)) : n(this, E, void 0), v !== 200) {
        d(this, l, y).call(this, `Non-200 status code (${v})`, v);
        return;
      }
      if (!(K.get("content-type") || "").startsWith("text/event-stream")) {
        d(this, l, y).call(this, 'Invalid content type, expected "text/event-stream"', v);
        return;
      }
      if (s(this, h) === this.CLOSED)
        return;
      n(this, h, this.OPEN);
      const G = new Event("open");
      if ((m = s(this, C)) == null || m.call(this, G), this.dispatchEvent(G), typeof k != "object" || !k || !("getReader" in k)) {
        d(this, l, y).call(this, "Invalid response body, expected a web ReadableStream", v), this.close();
        return;
      }
      const Q = new TextDecoder(), V = k.getReader();
      let P = !0;
      do {
        const { done: $, value: F } = await V.read();
        F && s(this, f).feed(Q.decode(F, { stream: !$ })), $ && (P = !1, s(this, f).reset(), d(this, l, U).call(this));
      } while (P);
    }), a(this, R, (o) => {
      n(this, p, void 0), !(o.name === "AbortError" || o.type === "aborted") && d(this, l, U).call(this, T(o));
    }), a(this, x, (o) => {
      typeof o.id == "string" && n(this, N, o.id);
      const m = new MessageEvent(o.event || "message", {
        data: o.data,
        origin: s(this, E) ? s(this, E).origin : s(this, u).origin,
        lastEventId: o.id || ""
      });
      s(this, w) && (!o.event || o.event === "message") && s(this, w).call(this, m), this.dispatchEvent(m);
    }), a(this, I, (o) => {
      n(this, M, o);
    }), a(this, A, () => {
      n(this, _, void 0), s(this, h) === this.CONNECTING && d(this, l, L).call(this);
    });
    try {
      if (e instanceof URL)
        n(this, u, e);
      else if (typeof e == "string")
        n(this, u, new URL(e, Z()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw Y("An invalid or illegal string was specified");
    }
    n(this, f, X({
      onEvent: s(this, x),
      onRetry: s(this, I)
    })), n(this, h, this.CONNECTING), n(this, M, 3e3), n(this, O, (r = i == null ? void 0 : i.fetch) != null ? r : globalThis.fetch), n(this, W, (c = i == null ? void 0 : i.withCredentials) != null ? c : !1), d(this, l, L).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return s(this, h);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return s(this, u).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return s(this, W);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return s(this, g);
  }
  set onerror(e) {
    n(this, g, e);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return s(this, w);
  }
  set onmessage(e) {
    n(this, w, e);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return s(this, C);
  }
  set onopen(e) {
    n(this, C, e);
  }
  addEventListener(e, i, r) {
    const c = i;
    super.addEventListener(e, c, r);
  }
  removeEventListener(e, i, r) {
    const c = i;
    super.removeEventListener(e, c, r);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    s(this, _) && clearTimeout(s(this, _)), s(this, h) !== this.CLOSED && (s(this, p) && s(this, p).abort(), n(this, h, this.CLOSED), n(this, p, void 0));
  }
}
h = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), O = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
L = function() {
  n(this, h, this.CONNECTING), n(this, p, new AbortController()), s(this, O)(s(this, u), d(this, l, H).call(this)).then(s(this, b)).catch(s(this, R));
}, b = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
H = function() {
  var t;
  const e = {
    // [spec] Let `corsAttributeState` be `Anonymous`…
    // [spec] …will have their mode set to "cors"…
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...s(this, N) ? { "Last-Event-ID": s(this, N) } : void 0 },
    cache: "no-store",
    signal: (t = s(this, p)) == null ? void 0 : t.signal
  };
  return "window" in globalThis && (e.credentials = this.withCredentials ? "include" : "same-origin"), e;
}, x = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
y = function(t, e) {
  var i;
  s(this, h) !== this.CLOSED && n(this, h, this.CLOSED);
  const r = new q("error", { code: e, message: t });
  (i = s(this, g)) == null || i.call(this, r), this.dispatchEvent(r);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
U = function(t, e) {
  var i;
  if (s(this, h) === this.CLOSED)
    return;
  n(this, h, this.CONNECTING);
  const r = new q("error", { code: e, message: t });
  (i = s(this, g)) == null || i.call(this, r), this.dispatchEvent(r), n(this, _, setTimeout(s(this, A), s(this, M)));
}, A = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
S.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
S.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
S.CLOSED = 2;
function Z() {
  const t = "document" in globalThis ? globalThis.document : void 0;
  return t && typeof t == "object" && "baseURI" in t && typeof t.baseURI == "string" ? t.baseURI : void 0;
}
export {
  q as ErrorEvent,
  S as EventSource
};
