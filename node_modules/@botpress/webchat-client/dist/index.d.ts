/**
 * Add a [Participant](#schema_user) to a [Conversation](#schema_conversation).
 */
declare const addParticipant: <ThrowOnError extends boolean = false>(options: Options<AddParticipantData, ThrowOnError>) => RequestResult<{
    participant: User;
}, {
    participant: User;
}, ThrowOnError>;

/**
 * Participant data
 */
export declare type AddParticipantBody = {
    /**
     * User id
     */
    userId: string;
};

export declare type AddParticipantData = {
    /**
     * Participant data
     */
    body?: AddParticipantBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
    };
    query?: never;
    url: '/conversations/{id}/participants';
};

export declare type AddParticipantError = AddParticipantErrors[keyof AddParticipantErrors];

export declare type AddParticipantErrors = {
    /**
     * Returns the [Participant](#schema_user) object
     */
    default: {
        participant: User;
    };
};

export declare type AddParticipantResponse = AddParticipantResponses[keyof AddParticipantResponses];

export declare type AddParticipantResponses = {
    /**
     * Returns the [Participant](#schema_user) object
     */
    200: {
        participant: User;
    };
};

declare type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';

declare interface Auth {
    /**
     * Which part of the request do we use to send the auth?
     *
     * @default 'header'
     */
    in?: 'header' | 'query' | 'cookie';
    /**
     * Header or query parameter name.
     *
     * @default 'Authorization'
     */
    name?: string;
    scheme?: 'basic' | 'bearer';
    type: 'apiKey' | 'http';
}

declare type AuthToken = string | undefined;

declare type BodySerializer = (body: any) => any;

declare type BuildUrlFn = <TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
}>(options: Pick<TData, 'url'> & Options_2<TData>) => string;

declare type CallbackFn<T> = (args: T) => void;

declare interface Client$1<RequestFn = never, Config = unknown, MethodFn = never, BuildUrlFn = never> {
    /**
     * Returns the final request URL.
     */
    buildUrl: BuildUrlFn;
    connect: MethodFn;
    delete: MethodFn;
    get: MethodFn;
    getConfig: () => Config;
    head: MethodFn;
    options: MethodFn;
    patch: MethodFn;
    post: MethodFn;
    put: MethodFn;
    request: RequestFn;
    setConfig: (config: Config) => Config;
    trace: MethodFn;
}

export declare type Client = {
    createConversation: () => Promise<ClientTypes_2.CreateConversationResponse>;
    getConversation: (params: ConversationIdParam) => Promise<ClientTypes_2.GetConversationResponse>;
    deleteConversation: (params: ConversationIdParam) => Promise<ClientTypes_2.DeleteConversationResponse>;
    listConversations: (params: NextTokenParam) => Promise<ClientTypes_2.ListConversationsResponse>;
    listConversationMessages: (params: ConversationIdParam & NextTokenParam) => Promise<ClientTypes_2.ListConversationMessagesResponse>;
    addParticipant: (params: ConversationIdParam & UserIdParam) => Promise<ClientTypes_2.AddParticipantResponse>;
    removeParticipant: (params: ConversationIdParam & UserIdParam) => Promise<ClientTypes_2.RemoveParticipantResponse>;
    getParticipant: (params: ConversationIdParam & UserIdParam) => Promise<ClientTypes_2.GetParticipantResponse>;
    listParticipants: (params: ConversationIdParam & NextTokenParam) => Promise<ClientTypes_2.ListParticipantsResponse>;
    createMessage: (params: ClientTypes_2.CreateMessageBody) => Promise<ClientTypes_2.CreateMessageResponse>;
    updateMessage: (params: MessageIdParam & ClientTypes_2.UpdateMessageBody) => Promise<ClientTypes_2.UpdateMessageResponse>;
    getMessage: (params: MessageIdParam) => Promise<ClientTypes_2.GetMessageResponse>;
    deleteMessage: (params: MessageIdParam) => Promise<ClientTypes_2.DeleteMessageResponse>;
    createFile: (params: ClientTypes_2.CreateFileBody) => Promise<ClientTypes_2.CreateFileResponse>;
    createUser: (params: ClientTypes_2.CreateUserBody) => Promise<ClientTypes_2.CreateUserResponse>;
    getUser: (params: UserIdParam) => Promise<ClientTypes_2.GetUserResponse>;
    updateUser: (params: ClientTypes_2.CreateUserBody) => Promise<ClientTypes_2.UpdateUserResponse>;
    deleteUser: (params: UserIdParam) => Promise<ClientTypes_2.DeleteUserResponse>;
    createEvent: (params: ClientTypes_2.CreateEventBody) => Promise<ClientTypes_2.CreateEventResponse>;
    getEvent: (params: EventIdParam) => Promise<ClientTypes_2.GetEventResponse>;
    listenConversation: (params: ConversationIdParam) => EventEmitter<Record<Event_3['type'], Event_3['data']>>['on'];
};

declare type Client_2 = Client$1<RequestFn, Config, MethodFn, BuildUrlFn> & {
    interceptors: Middleware<Request, Response, unknown, RequestOptions>;
};

export declare type ClientOptions = {
    baseUrl: 'https://webchat.botpress.cloud/' | (string & {});
};

declare interface ClientOptions_2 {
    baseUrl?: string;
    throwOnError?: boolean;
}

declare namespace ClientTypes_2 {
    export {
        User,
        Conversation,
        Message,
        Event_2 as Event,
        File_2 as File,
        CreateConversationBody,
        AddParticipantBody,
        CreateMessageBody,
        UpdateMessageBody,
        SelectMessageBody,
        CreateUserBody,
        UpdateUserBody,
        CreateEventBody,
        CreateFileBody,
        DeleteConversationData,
        DeleteConversationErrors,
        DeleteConversationError,
        DeleteConversationResponses,
        DeleteConversationResponse,
        GetConversationData,
        GetConversationErrors,
        GetConversationError,
        GetConversationResponses,
        GetConversationResponse,
        ListConversationsData,
        ListConversationsErrors,
        ListConversationsError,
        ListConversationsResponses,
        ListConversationsResponse,
        CreateConversationData,
        CreateConversationErrors,
        CreateConversationError,
        CreateConversationResponses,
        CreateConversationResponse,
        ListenConversationData,
        ListenConversationErrors,
        ListenConversationError,
        ListenConversationResponses,
        ListenConversationResponse,
        ListConversationMessagesData,
        ListConversationMessagesErrors,
        ListConversationMessagesError,
        ListConversationMessagesResponses,
        ListConversationMessagesResponse,
        ListParticipantsData,
        ListParticipantsErrors,
        ListParticipantsError,
        ListParticipantsResponses,
        ListParticipantsResponse,
        AddParticipantData,
        AddParticipantErrors,
        AddParticipantError,
        AddParticipantResponses,
        AddParticipantResponse,
        RemoveParticipantData,
        RemoveParticipantErrors,
        RemoveParticipantError,
        RemoveParticipantResponses,
        RemoveParticipantResponse,
        GetParticipantData,
        GetParticipantErrors,
        GetParticipantError,
        GetParticipantResponses,
        GetParticipantResponse,
        DeleteMessageData,
        DeleteMessageErrors,
        DeleteMessageError,
        DeleteMessageResponses,
        DeleteMessageResponse,
        GetMessageData,
        GetMessageErrors,
        GetMessageError,
        GetMessageResponses,
        GetMessageResponse,
        UpdateMessageData,
        UpdateMessageErrors,
        UpdateMessageError,
        UpdateMessageResponses,
        UpdateMessageResponse,
        CreateMessageData,
        CreateMessageErrors,
        CreateMessageError,
        CreateMessageResponses,
        CreateMessageResponse,
        SelectMessageData,
        SelectMessageErrors,
        SelectMessageError,
        SelectMessageResponses,
        SelectMessageResponse,
        DeleteUserData,
        DeleteUserErrors,
        DeleteUserError,
        DeleteUserResponses,
        DeleteUserResponse,
        GetUserData,
        GetUserErrors,
        GetUserError,
        GetUserResponses,
        GetUserResponse,
        UpdateUserData,
        UpdateUserErrors,
        UpdateUserError,
        UpdateUserResponses,
        UpdateUserResponse,
        CreateUserData,
        CreateUserErrors,
        CreateUserError,
        CreateUserResponses,
        CreateUserResponse,
        GetEventData,
        GetEventErrors,
        GetEventError,
        GetEventResponses,
        GetEventResponse,
        CreateEventData,
        CreateEventErrors,
        CreateEventError,
        CreateEventResponses,
        CreateEventResponse,
        CreateFileData,
        CreateFileErrors,
        CreateFileError,
        CreateFileResponses,
        CreateFileResponse,
        ClientOptions,
        Options,
        deleteConversation,
        getConversation,
        listConversations,
        createConversation,
        listenConversation,
        listConversationMessages,
        listParticipants,
        addParticipant,
        removeParticipant,
        getParticipant,
        deleteMessage,
        getMessage,
        updateMessage,
        createMessage,
        selectMessage,
        deleteUser,
        getUser,
        updateUser,
        createUser_2 as createUser,
        getEvent,
        createEvent,
        createFile
    }
}

declare interface Config$1 {
    /**
     * Auth token or a function returning auth token. The resolved value will be
     * added to the request payload as defined by its `security` array.
     */
    auth?: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken;
    /**
     * A function for serializing request body parameter. By default,
     * {@link JSON.stringify()} will be used.
     */
    bodySerializer?: BodySerializer | null;
    /**
     * An object containing any HTTP headers that you want to pre-populate your
     * `Headers` object with.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
     */
    headers?: RequestInit['headers'] | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
    /**
     * The request method.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#method See more}
     */
    method?: 'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE';
    /**
     * A function for serializing request query parameters. By default, arrays
     * will be exploded in form style, objects will be exploded in deepObject
     * style, and reserved characters are percent-encoded.
     *
     * This method will have no effect if the native `paramsSerializer()` Axios
     * API function is used.
     *
     * {@link https://swagger.io/docs/specification/serialization/#query View examples}
     */
    querySerializer?: QuerySerializer | QuerySerializerOptions;
    /**
     * A function transforming response data before it's returned. This is useful
     * for post-processing data, e.g. converting ISO strings into Date objects.
     */
    responseTransformer?: (data: unknown) => Promise<unknown>;
    /**
     * A function validating response data. This is useful if you want to ensure
     * the response conforms to the desired shape, so it can be safely passed to
     * the transformers and returned to the user.
     */
    responseValidator?: (data: unknown) => Promise<unknown>;
}

declare interface Config<T extends ClientOptions_2 = ClientOptions_2> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config$1 {
    /**
     * Base URL for all requests made by this client.
     */
    baseUrl?: T['baseUrl'];
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: (request: Request) => ReturnType<typeof fetch>;
    /**
     * Please don't use the Fetch client for Next.js applications. The `next`
     * options won't have any effect.
     *
     * Install {@link https://www.npmjs.com/package/@hey-api/client-next `@hey-api/client-next`} instead.
     */
    next?: never;
    /**
     * Return the response data parsed in a specified format. By default, `auto`
     * will infer the appropriate method from the `Content-Type` response header.
     * You can override this behavior with any of the {@link Body} methods.
     * Select `stream` if you don't want to parse response data at all.
     *
     * @default 'auto'
     */
    parseAs?: Exclude<keyof Body, 'body' | 'bodyUsed'> | 'auto' | 'stream';
    /**
     * Throw an error instead of returning it in the response?
     *
     * @default false
     */
    throwOnError?: T['throwOnError'];
}

export declare type Conversation = {
    /**
     * Id of the [Conversation](#schema_conversation)
     */
    id: string;
    /**
     * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
     */
    updatedAt: string;
};

declare type ConversationIdParam = {
    conversationId: string;
};

export declare const createClient: ({ userKey, clientId, apiUrl, }: {
    userKey: string;
    clientId: string;
    apiUrl?: string;
}) => Client;

/**
 * Creates a new [Conversation](#schema_conversation)
 */
declare const createConversation: <ThrowOnError extends boolean = false>(options: Options<CreateConversationData, ThrowOnError>) => RequestResult<{
    conversation: Conversation;
}, {
    conversation: Conversation;
}, ThrowOnError>;

/**
 * Conversation properties
 */
export declare type CreateConversationBody = {
    _?: string;
};

export declare type CreateConversationData = {
    /**
     * Conversation data
     */
    body?: CreateConversationBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: never;
    url: '/conversations';
};

export declare type CreateConversationError = CreateConversationErrors[keyof CreateConversationErrors];

export declare type CreateConversationErrors = {
    /**
     * Returns a [Conversation](#schema_conversation)
     */
    default: {
        conversation: Conversation;
    };
};

export declare type CreateConversationResponse = CreateConversationResponses[keyof CreateConversationResponses];

export declare type CreateConversationResponses = {
    /**
     * Returns a [Conversation](#schema_conversation)
     */
    201: {
        conversation: Conversation;
    };
};

/**
 * Creates a new [Event](#schema_event)
 */
declare const createEvent: <ThrowOnError extends boolean = false>(options: Options<CreateEventData, ThrowOnError>) => RequestResult<{
    event: Event_2;
}, {
    event: Event_2;
}, ThrowOnError>;

/**
 * Event data
 */
export declare type CreateEventBody = {
    /**
     * Payload is the content type of the event.
     */
    payload: {
        type: 'custom';
        data: {};
    } | {
        type: 'conversation_started';
        data: {};
    };
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Whether to bind the event to the conversation. Defaults to true
     */
    bindConversation?: boolean;
    /**
     * Whether to bind the event to the user. Defaults to true
     */
    bindUser?: boolean;
};

export declare type CreateEventData = {
    /**
     * Event data
     */
    body?: CreateEventBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: never;
    url: '/events';
};

export declare type CreateEventError = CreateEventErrors[keyof CreateEventErrors];

export declare type CreateEventErrors = {
    /**
     * Returns a [Event](#schema_event).
     */
    default: {
        event: Event_2;
    };
};

export declare type CreateEventResponse = CreateEventResponses[keyof CreateEventResponses];

export declare type CreateEventResponses = {
    /**
     * Returns a [Event](#schema_event).
     */
    201: {
        event: Event_2;
    };
};

/**
 * Creates a new file and returns it's upload URL.
 */
declare const createFile: <ThrowOnError extends boolean = false>(options: Options<CreateFileData, ThrowOnError>) => RequestResult<{
    file: File_2;
}, {
    file: File_2;
}, ThrowOnError>;

/**
 * File data
 */
export declare type CreateFileBody = {
    /**
     * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
     */
    key: string;
    /**
     * File size in bytes. This will count against your File Storage quota. If the index parameter is set to true, this will also count against your Vector DB Storage quota.
     */
    size: number;
    /**
     * File access policies. Add "public_content" to allow public access to the file content. Add "integrations" to allow read, search and list operations for any integration installed in the bot.
     */
    accessPolicies?: Array<'integrations' | 'public_content'>;
    /**
     * Whether the file should be indexed. If true, the file content will be searchable in the Vector DB. This will count against your Vector DB Storage quota.
     */
    index?: boolean;
    /**
     * File content type. If omitted, the content type will be inferred from the file extension (if any) specified in key. If a content type cannot be inferred, the default is "application/octet-stream".
     */
    contentType?: string;
    /**
     * File tags. These are used for search and filtering operations.
     */
    tags?: {
        [key: string]: string;
    };
    /**
     * The timestamp (in ISO 8601 format) when the file will be automatically deleted from the file API.
     */
    expiresAt?: string;
};

export declare type CreateFileData = {
    /**
     * File data
     */
    body?: CreateFileBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: never;
    url: '/files';
};

export declare type CreateFileError = CreateFileErrors[keyof CreateFileErrors];

export declare type CreateFileErrors = {
    /**
     * Returns a file
     */
    default: {
        file: File_2;
    };
};

export declare type CreateFileResponse = CreateFileResponses[keyof CreateFileResponses];

export declare type CreateFileResponses = {
    /**
     * Returns a file
     */
    201: {
        file: File_2;
    };
};

/**
 * Creates a new [Message](#schema_message)
 */
declare const createMessage: <ThrowOnError extends boolean = false>(options: Options<CreateMessageData, ThrowOnError>) => RequestResult<{
    message: Message;
}, {
    message: Message;
}, ThrowOnError>;

/**
 * Message data
 */
export declare type CreateMessageBody = {
    /**
     * Payload is the content of the message.
     */
    payload: {
        audioUrl: string;
        type: 'audio';
    } | {
        title: string;
        subtitle?: string;
        imageUrl?: string;
        actions: Array<{
            action: 'postback' | 'url' | 'say';
            label: string;
            value: string;
        }>;
        type: 'card';
    } | {
        items: Array<{
            title: string;
            subtitle?: string;
            imageUrl?: string;
            actions: Array<{
                action: 'postback' | 'url' | 'say';
                label: string;
                value: string;
            }>;
        }>;
        type: 'carousel';
    } | {
        text: string;
        options: Array<{
            label: string;
            value: string;
        }>;
        disableFreeText?: boolean;
        type: 'choice';
    } | {
        text: string;
        options: Array<{
            label: string;
            value: string;
        }>;
        disableFreeText?: boolean;
        type: 'dropdown';
    } | {
        fileUrl: string;
        title?: string;
        type: 'file';
    } | {
        imageUrl: string;
        type: 'image';
    } | {
        latitude: number;
        longitude: number;
        address?: string;
        title?: string;
        type: 'location';
    } | {
        text: string;
        value?: string;
        type: 'text';
    } | {
        videoUrl: string;
        type: 'video';
    } | {
        items: Array<{
            type: 'text';
            payload: {
                text: string;
                value?: string;
            };
        } | {
            type: 'markdown';
            payload: {
                markdown: string;
            };
        } | {
            type: 'image';
            payload: {
                imageUrl: string;
            };
        } | {
            type: 'audio';
            payload: {
                audioUrl: string;
            };
        } | {
            type: 'video';
            payload: {
                videoUrl: string;
            };
        } | {
            type: 'file';
            payload: {
                fileUrl: string;
                title?: string;
            };
        } | {
            type: 'location';
            payload: {
                latitude: number;
                longitude: number;
                address?: string;
                title?: string;
            };
        }>;
        type: 'bloc';
    } | {
        markdown: string;
        type: 'markdown';
    } | {
        url: string;
        name: string;
        data?: unknown;
        type: 'custom';
    } | {
        reaction: string;
        type: 'reaction';
    };
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Metadata of the message
     */
    metadata?: {};
    /**
     * ID of the message this message is replying to
     */
    replyTo?: string;
};

export declare type CreateMessageData = {
    /**
     * Message data
     */
    body?: CreateMessageBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: never;
    url: '/messages';
};

export declare type CreateMessageError = CreateMessageErrors[keyof CreateMessageErrors];

export declare type CreateMessageErrors = {
    /**
     * Returns a [Message](#schema_message).
     */
    default: {
        message: Message;
    };
};

export declare type CreateMessageResponse = CreateMessageResponses[keyof CreateMessageResponses];

export declare type CreateMessageResponses = {
    /**
     * Returns a [Message](#schema_message).
     */
    201: {
        message: Message;
    };
};

export declare const createUser: ({ clientId, apiUrl }: {
    clientId: string;
    apiUrl?: string;
}) => Promise<{
    user: ClientTypes_2.User;
    key: string;
}>;

/**
 * Creates a new [User](#schema_user)
 */
declare const createUser_2: <ThrowOnError extends boolean = false>(options?: Options<CreateUserData, ThrowOnError>) => RequestResult<{
    user: User;
    key: string;
}, {
    user: User;
    key: string;
}, ThrowOnError>;

/**
 * User data
 */
export declare type CreateUserBody = {
    /**
     * Name of the [User](#schema_user) (not a unique identifier)
     */
    name?: string;
    /**
     * Picture url of the [User](#schema_user)
     */
    pictureUrl?: string;
    /**
     * User data
     */
    userData?: {};
};

export declare type CreateUserData = {
    /**
     * User data
     */
    body?: CreateUserBody;
    path?: never;
    query?: never;
    url: '/users';
};

export declare type CreateUserError = CreateUserErrors[keyof CreateUserErrors];

export declare type CreateUserErrors = {
    /**
     * Returns a [User](#schema_user)
     */
    default: {
        user: User;
        key: string;
    };
};

export declare type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];

export declare type CreateUserResponses = {
    /**
     * Returns a [User](#schema_user)
     */
    201: {
        user: User;
        key: string;
    };
};

declare type Custom = {
    type: 'custom';
    data: {
        event: {
            [k: string]: any;
        };
    };
};

/**
 * Permanently deletes a [Conversation](#schema_conversation). It cannot be undone. Also immediately deletes corresponding [Messages](#schema_message).
 */
declare const deleteConversation: <ThrowOnError extends boolean = false>(options: Options<DeleteConversationData, ThrowOnError>) => RequestResult<{
    [key: string]: never;
}, {
    [key: string]: never;
}, ThrowOnError>;

export declare type DeleteConversationData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
    };
    query?: never;
    url: '/conversations/{id}';
};

export declare type DeleteConversationError = DeleteConversationErrors[keyof DeleteConversationErrors];

export declare type DeleteConversationErrors = {
    /**
     * Returns the [Conversation](#schema_conversation) object that was deleted
     */
    default: {
        [key: string]: never;
    };
};

export declare type DeleteConversationResponse = DeleteConversationResponses[keyof DeleteConversationResponses];

export declare type DeleteConversationResponses = {
    /**
     * Returns the [Conversation](#schema_conversation) object that was deleted
     */
    200: {
        [key: string]: never;
    };
};

/**
 * Permanently deletes a [Message](#schema_message). It cannot be undone.
 */
declare const deleteMessage: <ThrowOnError extends boolean = false>(options: Options<DeleteMessageData, ThrowOnError>) => RequestResult<{
    [key: string]: never;
}, {
    [key: string]: never;
}, ThrowOnError>;

export declare type DeleteMessageData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Message id
         */
        id: string;
    };
    query?: never;
    url: '/messages/{id}';
};

export declare type DeleteMessageError = DeleteMessageErrors[keyof DeleteMessageErrors];

export declare type DeleteMessageErrors = {
    /**
     * Returns the [Message](#schema_message) object that was deleted
     */
    default: {
        [key: string]: never;
    };
};

export declare type DeleteMessageResponse = DeleteMessageResponses[keyof DeleteMessageResponses];

export declare type DeleteMessageResponses = {
    /**
     * Returns the [Message](#schema_message) object that was deleted
     */
    200: {
        [key: string]: never;
    };
};

/**
 * Permanently deletes a [User](#schema_user). It cannot be undone.
 */
declare const deleteUser: <ThrowOnError extends boolean = false>(options: Options<DeleteUserData, ThrowOnError>) => RequestResult<{
    [key: string]: never;
}, {
    [key: string]: never;
}, ThrowOnError>;

export declare type DeleteUserData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: never;
    url: '/users/me';
};

export declare type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];

export declare type DeleteUserErrors = {
    /**
     * Returns the [User](#schema_user) object that was deleted
     */
    default: {
        [key: string]: never;
    };
};

export declare type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];

export declare type DeleteUserResponses = {
    /**
     * Returns the [User](#schema_user) object that was deleted
     */
    200: {
        [key: string]: never;
    };
};

declare type ErrInterceptor<Err, Res, Req, Options> = (error: Err, response: Res, request: Req, options: Options) => Err | Promise<Err>;

declare type Event_2 = {
    /**
     * ID of the [Event](#schema_event).
     */
    id: string;
    /**
     * Creation date of the [Event](#schema_event) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Payload is the content of the event.
     */
    payload: {
        type: 'custom';
        data: {};
    } | {
        type: 'conversation_started';
        data: {};
    };
    /**
     * ID of the [Conversation](#schema_conversation).
     */
    conversationId: string;
    /**
     * ID of the [User](#schema_user).
     */
    userId: string;
};
export { Event_2 as Event }

declare type Event_3 = Signal | {
    type: 'error';
    data: any;
} | {
    type: 'open';
    data: any;
};

declare class EventEmitter<T extends Record<string, any>> {
    private readonly eventMap;
    constructor();
    on<U extends keyof T>(event: U, callback: CallbackFn<T[U]>): () => void;
    emit<U extends keyof T>(event: U, arg?: T[U]): void;
}

declare type EventIdParam = {
    eventId: string;
};

declare type File_2 = {
    id: string;
    botId: string;
    key: string;
    size: number | null;
    contentType: string;
    tags: {
        [key: string]: string;
    };
    createdAt: string;
    updatedAt: string;
    accessPolicies: Array<'integrations' | 'public_content'>;
    index: boolean;
    url: string;
    status: 'upload_pending' | 'upload_failed' | 'upload_completed' | 'indexing_pending' | 'indexing_failed' | 'indexing_completed';
    failedStatusReason?: string;
    uploadUrl: string;
};
export { File_2 as File }

/**
 * Retrieves the [Conversation](#schema_conversation) object for a valid identifier.
 */
declare const getConversation: <ThrowOnError extends boolean = false>(options: Options<GetConversationData, ThrowOnError>) => RequestResult<{
    conversation: Conversation;
}, {
    conversation: Conversation;
}, ThrowOnError>;

export declare type GetConversationData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
    };
    query?: never;
    url: '/conversations/{id}';
};

export declare type GetConversationError = GetConversationErrors[keyof GetConversationErrors];

export declare type GetConversationErrors = {
    /**
     * Returns a [Conversation](#schema_conversation) object if a valid identifier was provided
     */
    default: {
        conversation: Conversation;
    };
};

export declare type GetConversationResponse = GetConversationResponses[keyof GetConversationResponses];

export declare type GetConversationResponses = {
    /**
     * Returns a [Conversation](#schema_conversation) object if a valid identifier was provided
     */
    200: {
        conversation: Conversation;
    };
};

/**
 * Retrieves the [Event](#schema_event) object for a valid identifier.
 */
declare const getEvent: <ThrowOnError extends boolean = false>(options: Options<GetEventData, ThrowOnError>) => RequestResult<{
    event: Event_2;
}, {
    event: Event_2;
}, ThrowOnError>;

export declare type GetEventData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Id of the Event
         */
        id: string;
    };
    query?: never;
    url: '/events/{id}';
};

export declare type GetEventError = GetEventErrors[keyof GetEventErrors];

export declare type GetEventErrors = {
    /**
     * Returns an [Event](#schema_event) object if a valid identifier was provided
     */
    default: {
        event: Event_2;
    };
};

export declare type GetEventResponse = GetEventResponses[keyof GetEventResponses];

export declare type GetEventResponses = {
    /**
     * Returns an [Event](#schema_event) object if a valid identifier was provided
     */
    200: {
        event: Event_2;
    };
};

/**
 * Retrieves the [Message](#schema_message) object for a valid identifier.
 */
declare const getMessage: <ThrowOnError extends boolean = false>(options: Options<GetMessageData, ThrowOnError>) => RequestResult<{
    message: Message;
}, {
    message: Message;
}, ThrowOnError>;

export declare type GetMessageData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Id of the Message
         */
        id: string;
    };
    query?: never;
    url: '/messages/{id}';
};

export declare type GetMessageError = GetMessageErrors[keyof GetMessageErrors];

export declare type GetMessageErrors = {
    /**
     * Returns a [Message](#schema_message) object if a valid identifier was provided
     */
    default: {
        message: Message;
    };
};

export declare type GetMessageResponse = GetMessageResponses[keyof GetMessageResponses];

export declare type GetMessageResponses = {
    /**
     * Returns a [Message](#schema_message) object if a valid identifier was provided
     */
    200: {
        message: Message;
    };
};

/**
 * Retrieves a [Participant](#schema_user) from a [Conversation](#schema_conversation).
 */
declare const getParticipant: <ThrowOnError extends boolean = false>(options: Options<GetParticipantData, ThrowOnError>) => RequestResult<{
    participant: User;
}, {
    participant: User;
}, ThrowOnError>;

export declare type GetParticipantData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
        /**
         * User id
         */
        userId: string;
    };
    query?: never;
    url: '/conversations/{id}/participants/{userId}';
};

export declare type GetParticipantError = GetParticipantErrors[keyof GetParticipantErrors];

export declare type GetParticipantErrors = {
    /**
     * Returns the [Participant](#schema_user) object
     */
    default: {
        participant: User;
    };
};

export declare type GetParticipantResponse = GetParticipantResponses[keyof GetParticipantResponses];

export declare type GetParticipantResponses = {
    /**
     * Returns the [Participant](#schema_user) object
     */
    200: {
        participant: User;
    };
};

/**
 * Retrieves the [User](#schema_user) object for a valid identifier.
 */
declare const getUser: <ThrowOnError extends boolean = false>(options: Options<GetUserData, ThrowOnError>) => RequestResult<{
    user: User;
}, {
    user: User;
}, ThrowOnError>;

export declare type GetUserData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: never;
    url: '/users/me';
};

export declare type GetUserError = GetUserErrors[keyof GetUserErrors];

export declare type GetUserErrors = {
    /**
     * Returns a [User](#schema_user) object if a valid identifier was provided
     */
    default: {
        user: User;
    };
};

export declare type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export declare type GetUserResponses = {
    /**
     * Returns a [User](#schema_user) object if a valid identifier was provided
     */
    200: {
        user: User;
    };
};

declare class Interceptors<Interceptor> {
    _fns: Interceptor[];
    constructor();
    clear(): void;
    exists(fn: Interceptor): boolean;
    eject(fn: Interceptor): void;
    use(fn: Interceptor): void;
}

/**
 * Retrieves the conversation's [Messages](#schema_message)
 */
declare const listConversationMessages: <ThrowOnError extends boolean = false>(options: Options<ListConversationMessagesData, ThrowOnError>) => RequestResult<{
    messages: Array<Message>;
    meta: {
        nextToken?: string;
    };
}, {
    messages: Array<Message>;
    meta: {
        nextToken?: string;
    };
}, ThrowOnError>;

export declare type ListConversationMessagesData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
    };
    query?: {
        /**
         * Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results
         */
        nextToken?: string;
    };
    url: '/conversations/{id}/messages';
};

export declare type ListConversationMessagesError = ListConversationMessagesErrors[keyof ListConversationMessagesErrors];

export declare type ListConversationMessagesErrors = {
    /**
     * Returns a list of [Message](#schema_message) objects
     */
    default: {
        messages: Array<Message>;
        meta: {
            /**
             * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
             */
            nextToken?: string;
        };
    };
};

export declare type ListConversationMessagesResponse = ListConversationMessagesResponses[keyof ListConversationMessagesResponses];

export declare type ListConversationMessagesResponses = {
    /**
     * Returns a list of [Message](#schema_message) objects
     */
    200: {
        messages: Array<Message>;
        meta: {
            /**
             * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
             */
            nextToken?: string;
        };
    };
};

/**
 * Returns a list of [Conversation](#schema_conversation) objects
 */
declare const listConversations: <ThrowOnError extends boolean = false>(options: Options<ListConversationsData, ThrowOnError>) => RequestResult<{
    conversations: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
    }>;
    meta: {
        nextToken?: string;
    };
}, {
    conversations: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
    }>;
    meta: {
        nextToken?: string;
    };
}, ThrowOnError>;

export declare type ListConversationsData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: {
        /**
         * Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results
         */
        nextToken?: string;
    };
    url: '/conversations';
};

export declare type ListConversationsError = ListConversationsErrors[keyof ListConversationsErrors];

export declare type ListConversationsErrors = {
    /**
     * Returns a list of [Conversation](#schema_conversation) objects
     */
    default: {
        conversations: Array<{
            /**
             * Id of the [Conversation](#schema_conversation)
             */
            id: string;
            /**
             * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
             */
            createdAt: string;
            /**
             * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
             */
            updatedAt: string;
        }>;
        meta: {
            /**
             * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
             */
            nextToken?: string;
        };
    };
};

export declare type ListConversationsResponse = ListConversationsResponses[keyof ListConversationsResponses];

export declare type ListConversationsResponses = {
    /**
     * Returns a list of [Conversation](#schema_conversation) objects
     */
    200: {
        conversations: Array<{
            /**
             * Id of the [Conversation](#schema_conversation)
             */
            id: string;
            /**
             * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
             */
            createdAt: string;
            /**
             * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
             */
            updatedAt: string;
        }>;
        meta: {
            /**
             * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
             */
            nextToken?: string;
        };
    };
};

/**
 * Creates a SSE stream to receive messages and events from a conversation
 */
declare const listenConversation: <ThrowOnError extends boolean = false>(options: Options<ListenConversationData, ThrowOnError>) => RequestResult<{
    [key: string]: never;
}, {
    [key: string]: never;
}, ThrowOnError>;

export declare type ListenConversationData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
    };
    query?: never;
    url: '/conversations/{id}/listen';
};

export declare type ListenConversationError = ListenConversationErrors[keyof ListenConversationErrors];

export declare type ListenConversationErrors = {
    /**
     * Returns nothing but a stream
     */
    default: {
        [key: string]: never;
    };
};

export declare type ListenConversationResponse = ListenConversationResponses[keyof ListenConversationResponses];

export declare type ListenConversationResponses = {
    /**
     * Returns nothing but a stream
     */
    200: {
        [key: string]: never;
    };
};

/**
 * Retrieves a list of [Participants](#schema_user) for a given [Conversation](#schema_conversation).
 */
declare const listParticipants: <ThrowOnError extends boolean = false>(options: Options<ListParticipantsData, ThrowOnError>) => RequestResult<{
    participants: Array<User>;
    meta: {
        nextToken?: string;
    };
}, {
    participants: Array<User>;
    meta: {
        nextToken?: string;
    };
}, ThrowOnError>;

export declare type ListParticipantsData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
    };
    query?: {
        /**
         * Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results
         */
        nextToken?: string;
    };
    url: '/conversations/{id}/participants';
};

export declare type ListParticipantsError = ListParticipantsErrors[keyof ListParticipantsErrors];

export declare type ListParticipantsErrors = {
    /**
     * Returns a list of [Participants](#schema_user) objects
     */
    default: {
        participants: Array<User>;
        meta: {
            /**
             * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
             */
            nextToken?: string;
        };
    };
};

export declare type ListParticipantsResponse = ListParticipantsResponses[keyof ListParticipantsResponses];

export declare type ListParticipantsResponses = {
    /**
     * Returns a list of [Participants](#schema_user) objects
     */
    200: {
        participants: Array<User>;
        meta: {
            /**
             * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
             */
            nextToken?: string;
        };
    };
};

/**
 * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
 */
export declare type Message = {
    /**
     * Id of the [Message](#schema_message)
     */
    id: string;
    /**
     * Creation date of the [Message](#schema_message) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Payload is the content of the message.
     */
    payload: {
        audioUrl: string;
        type: 'audio';
    } | {
        title: string;
        subtitle?: string;
        imageUrl?: string;
        actions: Array<{
            action: 'postback' | 'url' | 'say';
            label: string;
            value: string;
        }>;
        type: 'card';
    } | {
        items: Array<{
            title: string;
            subtitle?: string;
            imageUrl?: string;
            actions: Array<{
                action: 'postback' | 'url' | 'say';
                label: string;
                value: string;
            }>;
        }>;
        type: 'carousel';
    } | {
        text: string;
        options: Array<{
            label: string;
            value: string;
        }>;
        disableFreeText?: boolean;
        type: 'choice';
    } | {
        text: string;
        options: Array<{
            label: string;
            value: string;
        }>;
        disableFreeText?: boolean;
        type: 'dropdown';
    } | {
        fileUrl: string;
        title?: string;
        type: 'file';
    } | {
        imageUrl: string;
        type: 'image';
    } | {
        latitude: number;
        longitude: number;
        address?: string;
        title?: string;
        type: 'location';
    } | {
        text: string;
        value?: string;
        type: 'text';
    } | {
        videoUrl: string;
        type: 'video';
    } | {
        items: Array<{
            type: 'text';
            payload: {
                text: string;
                value?: string;
            };
        } | {
            type: 'markdown';
            payload: {
                markdown: string;
            };
        } | {
            type: 'image';
            payload: {
                imageUrl: string;
            };
        } | {
            type: 'audio';
            payload: {
                audioUrl: string;
            };
        } | {
            type: 'video';
            payload: {
                videoUrl: string;
            };
        } | {
            type: 'file';
            payload: {
                fileUrl: string;
                title?: string;
            };
        } | {
            type: 'location';
            payload: {
                latitude: number;
                longitude: number;
                address?: string;
                title?: string;
            };
        }>;
        type: 'bloc';
    } | {
        markdown: string;
        type: 'markdown';
    } | {
        url: string;
        name: string;
        data?: unknown;
        type: 'custom';
    } | {
        reaction: string;
        type: 'reaction';
    };
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Metadata of the message
     */
    metadata?: {};
    /**
     * ID of the message this message is replying to
     */
    replyTo?: string;
    /**
     * ID of the user who selected this message. Undefined if not selected.
     */
    selectedBy?: string;
};

declare type MessageCreated = {
    type: 'message_created';
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    data: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Payload is the content of the message.
         */
        payload: {
            audioUrl: string;
            type: 'audio';
            [k: string]: any;
        } | {
            title: string;
            subtitle?: string;
            imageUrl?: string;
            actions: {
                action: 'postback' | 'url' | 'say';
                label: string;
                value: string;
                [k: string]: any;
            }[];
            type: 'card';
            [k: string]: any;
        } | {
            items: {
                title: string;
                subtitle?: string;
                imageUrl?: string;
                actions: {
                    action: 'postback' | 'url' | 'say';
                    label: string;
                    value: string;
                    [k: string]: any;
                }[];
                [k: string]: any;
            }[];
            type: 'carousel';
            [k: string]: any;
        } | {
            text: string;
            options: {
                label: string;
                value: string;
                [k: string]: any;
            }[];
            type: 'choice';
            disableFreeText?: boolean;
            [k: string]: any;
        } | {
            text: string;
            options: {
                label: string;
                value: string;
                [k: string]: any;
            }[];
            type: 'dropdown';
            [k: string]: any;
        } | {
            fileUrl: string;
            title?: string;
            type: 'file';
            [k: string]: any;
        } | {
            imageUrl: string;
            type: 'image';
            [k: string]: any;
        } | {
            latitude: number;
            longitude: number;
            address?: string;
            title?: string;
            type: 'location';
            [k: string]: any;
        } | {
            text: string;
            type: 'text';
            value?: string;
            [k: string]: any;
        } | {
            videoUrl: string;
            type: 'video';
            [k: string]: any;
        } | {
            items: ({
                type: 'text';
                payload: {
                    text: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'markdown';
                payload: {
                    markdown: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'image';
                payload: {
                    imageUrl: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'audio';
                payload: {
                    audioUrl: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'video';
                payload: {
                    videoUrl: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'file';
                payload: {
                    fileUrl: string;
                    title?: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'location';
                payload: {
                    latitude: number;
                    longitude: number;
                    address?: string;
                    title?: string;
                    [k: string]: any;
                };
                [k: string]: any;
            })[];
            type: 'bloc';
            [k: string]: any;
        } | {
            markdown: string;
            type: 'markdown';
            [k: string]: any;
        } | {
            type: 'custom';
            url: string;
            name: string;
            data?: any;
            [k: string]: any;
        };
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Metadata of the message
         */
        metadata?: {
            [k: string]: any;
        };
        /**
         * ID of the message this message is replying to
         */
        replyTo?: string;
    };
};

declare type MessageIdParam = {
    messageId: string;
};

declare type MessageUpdated = {
    type: 'message_updated';
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    data: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Payload is the content of the message.
         */
        payload: {
            audioUrl: string;
            type: 'audio';
            [k: string]: any;
        } | {
            title: string;
            subtitle?: string;
            imageUrl?: string;
            actions: {
                action: 'postback' | 'url' | 'say';
                label: string;
                value: string;
                [k: string]: any;
            }[];
            type: 'card';
            [k: string]: any;
        } | {
            items: {
                title: string;
                subtitle?: string;
                imageUrl?: string;
                actions: {
                    action: 'postback' | 'url' | 'say';
                    label: string;
                    value: string;
                    [k: string]: any;
                }[];
                [k: string]: any;
            }[];
            type: 'carousel';
            [k: string]: any;
        } | {
            text: string;
            options: {
                label: string;
                value: string;
                [k: string]: any;
            }[];
            type: 'choice';
            disableFreeText?: boolean;
            [k: string]: any;
        } | {
            text: string;
            options: {
                label: string;
                value: string;
                [k: string]: any;
            }[];
            type: 'dropdown';
            [k: string]: any;
        } | {
            fileUrl: string;
            title?: string;
            type: 'file';
            [k: string]: any;
        } | {
            imageUrl: string;
            type: 'image';
            [k: string]: any;
        } | {
            latitude: number;
            longitude: number;
            address?: string;
            title?: string;
            type: 'location';
            [k: string]: any;
        } | {
            text: string;
            type: 'text';
            value?: string;
            [k: string]: any;
        } | {
            videoUrl: string;
            type: 'video';
            [k: string]: any;
        } | {
            items: ({
                type: 'text';
                payload: {
                    text: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'markdown';
                payload: {
                    markdown: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'image';
                payload: {
                    imageUrl: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'audio';
                payload: {
                    audioUrl: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'video';
                payload: {
                    videoUrl: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'file';
                payload: {
                    fileUrl: string;
                    title?: string;
                    [k: string]: any;
                };
                [k: string]: any;
            } | {
                type: 'location';
                payload: {
                    latitude: number;
                    longitude: number;
                    address?: string;
                    title?: string;
                    [k: string]: any;
                };
                [k: string]: any;
            })[];
            type: 'bloc';
            [k: string]: any;
        } | {
            markdown: string;
            type: 'markdown';
            [k: string]: any;
        } | {
            type: 'custom';
            url: string;
            name: string;
            data?: any;
            [k: string]: any;
        };
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Metadata of the message
         */
        metadata?: {
            [k: string]: any;
        };
        /**
         * ID of the message this message is replying to
         */
        replyTo?: string;
    };
};

declare type MethodFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions<ThrowOnError>, 'method'>) => RequestResult<TData, TError, ThrowOnError>;

declare interface Middleware<Req, Res, Err, Options> {
    error: Pick<Interceptors<ErrInterceptor<Err, Res, Req, Options>>, 'eject' | 'use'>;
    request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;
    response: Pick<Interceptors<ResInterceptor<Res, Req, Options>>, 'eject' | 'use'>;
}

declare type NextTokenParam = {
    nextToken?: string;
};

declare type ObjectStyle = 'form' | 'deepObject';

declare type OmitKeys<T, K> = Pick<T, Exclude<keyof T, K>>;

declare type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options_2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client_2;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

declare type Options_2<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = OmitKeys<RequestOptions<ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & Omit<TData, 'url'>;

declare type QuerySerializer = (query: Record<string, unknown>) => string;

declare interface QuerySerializerOptions {
    allowReserved?: boolean;
    array?: SerializerOptions<ArrayStyle>;
    object?: SerializerOptions<ObjectStyle>;
}

/**
 * Remove a [Participant](#schema_user) from a [Conversation](#schema_conversation).
 */
declare const removeParticipant: <ThrowOnError extends boolean = false>(options: Options<RemoveParticipantData, ThrowOnError>) => RequestResult<{
    [key: string]: never;
}, {
    [key: string]: never;
}, ThrowOnError>;

export declare type RemoveParticipantData = {
    body?: never;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Conversation id
         */
        id: string;
        /**
         * User id
         */
        userId: string;
    };
    query?: never;
    url: '/conversations/{id}/participants/{userId}';
};

export declare type RemoveParticipantError = RemoveParticipantErrors[keyof RemoveParticipantErrors];

export declare type RemoveParticipantErrors = {
    /**
     * Returns an empty object
     */
    default: {
        [key: string]: never;
    };
};

export declare type RemoveParticipantResponse = RemoveParticipantResponses[keyof RemoveParticipantResponses];

export declare type RemoveParticipantResponses = {
    /**
     * Returns an empty object
     */
    200: {
        [key: string]: never;
    };
};

declare type ReqInterceptor<Req, Options> = (request: Req, options: Options) => Req | Promise<Req>;

declare type RequestFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions<ThrowOnError>, 'method'> & Pick<Required<RequestOptions<ThrowOnError>>, 'method'>) => RequestResult<TData, TError, ThrowOnError>;

declare interface RequestOptions<ThrowOnError extends boolean = boolean, Url extends string = string> extends Config<{
    throwOnError: ThrowOnError;
}> {
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}

declare type RequestResult<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean> = ThrowOnError extends true ? Promise<{
    data: TData;
    request: Request;
    response: Response;
}> : Promise<({
    data: TData;
    error: undefined;
} | {
    data: undefined;
    error: TError;
}) & {
    request: Request;
    response: Response;
}>;

declare type ResInterceptor<Res, Req, Options> = (response: Res, request: Req, options: Options) => Res | Promise<Res>;

/**
 * Updates a [Message](#schema_message) sent by any user to mark it as already selected. A message can only be selected once.
 */
declare const selectMessage: <ThrowOnError extends boolean = false>(options: Options<SelectMessageData, ThrowOnError>) => RequestResult<{
    [key: string]: never;
}, {
    [key: string]: never;
}, ThrowOnError>;

/**
 * Empty object
 */
export declare type SelectMessageBody = {
    [key: string]: never;
};

export declare type SelectMessageData = {
    /**
     * Empty object
     */
    body?: SelectMessageBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Message id
         */
        id: string;
    };
    query?: never;
    url: '/messages/{id}/select';
};

export declare type SelectMessageError = SelectMessageErrors[keyof SelectMessageErrors];

export declare type SelectMessageErrors = {
    /**
     * Empty object
     */
    default: {
        [key: string]: never;
    };
};

export declare type SelectMessageResponse = SelectMessageResponses[keyof SelectMessageResponses];

export declare type SelectMessageResponses = {
    /**
     * Empty object
     */
    200: {
        [key: string]: never;
    };
};

declare interface SerializerOptions<T> {
    /**
     * @default true
     */
    explode: boolean;
    style: T;
}

declare type Signal = MessageCreated | MessageUpdated | WebchatVisibility | WebchatConfig | Custom | TypingStarted | TypingStopped;

declare interface TDataShape {
    body?: unknown;
    headers?: unknown;
    path?: unknown;
    query?: unknown;
    url: string;
}

declare type TypingStarted = {
    type: 'typing_started';
    data: {
        timeout?: number;
    };
};

declare type TypingStopped = {
    type: 'typing_stopped';
    data: {};
};

/**
 * Updates a [Message](#schema_message). The bot won't be aware of the changes.
 */
declare const updateMessage: <ThrowOnError extends boolean = false>(options: Options<UpdateMessageData, ThrowOnError>) => RequestResult<{
    message: Message;
}, {
    message: Message;
}, ThrowOnError>;

/**
 * Message data
 */
export declare type UpdateMessageBody = {
    /**
     * Payload is the content of the message.
     */
    payload?: {
        audioUrl: string;
        type: 'audio';
    } | {
        title: string;
        subtitle?: string;
        imageUrl?: string;
        actions: Array<{
            action: 'postback' | 'url' | 'say';
            label: string;
            value: string;
        }>;
        type: 'card';
    } | {
        items: Array<{
            title: string;
            subtitle?: string;
            imageUrl?: string;
            actions: Array<{
                action: 'postback' | 'url' | 'say';
                label: string;
                value: string;
            }>;
        }>;
        type: 'carousel';
    } | {
        text: string;
        options: Array<{
            label: string;
            value: string;
        }>;
        disableFreeText?: boolean;
        type: 'choice';
    } | {
        text: string;
        options: Array<{
            label: string;
            value: string;
        }>;
        disableFreeText?: boolean;
        type: 'dropdown';
    } | {
        fileUrl: string;
        title?: string;
        type: 'file';
    } | {
        imageUrl: string;
        type: 'image';
    } | {
        latitude: number;
        longitude: number;
        address?: string;
        title?: string;
        type: 'location';
    } | {
        text: string;
        value?: string;
        type: 'text';
    } | {
        videoUrl: string;
        type: 'video';
    } | {
        items: Array<{
            type: 'text';
            payload: {
                text: string;
                value?: string;
            };
        } | {
            type: 'markdown';
            payload: {
                markdown: string;
            };
        } | {
            type: 'image';
            payload: {
                imageUrl: string;
            };
        } | {
            type: 'audio';
            payload: {
                audioUrl: string;
            };
        } | {
            type: 'video';
            payload: {
                videoUrl: string;
            };
        } | {
            type: 'file';
            payload: {
                fileUrl: string;
                title?: string;
            };
        } | {
            type: 'location';
            payload: {
                latitude: number;
                longitude: number;
                address?: string;
                title?: string;
            };
        }>;
        type: 'bloc';
    } | {
        markdown: string;
        type: 'markdown';
    } | {
        url: string;
        name: string;
        data?: unknown;
        type: 'custom';
    } | {
        reaction: string;
        type: 'reaction';
    };
    /**
     * Metadata of the message
     */
    metadata?: {};
};

export declare type UpdateMessageData = {
    /**
     * Message data
     */
    body?: UpdateMessageBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path: {
        /**
         * Message id
         */
        id: string;
    };
    query?: never;
    url: '/messages/{id}';
};

export declare type UpdateMessageError = UpdateMessageErrors[keyof UpdateMessageErrors];

export declare type UpdateMessageErrors = {
    /**
     * Returns a [Message](#schema_message).
     */
    default: {
        message: Message;
    };
};

export declare type UpdateMessageResponse = UpdateMessageResponses[keyof UpdateMessageResponses];

export declare type UpdateMessageResponses = {
    /**
     * Returns a [Message](#schema_message).
     */
    200: {
        message: Message;
    };
};

/**
 * Update [User](#schema_user)
 */
declare const updateUser: <ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>) => RequestResult<{
    user: User;
}, {
    user: User;
}, ThrowOnError>;

/**
 * User data
 */
export declare type UpdateUserBody = {
    /**
     * Name of the [User](#schema_user) (not a unique identifier)
     */
    name?: string;
    /**
     * Picture url of the [User](#schema_user)
     */
    pictureUrl?: string;
    /**
     * User data
     */
    userData?: {} | null;
};

export declare type UpdateUserData = {
    /**
     * User data
     */
    body?: UpdateUserBody;
    headers: {
        /**
         * Authentication Key
         */
        'x-user-key': string;
    };
    path?: never;
    query?: never;
    url: '/users/me';
};

export declare type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export declare type UpdateUserErrors = {
    /**
     * Returns a [User](#schema_user)
     */
    default: {
        user: User;
    };
};

export declare type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export declare type UpdateUserResponses = {
    /**
     * Returns a [User](#schema_user)
     */
    200: {
        user: User;
    };
};

/**
 * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
 */
export declare type User = {
    /**
     * Name of the [User](#schema_user)
     */
    name?: string;
    /**
     * Picture url of the [User](#schema_user)
     */
    pictureUrl?: string;
    /**
     * User data
     */
    data?: {};
    /**
     * Id of the [User](#schema_user)
     */
    id: string;
    /**
     * Creation date of the [User](#schema_user) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [User](#schema_user) in ISO 8601 format
     */
    updatedAt: string;
};

declare type UserIdParam = {
    userId: string;
};

declare type WebchatConfig = {
    type: 'webchat_config';
    data: {
        config: {
            [k: string]: any;
        };
    };
};

declare type WebchatVisibility = {
    type: 'webchat_visibility';
    data: {
        visibility: 'show' | 'hide' | 'toggle';
    };
};

export { }
