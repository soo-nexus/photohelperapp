import { createUser as u, getEvent as f, createEvent as U, deleteUser as M, updateUser as y, getUser as R, createFile as b, deleteMessage as P, getMessage as T, updateMessage as $, createMessage as S, listParticipants as _, getParticipant as A, removeParticipant as I, addParticipant as q, listConversationMessages as w, listConversations as x, deleteConversation as N, getConversation as F, createConversation as J } from "./webchat-client3.js";
import { client as m } from "./webchat-client4.js";
import { EventSource as L } from "./webchat-client5.js";
import { EventEmitter as O } from "./webchat-client6.js";
const n = (a) => a.data, E = {
  throwOnError: !0
}, z = ({ clientId: a, apiUrl: d }) => {
  const p = `${d || m.getConfig().baseUrl}/${a}`, t = {
    ...E,
    baseUrl: p
  };
  return u({ ...t, body: {} }).then(n);
}, B = ({
  userKey: a,
  clientId: d,
  apiUrl: p
}) => {
  const t = {
    "x-user-key": a
  }, g = `${p || m.getConfig().baseUrl}/${d}`, r = {
    ...E,
    baseUrl: g
  };
  return {
    createConversation: () => J({ ...r, headers: t, body: {} }).then(n),
    getConversation: ({ conversationId: e }) => F({ ...r, headers: t, path: { id: e } }).then(n),
    deleteConversation: ({ conversationId: e }) => N({ ...r, headers: t, path: { id: e } }).then(n),
    listConversations: ({ nextToken: e }) => x({ ...r, headers: t, query: { nextToken: e } }).then(n),
    listConversationMessages: ({ conversationId: e, nextToken: s }) => w({
      ...r,
      headers: t,
      path: { id: e },
      query: { nextToken: s }
    }).then(n),
    addParticipant: ({ conversationId: e, userId: s }) => q({ ...r, headers: t, path: { id: e }, body: { userId: s } }).then(n),
    removeParticipant: ({ conversationId: e, userId: s }) => I({ ...r, headers: t, path: { id: e, userId: s } }).then(n),
    getParticipant: ({ conversationId: e, userId: s }) => A({ ...r, headers: t, path: { id: e, userId: s } }).then(n),
    listParticipants: ({ conversationId: e, nextToken: s }) => _({ ...r, headers: t, path: { id: e }, query: { nextToken: s } }).then(n),
    createMessage: (e) => S({ ...r, headers: t, body: e }).then(n),
    updateMessage: ({ messageId: e, ...s }) => $({ ...r, headers: t, path: { id: e }, body: s }).then(n),
    getMessage: ({ messageId: e }) => T({ ...r, headers: t, path: { id: e } }).then(n),
    deleteMessage: ({ messageId: e }) => P({ ...r, headers: t, path: { id: e } }).then(n),
    createFile: (e) => b({ ...r, headers: t, body: e }).then(n),
    createUser: (e) => u({ ...r, headers: t, body: e }).then(n),
    getUser: () => R({ ...r, headers: t }).then(n),
    updateUser: (e) => y({ ...r, headers: t, body: e }).then(n),
    deleteUser: () => M({ ...r, headers: t }).then(n),
    createEvent: (e) => U({ ...r, headers: t, body: e }).then(n),
    getEvent: ({ eventId: e }) => f({ ...r, headers: t, path: { id: e } }).then(n),
    listenConversation: ({ conversationId: e }) => {
      let l = 0, i = null;
      const c = new O(), v = () => {
        i && i.close();
        const C = `${g}/conversations/${e}/listen`;
        i = new L(C, {
          fetch: (h, o) => fetch(h, {
            ...o,
            headers: {
              ...o == null ? void 0 : o.headers,
              ...t,
              timeout: "60_000"
            }
          })
        }), i.onopen = () => c.emit("open"), i.onerror = (h) => {
          c.emit("error", h), l < 10 && (l++, setTimeout(() => v(), 3e3));
        }, i.onmessage = (h) => {
          const o = V(h.data);
          c.emit(o.type, o.data);
        };
      };
      return v(), c.on.bind(c);
    }
  };
}, V = (a) => {
  try {
    return JSON.parse(a);
  } catch {
    return a;
  }
};
export {
  B as createClient,
  z as createUser
};
