import zlib from 'node:zlib'
import fs from 'node:fs'

const ESM_BUNDLE_SIZE_LIMIT = 250000
const CJS_BUNDLE_SIZE_LIMIT = 200000

class BundleSizeExceededError extends Error {
  constructor(filePath, maxSize, actualSize) {
    super(
      `BUNDLE SIZE EXCEEDED: ${filePath} exceeded max size of ${maxSize / 1000}kB. Actual size is ${actualSize / 1000}kB (gzipped).`
    )
  }
}

class BundleSizeInfo {
  constructor(filePath, actualSize) {
    this.message = `BUNDLE SIZE OK: ${filePath} actual size is ${actualSize / 1000}kB (gzipped).`
  }
}

async function reportResults(results) {
  let failed = false

  for (const result of results) {
    if (result.status === 'rejected') {
      failed = true
      if (result.reason instanceof BundleSizeExceededError) {
        console.error(result.reason.message)
      } else {
        console.error('An unknown error occured when computing the bundle size')
        console.error(result.reason)
      }
    } else {
      console.log(result.value.message)
    }
  }

  if (failed) {
    process.exit(-1)
  }
}

async function assertGzipSizeBelowThreshold(filePath, maxBytes) {
  const size = await getGzipSize(filePath)

  if (size > maxBytes) {
    throw new BundleSizeExceededError(filePath, maxBytes, size)
  } else {
    return new BundleSizeInfo(filePath, size)
  }
}

async function getGzipSize(filePath) {
  const gzipStream = fs.createReadStream(filePath).pipe(zlib.createGzip())

  let size = 0

  for await (const chunk of gzipStream) {
    size += chunk.byteLength
  }

  return size
}

await Promise.allSettled([
  assertGzipSizeBelowThreshold('dist/index.js', ESM_BUNDLE_SIZE_LIMIT),
  assertGzipSizeBelowThreshold('dist/index.umd.cjs', CJS_BUNDLE_SIZE_LIMIT),
]).then(reportResults)
