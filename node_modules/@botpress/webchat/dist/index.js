import './style.css';
var oE = Object.defineProperty;
var aE = (e, t, n) => t in e ? oE(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var yp = (e, t, n) => aE(e, typeof t != "symbol" ? t + "" : t, n);
import * as k from "react";
import Le, { forwardRef as Ot, createElement as Xu, useState as ge, useRef as Ke, createRef as sE, useEffect as vt, createContext as Dy, useContext as ci, useCallback as Oe, useId as lE, useLayoutEffect as fi, useMemo as st, memo as ds, useImperativeHandle as uE, Fragment as cE, useReducer as fE } from "react";
import * as _y from "react-dom";
import { createPortal as dE } from "react-dom";
var an = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ju = { exports: {} }, $i = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bp;
function pE() {
  if (bp) return $i;
  bp = 1;
  var e = Le, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, f = {}, p = null, d = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (d = l.ref);
    for (c in l) r.call(l, c) && !o.hasOwnProperty(c) && (f[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) f[c] === void 0 && (f[c] = l[c]);
    return { $$typeof: t, type: s, key: p, ref: d, props: f, _owner: i.current };
  }
  return $i.Fragment = n, $i.jsx = a, $i.jsxs = a, $i;
}
var Ti = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xp;
function hE() {
  return xp || (xp = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Le, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), v = Symbol.iterator, h = "@@iterator";
    function g(R) {
      if (R === null || typeof R != "object")
        return null;
      var ee = v && R[v] || R[h];
      return typeof ee == "function" ? ee : null;
    }
    var m = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(R) {
      {
        for (var ee = arguments.length, le = new Array(ee > 1 ? ee - 1 : 0), he = 1; he < ee; he++)
          le[he - 1] = arguments[he];
        w("error", R, le);
      }
    }
    function w(R, ee, le) {
      {
        var he = m.ReactDebugCurrentFrame, De = he.getStackAddendum();
        De !== "" && (ee += "%s", le = le.concat([De]));
        var ze = le.map(function(Ee) {
          return String(Ee);
        });
        ze.unshift("Warning: " + ee), Function.prototype.apply.call(console[R], console, ze);
      }
    }
    var C = !1, S = !1, E = !1, I = !1, N = !1, A;
    A = Symbol.for("react.module.reference");
    function O(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === r || R === o || N || R === i || R === u || R === c || I || R === d || C || S || E || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === f || R.$$typeof === a || R.$$typeof === s || R.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === A || R.getModuleId !== void 0));
    }
    function D(R, ee, le) {
      var he = R.displayName;
      if (he)
        return he;
      var De = ee.displayName || ee.name || "";
      return De !== "" ? le + "(" + De + ")" : le;
    }
    function U(R) {
      return R.displayName || "Context";
    }
    function L(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case s:
            var ee = R;
            return U(ee) + ".Consumer";
          case a:
            var le = R;
            return U(le._context) + ".Provider";
          case l:
            return D(R, R.render, "ForwardRef");
          case f:
            var he = R.displayName || null;
            return he !== null ? he : L(R.type) || "Memo";
          case p: {
            var De = R, ze = De._payload, Ee = De._init;
            try {
              return L(Ee(ze));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var M = Object.assign, _ = 0, z, q, H, P, y, T, j;
    function x() {
    }
    x.__reactDisabledLog = !0;
    function F() {
      {
        if (_ === 0) {
          z = console.log, q = console.info, H = console.warn, P = console.error, y = console.group, T = console.groupCollapsed, j = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: x,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        _++;
      }
    }
    function G() {
      {
        if (_--, _ === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: M({}, R, {
              value: z
            }),
            info: M({}, R, {
              value: q
            }),
            warn: M({}, R, {
              value: H
            }),
            error: M({}, R, {
              value: P
            }),
            group: M({}, R, {
              value: y
            }),
            groupCollapsed: M({}, R, {
              value: T
            }),
            groupEnd: M({}, R, {
              value: j
            })
          });
        }
        _ < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var K = m.ReactCurrentDispatcher, Y;
    function Q(R, ee, le) {
      {
        if (Y === void 0)
          try {
            throw Error();
          } catch (De) {
            var he = De.stack.trim().match(/\n( *(at )?)/);
            Y = he && he[1] || "";
          }
        return `
` + Y + R;
      }
    }
    var Z = !1, X;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      X = new J();
    }
    function V(R, ee) {
      if (!R || Z)
        return "";
      {
        var le = X.get(R);
        if (le !== void 0)
          return le;
      }
      var he;
      Z = !0;
      var De = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ze;
      ze = K.current, K.current = null, F();
      try {
        if (ee) {
          var Ee = function() {
            throw Error();
          };
          if (Object.defineProperty(Ee.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ee, []);
            } catch (_t) {
              he = _t;
            }
            Reflect.construct(R, [], Ee);
          } else {
            try {
              Ee.call();
            } catch (_t) {
              he = _t;
            }
            R.call(Ee.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_t) {
            he = _t;
          }
          R();
        }
      } catch (_t) {
        if (_t && he && typeof _t.stack == "string") {
          for (var xe = _t.stack.split(`
`), Pt = he.stack.split(`
`), tt = xe.length - 1, ot = Pt.length - 1; tt >= 1 && ot >= 0 && xe[tt] !== Pt[ot]; )
            ot--;
          for (; tt >= 1 && ot >= 0; tt--, ot--)
            if (xe[tt] !== Pt[ot]) {
              if (tt !== 1 || ot !== 1)
                do
                  if (tt--, ot--, ot < 0 || xe[tt] !== Pt[ot]) {
                    var Gt = `
` + xe[tt].replace(" at new ", " at ");
                    return R.displayName && Gt.includes("<anonymous>") && (Gt = Gt.replace("<anonymous>", R.displayName)), typeof R == "function" && X.set(R, Gt), Gt;
                  }
                while (tt >= 1 && ot >= 0);
              break;
            }
        }
      } finally {
        Z = !1, K.current = ze, G(), Error.prepareStackTrace = De;
      }
      var Tr = R ? R.displayName || R.name : "", lr = Tr ? Q(Tr) : "";
      return typeof R == "function" && X.set(R, lr), lr;
    }
    function ne(R, ee, le) {
      return V(R, !1);
    }
    function se(R) {
      var ee = R.prototype;
      return !!(ee && ee.isReactComponent);
    }
    function fe(R, ee, le) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return V(R, se(R));
      if (typeof R == "string")
        return Q(R);
      switch (R) {
        case u:
          return Q("Suspense");
        case c:
          return Q("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            return ne(R.render);
          case f:
            return fe(R.type, ee, le);
          case p: {
            var he = R, De = he._payload, ze = he._init;
            try {
              return fe(ze(De), ee, le);
            } catch {
            }
          }
        }
      return "";
    }
    var oe = Object.prototype.hasOwnProperty, pe = {}, Se = m.ReactDebugCurrentFrame;
    function Ie(R) {
      if (R) {
        var ee = R._owner, le = fe(R.type, R._source, ee ? ee.type : null);
        Se.setExtraStackFrame(le);
      } else
        Se.setExtraStackFrame(null);
    }
    function nt(R, ee, le, he, De) {
      {
        var ze = Function.call.bind(oe);
        for (var Ee in R)
          if (ze(R, Ee)) {
            var xe = void 0;
            try {
              if (typeof R[Ee] != "function") {
                var Pt = Error((he || "React class") + ": " + le + " type `" + Ee + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[Ee] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Pt.name = "Invariant Violation", Pt;
              }
              xe = R[Ee](ee, Ee, he, le, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tt) {
              xe = tt;
            }
            xe && !(xe instanceof Error) && (Ie(De), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", he || "React class", le, Ee, typeof xe), Ie(null)), xe instanceof Error && !(xe.message in pe) && (pe[xe.message] = !0, Ie(De), b("Failed %s type: %s", le, xe.message), Ie(null));
          }
      }
    }
    var St = Array.isArray;
    function Et(R) {
      return St(R);
    }
    function kt(R) {
      {
        var ee = typeof Symbol == "function" && Symbol.toStringTag, le = ee && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return le;
      }
    }
    function ie(R) {
      try {
        return ue(R), !1;
      } catch {
        return !0;
      }
    }
    function ue(R) {
      return "" + R;
    }
    function W(R) {
      if (ie(R))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", kt(R)), ue(R);
    }
    var B = m.ReactCurrentOwner, te = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ae, ce, ve;
    ve = {};
    function qe(R) {
      if (oe.call(R, "ref")) {
        var ee = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function Ge(R) {
      if (oe.call(R, "key")) {
        var ee = Object.getOwnPropertyDescriptor(R, "key").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function gt(R, ee) {
      if (typeof R.ref == "string" && B.current && ee && B.current.stateNode !== ee) {
        var le = L(B.current.type);
        ve[le] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', L(B.current.type), R.ref), ve[le] = !0);
      }
    }
    function rt(R, ee) {
      {
        var le = function() {
          ae || (ae = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        le.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: le,
          configurable: !0
        });
      }
    }
    function Re(R, ee) {
      {
        var le = function() {
          ce || (ce = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        le.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: le,
          configurable: !0
        });
      }
    }
    var it = function(R, ee, le, he, De, ze, Ee) {
      var xe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: R,
        key: ee,
        ref: le,
        props: Ee,
        // Record the component responsible for creating this element.
        _owner: ze
      };
      return xe._store = {}, Object.defineProperty(xe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(xe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: he
      }), Object.defineProperty(xe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: De
      }), Object.freeze && (Object.freeze(xe.props), Object.freeze(xe)), xe;
    };
    function Ze(R, ee, le, he, De) {
      {
        var ze, Ee = {}, xe = null, Pt = null;
        le !== void 0 && (W(le), xe = "" + le), Ge(ee) && (W(ee.key), xe = "" + ee.key), qe(ee) && (Pt = ee.ref, gt(ee, De));
        for (ze in ee)
          oe.call(ee, ze) && !te.hasOwnProperty(ze) && (Ee[ze] = ee[ze]);
        if (R && R.defaultProps) {
          var tt = R.defaultProps;
          for (ze in tt)
            Ee[ze] === void 0 && (Ee[ze] = tt[ze]);
        }
        if (xe || Pt) {
          var ot = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          xe && rt(Ee, ot), Pt && Re(Ee, ot);
        }
        return it(R, xe, Pt, De, he, B.current, Ee);
      }
    }
    var qt = m.ReactCurrentOwner, Ei = m.ReactDebugCurrentFrame;
    function Rn(R) {
      if (R) {
        var ee = R._owner, le = fe(R.type, R._source, ee ? ee.type : null);
        Ei.setExtraStackFrame(le);
      } else
        Ei.setExtraStackFrame(null);
    }
    var or;
    or = !1;
    function ar(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function sr() {
      {
        if (qt.current) {
          var R = L(qt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function ol(R) {
      return "";
    }
    var hn = {};
    function Fo(R) {
      {
        var ee = sr();
        if (!ee) {
          var le = typeof R == "string" ? R : R.displayName || R.name;
          le && (ee = `

Check the top-level render call using <` + le + ">.");
        }
        return ee;
      }
    }
    function ki(R, ee) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var le = Fo(ee);
        if (hn[le])
          return;
        hn[le] = !0;
        var he = "";
        R && R._owner && R._owner !== qt.current && (he = " It was passed a child from " + L(R._owner.type) + "."), Rn(R), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', le, he), Rn(null);
      }
    }
    function Ci(R, ee) {
      {
        if (typeof R != "object")
          return;
        if (Et(R))
          for (var le = 0; le < R.length; le++) {
            var he = R[le];
            ar(he) && ki(he, ee);
          }
        else if (ar(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var De = g(R);
          if (typeof De == "function" && De !== R.entries)
            for (var ze = De.call(R), Ee; !(Ee = ze.next()).done; )
              ar(Ee.value) && ki(Ee.value, ee);
        }
      }
    }
    function J0(R) {
      {
        var ee = R.type;
        if (ee == null || typeof ee == "string")
          return;
        var le;
        if (typeof ee == "function")
          le = ee.propTypes;
        else if (typeof ee == "object" && (ee.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ee.$$typeof === f))
          le = ee.propTypes;
        else
          return;
        if (le) {
          var he = L(ee);
          nt(le, R.props, "prop", he, R);
        } else if (ee.PropTypes !== void 0 && !or) {
          or = !0;
          var De = L(ee);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", De || "Unknown");
        }
        typeof ee.getDefaultProps == "function" && !ee.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Q0(R) {
      {
        for (var ee = Object.keys(R.props), le = 0; le < ee.length; le++) {
          var he = ee[le];
          if (he !== "children" && he !== "key") {
            Rn(R), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", he), Rn(null);
            break;
          }
        }
        R.ref !== null && (Rn(R), b("Invalid attribute `ref` supplied to `React.Fragment`."), Rn(null));
      }
    }
    var mp = {};
    function gp(R, ee, le, he, De, ze) {
      {
        var Ee = O(R);
        if (!Ee) {
          var xe = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (xe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Pt = ol();
          Pt ? xe += Pt : xe += sr();
          var tt;
          R === null ? tt = "null" : Et(R) ? tt = "array" : R !== void 0 && R.$$typeof === t ? (tt = "<" + (L(R.type) || "Unknown") + " />", xe = " Did you accidentally export a JSX literal instead of a component?") : tt = typeof R, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", tt, xe);
        }
        var ot = Ze(R, ee, le, De, ze);
        if (ot == null)
          return ot;
        if (Ee) {
          var Gt = ee.children;
          if (Gt !== void 0)
            if (he)
              if (Et(Gt)) {
                for (var Tr = 0; Tr < Gt.length; Tr++)
                  Ci(Gt[Tr], R);
                Object.freeze && Object.freeze(Gt);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ci(Gt, R);
        }
        if (oe.call(ee, "key")) {
          var lr = L(R), _t = Object.keys(ee).filter(function(iE) {
            return iE !== "key";
          }), al = _t.length > 0 ? "{key: someKey, " + _t.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mp[lr + al]) {
            var rE = _t.length > 0 ? "{" + _t.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, al, lr, rE, lr), mp[lr + al] = !0;
          }
        }
        return R === r ? Q0(ot) : J0(ot), ot;
      }
    }
    function Z0(R, ee, le) {
      return gp(R, ee, le, !0);
    }
    function eE(R, ee, le) {
      return gp(R, ee, le, !1);
    }
    var tE = eE, nE = Z0;
    Ti.Fragment = r, Ti.jsx = tE, Ti.jsxs = nE;
  }()), Ti;
}
process.env.NODE_ENV === "production" ? Ju.exports = pE() : Ju.exports = hE();
var $ = Ju.exports;
function vE(e, t = []) {
  let n = [];
  function r(o, a) {
    const s = k.createContext(a), l = n.length;
    n = [...n, a];
    function u(f) {
      const { scope: p, children: d, ...v } = f, h = (p == null ? void 0 : p[e][l]) || s, g = k.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ $.jsx(h.Provider, { value: g, children: d });
    }
    function c(f, p) {
      const d = (p == null ? void 0 : p[e][l]) || s, v = k.useContext(d);
      if (v) return v;
      if (a !== void 0) return a;
      throw new Error(`\`${f}\` must be used within \`${o}\``);
    }
    return u.displayName = o + "Provider", [u, c];
  }
  const i = () => {
    const o = n.map((a) => k.createContext(a));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || o;
      return k.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return i.scopeName = e, [r, mE(i, ...t)];
}
function mE(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const a = r.reduce((s, { useScope: l, scopeName: u }) => {
        const f = l(o)[`__scope${u}`];
        return { ...s, ...f };
      }, {});
      return k.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Qn(e) {
  const t = k.useRef(e);
  return k.useEffect(() => {
    t.current = e;
  }), k.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
var Qr = globalThis != null && globalThis.document ? k.useLayoutEffect : () => {
};
function gE(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function yE(...e) {
  return (t) => e.forEach((n) => gE(n, t));
}
var My = k.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = k.Children.toArray(n), o = i.find(xE);
  if (o) {
    const a = o.props.children, s = i.map((l) => l === o ? k.Children.count(a) > 1 ? k.Children.only(null) : k.isValidElement(a) ? a.props.children : null : l);
    return /* @__PURE__ */ $.jsx(Qu, { ...r, ref: t, children: k.isValidElement(a) ? k.cloneElement(a, void 0, s) : null });
  }
  return /* @__PURE__ */ $.jsx(Qu, { ...r, ref: t, children: n });
});
My.displayName = "Slot";
var Qu = k.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (k.isValidElement(n)) {
    const i = SE(n);
    return k.cloneElement(n, {
      ...wE(r, n.props),
      // @ts-ignore
      ref: t ? yE(t, i) : i
    });
  }
  return k.Children.count(n) > 1 ? k.Children.only(null) : null;
});
Qu.displayName = "SlotClone";
var bE = ({ children: e }) => /* @__PURE__ */ $.jsx($.Fragment, { children: e });
function xE(e) {
  return k.isValidElement(e) && e.type === bE;
}
function wE(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...s) => {
      o(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function SE(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var EE = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], ff = EE.reduce((e, t) => {
  const n = k.forwardRef((r, i) => {
    const { asChild: o, ...a } = r, s = o ? My : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ $.jsx(s, { ...a, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {}), df = "Avatar", [kE, $X] = vE(df), [CE, jy] = kE(df), pf = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [i, o] = k.useState("idle");
    return /* @__PURE__ */ $.jsx(
      CE,
      {
        scope: n,
        imageLoadingStatus: i,
        onImageLoadingStatusChange: o,
        children: /* @__PURE__ */ $.jsx(ff.span, { ...r, ref: t })
      }
    );
  }
);
pf.displayName = df;
var Ny = "AvatarImage", hf = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
    }, ...o } = e, a = jy(Ny, n), s = $E(r), l = Qn((u) => {
      i(u), a.onImageLoadingStatusChange(u);
    });
    return Qr(() => {
      s !== "idle" && l(s);
    }, [s, l]), s === "loaded" ? /* @__PURE__ */ $.jsx(ff.img, { ...o, ref: t, src: r }) : null;
  }
);
hf.displayName = Ny;
var Ly = "AvatarFallback", vf = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...i } = e, o = jy(Ly, n), [a, s] = k.useState(r === void 0);
    return k.useEffect(() => {
      if (r !== void 0) {
        const l = window.setTimeout(() => s(!0), r);
        return () => window.clearTimeout(l);
      }
    }, [r]), a && o.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ $.jsx(ff.span, { ...i, ref: t }) : null;
  }
);
vf.displayName = Ly;
function $E(e) {
  const [t, n] = k.useState("idle");
  return Qr(() => {
    if (!e) {
      n("error");
      return;
    }
    let r = !0;
    const i = new window.Image(), o = (a) => () => {
      r && n(a);
    };
    return n("loading"), i.onload = o("loaded"), i.onerror = o("error"), i.src = e, () => {
      r = !1;
    };
  }, [e]), t;
}
function Zu(e) {
  if (!/^#?([a-fA-F\d]{6}|[a-fA-F\d]{3})$/.test(e))
    return { r: 0, g: 0, b: 0 };
  const n = e.replace(/^#/, "");
  let r = n;
  n.length === 3 && (r = n.split("").map((l) => l + l).join(""));
  const i = parseInt(r, 16), o = i >> 16 & 255, a = i >> 8 & 255, s = i & 255;
  return { r: o, g: a, b: s };
}
function TE(e) {
  return `#${((1 << 24) + (e.r << 16) + (e.g << 8) + e.b).toString(16).slice(1)}`;
}
const OE = (e, t = 30) => {
  const n = Math.min(e.r, e.g, e.b), r = Math.max(e.r, e.g, e.b, n + 1);
  return {
    r: Math.floor((e.r - n) / (r - n) * t * (1 - 0.299) + 120 - t / 2),
    g: Math.floor((e.g - n) / (r - n) * t * (1 - 0.587) + 120 - t / 2),
    b: Math.floor((e.b - n) / (r - n) * t * (1 - 0.114) + 120 - t / 2)
  };
};
function wp(e) {
  return Object.entries(e).reduce((t, [n, r]) => {
    const i = n.replace(/(\d+)/, (o) => (1e3 - parseInt(o)).toString());
    return { ...t, [i]: r };
  }, {});
}
const IE = 2.4, RE = 0.2126729, PE = 0.7151522, AE = 0.072175, DE = 0.56, _E = 0.57, ME = 0.62, jE = 0.65, Bo = 0.022, Sp = 1.414, NE = 1.14, LE = 1.14, FE = 0.035991, BE = 0.035991, zE = 27.7847239587675, WE = 27.7847239587675, Ep = 0.027, kp = 0.027, Cp = 1e-3, UE = 5e-4;
function $p(e) {
  const { r: t, g: n, b: r } = e, i = (o) => (o / 255) ** IE;
  return RE * i(t) + PE * i(n) + AE * i(r);
}
function Tp(e, t) {
  if (!e || !t)
    return 0;
  let n = $p(Zu(e)), r = $p(Zu(t)), i = 0, o = 0;
  return n = n > Bo ? n : n + (Bo - n) ** Sp, r = r > Bo ? r : r + (Bo - r) ** Sp, Math.abs(r - n) < UE ? 0 : (r > n ? (i = (r ** DE - n ** _E) * NE, o = i < Cp ? 0 : i < FE ? i - i * zE * Ep : i - Ep) : (i = (r ** jE - n ** ME) * LE, o = i > -Cp ? 0 : i > -BE ? i - i * WE * kp : i + kp), Math.abs(o * 100));
}
function Op(e, t) {
  let n = `${e} {`;
  for (const [r, i] of Object.entries(t))
    n += `${r}: ${i}; `;
  return n += "}", n;
}
function Fy(e, t) {
  let n = 0;
  if (e.length == 0)
    return n;
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    n = (n << 5) - n + i, n = n & n;
  }
  return Math.abs(n) % t;
}
var By = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(an, function() {
    var n = 1e3, r = 6e4, i = 36e5, o = "millisecond", a = "second", s = "minute", l = "hour", u = "day", c = "week", f = "month", p = "quarter", d = "year", v = "date", h = "Invalid Date", g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(M) {
      var _ = ["th", "st", "nd", "rd"], z = M % 100;
      return "[" + M + (_[(z - 20) % 10] || _[z] || _[0]) + "]";
    } }, w = function(M, _, z) {
      var q = String(M);
      return !q || q.length >= _ ? M : "" + Array(_ + 1 - q.length).join(z) + M;
    }, C = { s: w, z: function(M) {
      var _ = -M.utcOffset(), z = Math.abs(_), q = Math.floor(z / 60), H = z % 60;
      return (_ <= 0 ? "+" : "-") + w(q, 2, "0") + ":" + w(H, 2, "0");
    }, m: function M(_, z) {
      if (_.date() < z.date()) return -M(z, _);
      var q = 12 * (z.year() - _.year()) + (z.month() - _.month()), H = _.clone().add(q, f), P = z - H < 0, y = _.clone().add(q + (P ? -1 : 1), f);
      return +(-(q + (z - H) / (P ? H - y : y - H)) || 0);
    }, a: function(M) {
      return M < 0 ? Math.ceil(M) || 0 : Math.floor(M);
    }, p: function(M) {
      return { M: f, y: d, w: c, d: u, D: v, h: l, m: s, s: a, ms: o, Q: p }[M] || String(M || "").toLowerCase().replace(/s$/, "");
    }, u: function(M) {
      return M === void 0;
    } }, S = "en", E = {};
    E[S] = b;
    var I = "$isDayjsObject", N = function(M) {
      return M instanceof U || !(!M || !M[I]);
    }, A = function M(_, z, q) {
      var H;
      if (!_) return S;
      if (typeof _ == "string") {
        var P = _.toLowerCase();
        E[P] && (H = P), z && (E[P] = z, H = P);
        var y = _.split("-");
        if (!H && y.length > 1) return M(y[0]);
      } else {
        var T = _.name;
        E[T] = _, H = T;
      }
      return !q && H && (S = H), H || !q && S;
    }, O = function(M, _) {
      if (N(M)) return M.clone();
      var z = typeof _ == "object" ? _ : {};
      return z.date = M, z.args = arguments, new U(z);
    }, D = C;
    D.l = A, D.i = N, D.w = function(M, _) {
      return O(M, { locale: _.$L, utc: _.$u, x: _.$x, $offset: _.$offset });
    };
    var U = function() {
      function M(z) {
        this.$L = A(z.locale, null, !0), this.parse(z), this.$x = this.$x || z.x || {}, this[I] = !0;
      }
      var _ = M.prototype;
      return _.parse = function(z) {
        this.$d = function(q) {
          var H = q.date, P = q.utc;
          if (H === null) return /* @__PURE__ */ new Date(NaN);
          if (D.u(H)) return /* @__PURE__ */ new Date();
          if (H instanceof Date) return new Date(H);
          if (typeof H == "string" && !/Z$/i.test(H)) {
            var y = H.match(g);
            if (y) {
              var T = y[2] - 1 || 0, j = (y[7] || "0").substring(0, 3);
              return P ? new Date(Date.UTC(y[1], T, y[3] || 1, y[4] || 0, y[5] || 0, y[6] || 0, j)) : new Date(y[1], T, y[3] || 1, y[4] || 0, y[5] || 0, y[6] || 0, j);
            }
          }
          return new Date(H);
        }(z), this.init();
      }, _.init = function() {
        var z = this.$d;
        this.$y = z.getFullYear(), this.$M = z.getMonth(), this.$D = z.getDate(), this.$W = z.getDay(), this.$H = z.getHours(), this.$m = z.getMinutes(), this.$s = z.getSeconds(), this.$ms = z.getMilliseconds();
      }, _.$utils = function() {
        return D;
      }, _.isValid = function() {
        return this.$d.toString() !== h;
      }, _.isSame = function(z, q) {
        var H = O(z);
        return this.startOf(q) <= H && H <= this.endOf(q);
      }, _.isAfter = function(z, q) {
        return O(z) < this.startOf(q);
      }, _.isBefore = function(z, q) {
        return this.endOf(q) < O(z);
      }, _.$g = function(z, q, H) {
        return D.u(z) ? this[q] : this.set(H, z);
      }, _.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, _.valueOf = function() {
        return this.$d.getTime();
      }, _.startOf = function(z, q) {
        var H = this, P = !!D.u(q) || q, y = D.p(z), T = function(Z, X) {
          var J = D.w(H.$u ? Date.UTC(H.$y, X, Z) : new Date(H.$y, X, Z), H);
          return P ? J : J.endOf(u);
        }, j = function(Z, X) {
          return D.w(H.toDate()[Z].apply(H.toDate("s"), (P ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(X)), H);
        }, x = this.$W, F = this.$M, G = this.$D, K = "set" + (this.$u ? "UTC" : "");
        switch (y) {
          case d:
            return P ? T(1, 0) : T(31, 11);
          case f:
            return P ? T(1, F) : T(0, F + 1);
          case c:
            var Y = this.$locale().weekStart || 0, Q = (x < Y ? x + 7 : x) - Y;
            return T(P ? G - Q : G + (6 - Q), F);
          case u:
          case v:
            return j(K + "Hours", 0);
          case l:
            return j(K + "Minutes", 1);
          case s:
            return j(K + "Seconds", 2);
          case a:
            return j(K + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, _.endOf = function(z) {
        return this.startOf(z, !1);
      }, _.$set = function(z, q) {
        var H, P = D.p(z), y = "set" + (this.$u ? "UTC" : ""), T = (H = {}, H[u] = y + "Date", H[v] = y + "Date", H[f] = y + "Month", H[d] = y + "FullYear", H[l] = y + "Hours", H[s] = y + "Minutes", H[a] = y + "Seconds", H[o] = y + "Milliseconds", H)[P], j = P === u ? this.$D + (q - this.$W) : q;
        if (P === f || P === d) {
          var x = this.clone().set(v, 1);
          x.$d[T](j), x.init(), this.$d = x.set(v, Math.min(this.$D, x.daysInMonth())).$d;
        } else T && this.$d[T](j);
        return this.init(), this;
      }, _.set = function(z, q) {
        return this.clone().$set(z, q);
      }, _.get = function(z) {
        return this[D.p(z)]();
      }, _.add = function(z, q) {
        var H, P = this;
        z = Number(z);
        var y = D.p(q), T = function(F) {
          var G = O(P);
          return D.w(G.date(G.date() + Math.round(F * z)), P);
        };
        if (y === f) return this.set(f, this.$M + z);
        if (y === d) return this.set(d, this.$y + z);
        if (y === u) return T(1);
        if (y === c) return T(7);
        var j = (H = {}, H[s] = r, H[l] = i, H[a] = n, H)[y] || 1, x = this.$d.getTime() + z * j;
        return D.w(x, this);
      }, _.subtract = function(z, q) {
        return this.add(-1 * z, q);
      }, _.format = function(z) {
        var q = this, H = this.$locale();
        if (!this.isValid()) return H.invalidDate || h;
        var P = z || "YYYY-MM-DDTHH:mm:ssZ", y = D.z(this), T = this.$H, j = this.$m, x = this.$M, F = H.weekdays, G = H.months, K = H.meridiem, Y = function(X, J, V, ne) {
          return X && (X[J] || X(q, P)) || V[J].slice(0, ne);
        }, Q = function(X) {
          return D.s(T % 12 || 12, X, "0");
        }, Z = K || function(X, J, V) {
          var ne = X < 12 ? "AM" : "PM";
          return V ? ne.toLowerCase() : ne;
        };
        return P.replace(m, function(X, J) {
          return J || function(V) {
            switch (V) {
              case "YY":
                return String(q.$y).slice(-2);
              case "YYYY":
                return D.s(q.$y, 4, "0");
              case "M":
                return x + 1;
              case "MM":
                return D.s(x + 1, 2, "0");
              case "MMM":
                return Y(H.monthsShort, x, G, 3);
              case "MMMM":
                return Y(G, x);
              case "D":
                return q.$D;
              case "DD":
                return D.s(q.$D, 2, "0");
              case "d":
                return String(q.$W);
              case "dd":
                return Y(H.weekdaysMin, q.$W, F, 2);
              case "ddd":
                return Y(H.weekdaysShort, q.$W, F, 3);
              case "dddd":
                return F[q.$W];
              case "H":
                return String(T);
              case "HH":
                return D.s(T, 2, "0");
              case "h":
                return Q(1);
              case "hh":
                return Q(2);
              case "a":
                return Z(T, j, !0);
              case "A":
                return Z(T, j, !1);
              case "m":
                return String(j);
              case "mm":
                return D.s(j, 2, "0");
              case "s":
                return String(q.$s);
              case "ss":
                return D.s(q.$s, 2, "0");
              case "SSS":
                return D.s(q.$ms, 3, "0");
              case "Z":
                return y;
            }
            return null;
          }(X) || y.replace(":", "");
        });
      }, _.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, _.diff = function(z, q, H) {
        var P, y = this, T = D.p(q), j = O(z), x = (j.utcOffset() - this.utcOffset()) * r, F = this - j, G = function() {
          return D.m(y, j);
        };
        switch (T) {
          case d:
            P = G() / 12;
            break;
          case f:
            P = G();
            break;
          case p:
            P = G() / 3;
            break;
          case c:
            P = (F - x) / 6048e5;
            break;
          case u:
            P = (F - x) / 864e5;
            break;
          case l:
            P = F / i;
            break;
          case s:
            P = F / r;
            break;
          case a:
            P = F / n;
            break;
          default:
            P = F;
        }
        return H ? P : D.a(P);
      }, _.daysInMonth = function() {
        return this.endOf(f).$D;
      }, _.$locale = function() {
        return E[this.$L];
      }, _.locale = function(z, q) {
        if (!z) return this.$L;
        var H = this.clone(), P = A(z, q, !0);
        return P && (H.$L = P), H;
      }, _.clone = function() {
        return D.w(this.$d, this);
      }, _.toDate = function() {
        return new Date(this.valueOf());
      }, _.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, _.toISOString = function() {
        return this.$d.toISOString();
      }, _.toString = function() {
        return this.$d.toUTCString();
      }, M;
    }(), L = U.prototype;
    return O.prototype = L, [["$ms", o], ["$s", a], ["$m", s], ["$H", l], ["$W", u], ["$M", f], ["$y", d], ["$D", v]].forEach(function(M) {
      L[M[1]] = function(_) {
        return this.$g(_, M[0], M[1]);
      };
    }), O.extend = function(M, _) {
      return M.$i || (M(_, U, O), M.$i = !0), O;
    }, O.locale = A, O.isDayjs = N, O.unix = function(M) {
      return O(1e3 * M);
    }, O.en = E[S], O.Ls = E, O.p = {}, O;
  });
})(By);
var HE = By.exports;
const ps = /* @__PURE__ */ $e(HE);
var zy = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(an, function() {
    return function(n, r, i) {
      r.prototype.isToday = function() {
        var o = "YYYY-MM-DD", a = i();
        return this.format(o) === a.format(o);
      };
    };
  });
})(zy);
var VE = zy.exports;
const KE = /* @__PURE__ */ $e(VE);
var Wy = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(an, function() {
    return function(n, r, i) {
      r.prototype.isYesterday = function() {
        var o = "YYYY-MM-DD", a = i().subtract(1, "day");
        return this.format(o) === a.format(o);
      };
    };
  });
})(Wy);
var qE = Wy.exports;
const GE = /* @__PURE__ */ $e(qE);
let zo;
const YE = new Uint8Array(16);
function XE() {
  if (!zo && (zo = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !zo))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return zo(YE);
}
const yt = [];
for (let e = 0; e < 256; ++e)
  yt.push((e + 256).toString(16).slice(1));
function JE(e, t = 0) {
  return yt[e[t + 0]] + yt[e[t + 1]] + yt[e[t + 2]] + yt[e[t + 3]] + "-" + yt[e[t + 4]] + yt[e[t + 5]] + "-" + yt[e[t + 6]] + yt[e[t + 7]] + "-" + yt[e[t + 8]] + yt[e[t + 9]] + "-" + yt[e[t + 10]] + yt[e[t + 11]] + yt[e[t + 12]] + yt[e[t + 13]] + yt[e[t + 14]] + yt[e[t + 15]];
}
const QE = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Ip = {
  randomUUID: QE
};
function Uy(e, t, n) {
  if (Ip.randomUUID && !t && !e)
    return Ip.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || XE)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, JE(r);
}
ps.extend(KE);
ps.extend(GE);
function ZE(e, t, n, r, i) {
  return e.map((o) => {
    const { authorId: a } = o, s = a === n ? "outgoing" : "incoming", l = t.find((c) => c.id === a);
    let u;
    return l && l.id === n ? u = {
      name: l.name || "You",
      avatar: l.pictureUrl
    } : l ? u = {
      name: l.name || "Agent",
      avatar: l.pictureUrl
    } : u = {
      name: r || "Bot",
      avatar: i
    }, {
      ...o,
      direction: s,
      sender: u
    };
  });
}
function ek(e, t = "day") {
  var r, i, o;
  if (!e || e.length === 0) return [];
  const n = [];
  (r = e[0]) != null && r.timestamp && n.push(Rp(e[0].timestamp));
  for (let a = 0; a < e.length; a++)
    if (e[a] && n.push(e[a]), a + 1 < e.length) {
      const s = (i = e[a]) == null ? void 0 : i.timestamp, l = (o = e[a + 1]) == null ? void 0 : o.timestamp;
      !ps(s).isSame(l, t) && l && n.push(Rp(l));
    }
  return n;
}
function Rp(e) {
  return {
    id: Uy(),
    direction: "system",
    sender: { name: "system" },
    timestamp: e,
    block: {
      type: "text",
      text: tk(e)
    }
  };
}
function tk(e, t = !1) {
  const n = ps(e), r = "h:mma";
  return n.isToday() ? t ? `Today • ${n.format(r)}` : "Today" : n.isYesterday() ? t ? `Yesterday • ${n.format(r)}` : "Yesterday" : t ? n.format(`YYYY-MM-DD • ${r}`) : n.format("YYYY-MM-DD");
}
function nk(e = "") {
  if (typeof e != "string")
    throw new TypeError("Color should be string!");
  const t = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(e);
  if (t)
    return t.splice(1).map((r) => Number.parseInt(r, 16));
  const n = /^#?([\da-f])([\da-f])([\da-f])$/i.exec(e);
  if (n)
    return n.splice(1).map((r) => Number.parseInt(r + r, 16));
  if (e.includes(","))
    return e.split(",").map((r) => Number.parseInt(r));
  throw new Error("Invalid color format! Use #ABC or #AABBCC or r,g,b");
}
function rk(e) {
  return "#" + e.map((t) => `0${t.toString(16).toUpperCase()}`.slice(-2)).join("");
}
function ik(e, t) {
  return e.map((n) => Math.round(n + (255 - n) * t));
}
function ok(e, t) {
  return e.map((n) => Math.round(n * t));
}
const Oi = (e) => (t) => ik(t, e), Ii = (e) => (t) => ok(t, e), ak = {
  50: Oi(0.95),
  100: Oi(0.9),
  200: Oi(0.75),
  300: Oi(0.6),
  400: Oi(0.3),
  500: (e) => e,
  600: Ii(0.9),
  700: Ii(0.6),
  800: Ii(0.45),
  900: Ii(0.3),
  950: Ii(0.2)
};
function Pp(e, t = ak) {
  const n = {}, r = nk(e);
  for (const [i, o] of Object.entries(t))
    n[i] = rk(o(r));
  return n;
}
function sk(e) {
  const { fontFamily: t, radius: n, themeMode: r, color: i, variant: o, headerVariant: a } = e;
  let s = {}, l = {};
  if (i) {
    const d = Pp(i), v = r === "dark" ? wp(d) : d, h = Pp(TE(OE(Zu(i)))), g = r === "dark" ? wp(h) : h, m = r === "dark" ? "#101010" : "#fdfdfd";
    l = Object.entries({ ...v, 1: m }).reduce(
      (w, [C, S]) => ({ ...w, [`--bpPrimary-${C}`]: S }),
      {}
    );
    const b = Object.entries({ ...g, 1: m }).reduce(
      (w, [C, S]) => ({ ...w, [`--bpGray-${C}`]: S }),
      {}
    );
    s = {
      ...l,
      ...b
    };
  }
  n && (s = {
    ...s,
    "--bpRadius-scale": n.toString()
  });
  const u = r === "dark" ? { bg: "var(--transparent-dark)", bgHover: "var(--transparent-dark-hover)" } : { bg: "var(--transparent-light)", bgHover: "var(--transparent-light-hover)" }, c = l ? Tp(l["--bpPrimary-600"], l["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)", f = o === "solid" ? {
    "--message-bg": "var(--bpPrimary-600)",
    "--message-bg-hover": "var(--bpPrimary-700)",
    "--message-text": c,
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-200)",
    "--button-bg-hover": "var(--bpPrimary-300)",
    "--button-text": "var(--bpPrimary-800)",
    "--fab-bg": "var(--bpPrimary-600)",
    "--fab-bg-hover": "var(--bpPrimary-700)",
    "--fab-icon": c,
    "--modal-submit-bg": "var(--bpPrimary-600)",
    "--modal-submit-bg-hover": "var(--bpPrimary-700)"
  } : {
    "--message-bg": "var(--bpPrimary-100)",
    "--message-bg-hover": "var(--bpPrimary-200)",
    "--message-text": "var(--bpPrimary-900)",
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-500)",
    "--button-bg-hover": "var(--bpPrimary-600)",
    "--button-text": l ? Tp(l["--bpPrimary-500"], l["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)",
    "--fab-bg": "var(--bpPrimary-100)",
    "--fab-bg-hover": "var(--bpPrimary-200)",
    "--fab-icon": "var(--bpPrimary-700)",
    "--scrollbar": "var(--bpGray-500)",
    "--scrollbar-hover": "var(--bpGray-400)",
    "--modal-submit-bg": "var(--bpPrimary-200)",
    "--modal-submit-bg-hover": "var(--bpPrimary-300)"
  }, p = a === "solid" ? {
    "--header-bg": "var(--bpPrimary-600)",
    "--header-bg-hover": "var(--bpPrimary-700)",
    "--header-hover-dark": "var(--bpPrimary-800)",
    "--header-title": c,
    "--header-description": c,
    "--header-description-icon": c,
    "--header-description-link": c,
    "--header-avatar-bg": "var(--bpPrimary-300)",
    "--header-avatar-text": "var(--bpPrimary-700)"
  } : {
    "--header-bg": u.bg,
    "--header-bg-hover": u.bgHover,
    "--header-hover-dark": "var(--bpGray-200)",
    "--header-title": "var(--bpGray-900)",
    "--header-description": "var(--bpGray-600)",
    "--header-description-icon": "var(--bpPrimary-700)",
    "--header-description-link": "var(--bpPrimary-800)",
    "--header-avatar-bg": "var(--bpPrimary-600)",
    "--header-avatar-text": "var(--bpPrimary-50)"
  };
  return s = {
    ...s,
    ...f,
    ...p
  }, Op(":root", s) + (t ? Op(".bpFont", { "font-family": `var(--${t}-font)` }) : "");
}
const lk = (e, t = {}) => new Promise((n, r) => {
  if (typeof window > "u")
    return r("Window is not defined");
  if (!e)
    return r("Url is not defined");
  let i = null;
  const o = new Image();
  o.addEventListener("load", () => {
    i && clearTimeout(i), n({ width: o.naturalWidth, height: o.naturalHeight });
  }), o.addEventListener("error", (a) => {
    i && clearTimeout(i), r(`${a.type}: ${a.message}`);
  }), o.src = e, t.timeout && (i = setTimeout(() => r("Timeout"), t.timeout));
}), uk = ["audio", "file", "image", "video"], ck = (e) => uk.includes(e), fk = "The Client ID is required to initialize the webchat.", TX = "The API url is required to initialize the webchat.", OX = "The Bot ID is required to initialize the webchat.", IX = "No config URL provided.", dk = "Invalid API URL. Please use a valid API URL.", pk = "Invalid Client ID. Please use a valid Botpress Client ID.", hk = "Invalid URL. Please make sure your client ID and API URL are valid", RX = "Invalid config URL. Please make sure your config URL is valid", PX = "Invalid webchat configuration, please make sure your config file is valid", AX = "Access denied to configuration file. Please check your credentials or your configuration URL and try again.", vk = "This bot is currently blocked or disabled.", mk = "This bot has temporarily paused. Please check back later.", gk = "You are not a participant of this conversation, please clear your local storage.", yk = "Please check your internet connection and refresh the page.", sl = (e) => {
  var n, r;
  console.error("An error occurred:", e);
  let t = {
    type: "unknown",
    message: "An unexpected error occurred"
  };
  if (e instanceof Error && "id" in e && "code" in e && "type" in e) {
    const i = e;
    i.code === 404 && ((n = i.message) != null && n.includes("[Webhook Handler]")) && i.type === "ResourceNotFound" ? t = {
      type: "configuration",
      message: pk
    } : i.code === 403 && ((r = i.message) != null && r.includes("[Webhook Handler]")) && i.type === "Forbidden" ? t = {
      type: "bot",
      message: vk
    } : i.code === 405 && i.type === "MethodNotFound" ? t = {
      type: "configuration",
      message: hk
    } : i.code === 403 && i.type === "QuotaExceeded" ? t = {
      type: "bot",
      message: mk
    } : i.code === 403 && i.type === "Forbidden" ? t = {
      type: "bot",
      message: gk
    } : t = {
      type: i.type,
      message: i.message
    };
  } else e instanceof Error && (e.message.replaceAll(" ", "").toLowerCase().includes("networkerror") || e.message.replaceAll(" ", "").toLowerCase().includes("failedtofetch")) && (t = {
    type: "network",
    message: yk
  });
  return t;
}, mf = Ot(
  ({ userId: e, src: t, container: n, image: r, fallback: i, ...o }, a) => {
    const s = Fy(e ?? "", 15);
    return /* @__PURE__ */ $.jsxs(pf, { ref: a, "data-color": s, ...n, ...o, children: [
      /* @__PURE__ */ $.jsx(hf, { src: t, ...r }),
      /* @__PURE__ */ $.jsx(vf, { ...i, children: typeof o.children == "string" ? o.children[0] : o.children })
    ] });
  }
);
mf.displayName = "Avatar";
function bk(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const xk = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, wk = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Sk = {};
function Ap(e, t) {
  return (Sk.jsx ? wk : xk).test(e);
}
const Ek = /[ \t\n\f\r]/g;
function kk(e) {
  return typeof e == "object" ? e.type === "text" ? Dp(e.value) : !1 : Dp(e);
}
function Dp(e) {
  return e.replace(Ek, "") === "";
}
class fo {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
fo.prototype.property = {};
fo.prototype.normal = {};
fo.prototype.space = null;
function Hy(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new fo(n, r, t);
}
function ec(e) {
  return e.toLowerCase();
}
class Zt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
Zt.prototype.space = null;
Zt.prototype.boolean = !1;
Zt.prototype.booleanish = !1;
Zt.prototype.overloadedBoolean = !1;
Zt.prototype.number = !1;
Zt.prototype.commaSeparated = !1;
Zt.prototype.spaceSeparated = !1;
Zt.prototype.commaOrSpaceSeparated = !1;
Zt.prototype.mustUseProperty = !1;
Zt.prototype.defined = !1;
let Ck = 0;
const me = xr(), at = xr(), Vy = xr(), re = xr(), He = xr(), Kr = xr(), zt = xr();
function xr() {
  return 2 ** ++Ck;
}
const tc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: me,
  booleanish: at,
  commaOrSpaceSeparated: zt,
  commaSeparated: Kr,
  number: re,
  overloadedBoolean: Vy,
  spaceSeparated: He
}, Symbol.toStringTag, { value: "Module" })), ll = Object.keys(tc);
class gf extends Zt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let o = -1;
    if (super(t, n), _p(this, "space", i), typeof r == "number")
      for (; ++o < ll.length; ) {
        const a = ll[o];
        _p(this, ll[o], (r & tc[a]) === tc[a]);
      }
  }
}
gf.prototype.defined = !0;
function _p(e, t, n) {
  n && (e[t] = n);
}
const $k = {}.hasOwnProperty;
function di(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if ($k.call(e.properties, r)) {
      const i = e.properties[r], o = new gf(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0), t[r] = o, n[ec(r)] = r, n[ec(o.attribute)] = r;
    }
  return new fo(t, n, e.space);
}
const Ky = di({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), qy = di({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Gy(e, t) {
  return t in e ? e[t] : t;
}
function Yy(e, t) {
  return Gy(e, t.toLowerCase());
}
const Xy = di({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Yy,
  properties: { xmlns: null, xmlnsXLink: null }
}), Jy = di({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: at,
    ariaAutoComplete: null,
    ariaBusy: at,
    ariaChecked: at,
    ariaColCount: re,
    ariaColIndex: re,
    ariaColSpan: re,
    ariaControls: He,
    ariaCurrent: null,
    ariaDescribedBy: He,
    ariaDetails: null,
    ariaDisabled: at,
    ariaDropEffect: He,
    ariaErrorMessage: null,
    ariaExpanded: at,
    ariaFlowTo: He,
    ariaGrabbed: at,
    ariaHasPopup: null,
    ariaHidden: at,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: He,
    ariaLevel: re,
    ariaLive: null,
    ariaModal: at,
    ariaMultiLine: at,
    ariaMultiSelectable: at,
    ariaOrientation: null,
    ariaOwns: He,
    ariaPlaceholder: null,
    ariaPosInSet: re,
    ariaPressed: at,
    ariaReadOnly: at,
    ariaRelevant: null,
    ariaRequired: at,
    ariaRoleDescription: He,
    ariaRowCount: re,
    ariaRowIndex: re,
    ariaRowSpan: re,
    ariaSelected: at,
    ariaSetSize: re,
    ariaSort: null,
    ariaValueMax: re,
    ariaValueMin: re,
    ariaValueNow: re,
    ariaValueText: null,
    role: null
  }
}), Tk = di({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Yy,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Kr,
    acceptCharset: He,
    accessKey: He,
    action: null,
    allow: null,
    allowFullScreen: me,
    allowPaymentRequest: me,
    allowUserMedia: me,
    alt: null,
    as: null,
    async: me,
    autoCapitalize: null,
    autoComplete: He,
    autoFocus: me,
    autoPlay: me,
    blocking: He,
    capture: null,
    charSet: null,
    checked: me,
    cite: null,
    className: He,
    cols: re,
    colSpan: null,
    content: null,
    contentEditable: at,
    controls: me,
    controlsList: He,
    coords: re | Kr,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: me,
    defer: me,
    dir: null,
    dirName: null,
    disabled: me,
    download: Vy,
    draggable: at,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: me,
    formTarget: null,
    headers: He,
    height: re,
    hidden: me,
    high: re,
    href: null,
    hrefLang: null,
    htmlFor: He,
    httpEquiv: He,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: me,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: me,
    itemId: null,
    itemProp: He,
    itemRef: He,
    itemScope: me,
    itemType: He,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: me,
    low: re,
    manifest: null,
    max: null,
    maxLength: re,
    media: null,
    method: null,
    min: null,
    minLength: re,
    multiple: me,
    muted: me,
    name: null,
    nonce: null,
    noModule: me,
    noValidate: me,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: me,
    optimum: re,
    pattern: null,
    ping: He,
    placeholder: null,
    playsInline: me,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: me,
    referrerPolicy: null,
    rel: He,
    required: me,
    reversed: me,
    rows: re,
    rowSpan: re,
    sandbox: He,
    scope: null,
    scoped: me,
    seamless: me,
    selected: me,
    shadowRootClonable: me,
    shadowRootDelegatesFocus: me,
    shadowRootMode: null,
    shape: null,
    size: re,
    sizes: null,
    slot: null,
    span: re,
    spellCheck: at,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: re,
    step: null,
    style: null,
    tabIndex: re,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: me,
    useMap: null,
    value: at,
    width: re,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: He,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: re,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: re,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: me,
    // Lists. Use CSS to reduce space between items instead
    declare: me,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: re,
    // `<img>` and `<object>`
    leftMargin: re,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: re,
    // `<body>`
    marginWidth: re,
    // `<body>`
    noResize: me,
    // `<frame>`
    noHref: me,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: me,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: me,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: re,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: at,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: re,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: re,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: me,
    disableRemotePlayback: me,
    prefix: null,
    property: null,
    results: re,
    security: null,
    unselectable: null
  }
}), Ok = di({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Gy,
  properties: {
    about: zt,
    accentHeight: re,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: re,
    amplitude: re,
    arabicForm: null,
    ascent: re,
    attributeName: null,
    attributeType: null,
    azimuth: re,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: re,
    by: null,
    calcMode: null,
    capHeight: re,
    className: He,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: re,
    diffuseConstant: re,
    direction: null,
    display: null,
    dur: null,
    divisor: re,
    dominantBaseline: null,
    download: me,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: re,
    enableBackground: null,
    end: null,
    event: null,
    exponent: re,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: re,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Kr,
    g2: Kr,
    glyphName: Kr,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: re,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: re,
    horizOriginX: re,
    horizOriginY: re,
    id: null,
    ideographic: re,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: re,
    k: re,
    k1: re,
    k2: re,
    k3: re,
    k4: re,
    kernelMatrix: zt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: re,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: re,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: re,
    overlineThickness: re,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: re,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: He,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: re,
    pointsAtY: re,
    pointsAtZ: re,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: zt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: zt,
    rev: zt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: zt,
    requiredFeatures: zt,
    requiredFonts: zt,
    requiredFormats: zt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: re,
    specularExponent: re,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: re,
    strikethroughThickness: re,
    string: null,
    stroke: null,
    strokeDashArray: zt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: re,
    strokeOpacity: re,
    strokeWidth: null,
    style: null,
    surfaceScale: re,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: zt,
    tabIndex: re,
    tableValues: null,
    target: null,
    targetX: re,
    targetY: re,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: zt,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: re,
    underlineThickness: re,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: re,
    values: null,
    vAlphabetic: re,
    vMathematical: re,
    vectorEffect: null,
    vHanging: re,
    vIdeographic: re,
    version: null,
    vertAdvY: re,
    vertOriginX: re,
    vertOriginY: re,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: re,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), Ik = /^data[-\w.:]+$/i, Mp = /-[a-z]/g, Rk = /[A-Z]/g;
function Pk(e, t) {
  const n = ec(t);
  let r = t, i = Zt;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Ik.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace(Mp, Dk);
      r = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!Mp.test(o)) {
        let a = o.replace(Rk, Ak);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    i = gf;
  }
  return new i(r, t);
}
function Ak(e) {
  return "-" + e.toLowerCase();
}
function Dk(e) {
  return e.charAt(1).toUpperCase();
}
const _k = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Mk = Hy([qy, Ky, Xy, Jy, Tk], "html"), yf = Hy([qy, Ky, Xy, Jy, Ok], "svg");
function jk(e) {
  return e.join(" ").trim();
}
var Qy = {}, jp = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Nk = /\n/g, Lk = /^\s*/, Fk = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Bk = /^:\s*/, zk = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Wk = /^[;\s]*/, Uk = /^\s+|\s+$/g, Hk = `
`, Np = "/", Lp = "*", dr = "", Vk = "comment", Kk = "declaration", qk = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function i(v) {
    var h = v.match(Nk);
    h && (n += h.length);
    var g = v.lastIndexOf(Hk);
    r = ~g ? v.length - g : r + v.length;
  }
  function o() {
    var v = { line: n, column: r };
    return function(h) {
      return h.position = new a(v), u(), h;
    };
  }
  function a(v) {
    this.start = v, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(v) {
    var h = new Error(
      t.source + ":" + n + ":" + r + ": " + v
    );
    if (h.reason = v, h.filename = t.source, h.line = n, h.column = r, h.source = e, !t.silent) throw h;
  }
  function l(v) {
    var h = v.exec(e);
    if (h) {
      var g = h[0];
      return i(g), e = e.slice(g.length), h;
    }
  }
  function u() {
    l(Lk);
  }
  function c(v) {
    var h;
    for (v = v || []; h = f(); )
      h !== !1 && v.push(h);
    return v;
  }
  function f() {
    var v = o();
    if (!(Np != e.charAt(0) || Lp != e.charAt(1))) {
      for (var h = 2; dr != e.charAt(h) && (Lp != e.charAt(h) || Np != e.charAt(h + 1)); )
        ++h;
      if (h += 2, dr === e.charAt(h - 1))
        return s("End of comment missing");
      var g = e.slice(2, h - 2);
      return r += 2, i(g), e = e.slice(h), r += 2, v({
        type: Vk,
        comment: g
      });
    }
  }
  function p() {
    var v = o(), h = l(Fk);
    if (h) {
      if (f(), !l(Bk)) return s("property missing ':'");
      var g = l(zk), m = v({
        type: Kk,
        property: Fp(h[0].replace(jp, dr)),
        value: g ? Fp(g[0].replace(jp, dr)) : dr
      });
      return l(Wk), m;
    }
  }
  function d() {
    var v = [];
    c(v);
    for (var h; h = p(); )
      h !== !1 && (v.push(h), c(v));
    return v;
  }
  return u(), d();
};
function Fp(e) {
  return e ? e.replace(Uk, dr) : dr;
}
var Gk = an && an.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Qy, "__esModule", { value: !0 });
var Bp = Qy.default = Xk, Yk = Gk(qk);
function Xk(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Yk.default)(e), i = typeof t == "function";
  return r.forEach(function(o) {
    if (o.type === "declaration") {
      var a = o.property, s = o.value;
      i ? t(a, s, o) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
const Jk = Bp.default || Bp, Zy = eb("end"), bf = eb("start");
function eb(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function Qk(e) {
  const t = bf(e), n = Zy(e);
  if (t && n)
    return { start: t, end: n };
}
function Hi(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? zp(e.position) : "start" in e || "end" in e ? zp(e) : "line" in e || "column" in e ? nc(e) : "";
}
function nc(e) {
  return Wp(e && e.line) + ":" + Wp(e && e.column);
}
function zp(e) {
  return nc(e && e.start) + "-" + nc(e && e.end);
}
function Wp(e) {
  return e && typeof e == "number" ? e : 1;
}
class It extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", o = {}, a = !1;
    if (n && ("line" in n && "column" in n ? o = { place: n } : "start" in n && "end" in n ? o = { place: n } : "type" in n ? o = {
      ancestors: [n],
      place: n.position
    } : o = { ...n }), typeof t == "string" ? i = t : !o.cause && t && (a = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? o.ruleId = r : (o.source = r.slice(0, l), o.ruleId = r.slice(l + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const l = o.ancestors[o.ancestors.length - 1];
      l && (o.place = l.position);
    }
    const s = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = Hi(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = a && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
It.prototype.file = "";
It.prototype.name = "";
It.prototype.reason = "";
It.prototype.message = "";
It.prototype.stack = "";
It.prototype.column = void 0;
It.prototype.line = void 0;
It.prototype.ancestors = void 0;
It.prototype.cause = void 0;
It.prototype.fatal = void 0;
It.prototype.place = void 0;
It.prototype.ruleId = void 0;
It.prototype.source = void 0;
const xf = {}.hasOwnProperty, Zk = /* @__PURE__ */ new Map(), eC = /[A-Z]/g, tC = /-([a-z])/g, nC = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), rC = /* @__PURE__ */ new Set(["td", "th"]), tb = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function iC(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = dC(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = fC(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? yf : Mk,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = nb(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function nb(e, t, n) {
  if (t.type === "element")
    return oC(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return aC(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return lC(e, t, n);
  if (t.type === "mdxjsEsm")
    return sC(e, t);
  if (t.type === "root")
    return uC(e, t, n);
  if (t.type === "text")
    return cC(e, t);
}
function oC(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = yf, e.schema = i), e.ancestors.push(t);
  const o = ib(e, t.tagName, !1), a = pC(e, t);
  let s = Sf(e, t);
  return nC.has(t.tagName) && (s = s.filter(function(l) {
    return typeof l == "string" ? !kk(l) : !0;
  })), rb(e, a, o, t), wf(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n);
}
function aC(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Ji(e, t.position);
}
function sC(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Ji(e, t.position);
}
function lC(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = yf, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : ib(e, t.name, !0), a = hC(e, t), s = Sf(e, t);
  return rb(e, a, o, t), wf(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n);
}
function uC(e, t, n) {
  const r = {};
  return wf(r, Sf(e, t)), e.create(t, e.Fragment, r, n);
}
function cC(e, t) {
  return t.value;
}
function rb(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function wf(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function fC(e, t, n) {
  return r;
  function r(i, o, a, s) {
    const u = Array.isArray(a.children) ? n : t;
    return s ? u(o, a, s) : u(o, a);
  }
}
function dC(e, t) {
  return n;
  function n(r, i, o, a) {
    const s = Array.isArray(o.children), l = bf(r);
    return t(
      i,
      o,
      a,
      s,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function pC(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && xf.call(t.properties, i)) {
      const o = vC(e, i, t.properties[i]);
      if (o) {
        const [a, s] = o;
        e.tableCellAlignToStyle && a === "align" && typeof s == "string" && rC.has(t.tagName) ? r = s : n[a] = s;
      }
    }
  if (r) {
    const o = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function hC(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const a = o.expression;
        a.type;
        const s = a.properties[0];
        s.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        Ji(e, t.position);
    else {
      const i = r.name;
      let o;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const s = r.value.data.estree.body[0];
          s.type, o = e.evaluater.evaluateExpression(s.expression);
        } else
          Ji(e, t.position);
      else
        o = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return n;
}
function Sf(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : Zk;
  for (; ++r < t.children.length; ) {
    const o = t.children[r];
    let a;
    if (e.passKeys) {
      const l = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (l) {
        const u = i.get(l) || 0;
        a = l + "-" + u, i.set(l, u + 1);
      }
    }
    const s = nb(e, o, a);
    s !== void 0 && n.push(s);
  }
  return n;
}
function vC(e, t, n) {
  const r = Pk(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? bk(n) : jk(n)), r.property === "style") {
      let i = typeof n == "object" ? n : mC(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = gC(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? _k[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function mC(e, t) {
  const n = {};
  try {
    Jk(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const o = (
        /** @type {Error} */
        i
      ), a = new It("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: o,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw a.file = e.filePath || void 0, a.url = tb + "#cannot-parse-style-attribute", a;
    }
  }
  return n;
  function r(i, o) {
    let a = i;
    a.slice(0, 2) !== "--" && (a.slice(0, 4) === "-ms-" && (a = "ms-" + a.slice(4)), a = a.replace(tC, bC)), n[a] = o;
  }
}
function ib(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, a;
    for (; ++o < i.length; ) {
      const s = Ap(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      a = a ? {
        type: "MemberExpression",
        object: a,
        property: s,
        computed: !!(o && s.type === "Literal"),
        optional: !1
      } : s;
    }
    r = a;
  } else
    r = Ap(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return xf.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Ji(e);
}
function Ji(e, t) {
  const n = new It(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = tb + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function gC(e) {
  const t = {};
  let n;
  for (n in e)
    xf.call(e, n) && (t[yC(n)] = e[n]);
  return t;
}
function yC(e) {
  let t = e.replace(eC, xC);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function bC(e, t) {
  return t.toUpperCase();
}
function xC(e) {
  return "-" + e.toLowerCase();
}
const ul = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, wC = {};
function Ef(e, t) {
  const n = wC, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return ob(e, r, i);
}
function ob(e, t, n) {
  if (SC(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Up(e.children, t, n);
  }
  return Array.isArray(e) ? Up(e, t, n) : "";
}
function Up(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = ob(e[i], t, n);
  return r.join("");
}
function SC(e) {
  return !!(e && typeof e == "object");
}
const Hp = document.createElement("i");
function kf(e) {
  const t = "&" + e + ";";
  Hp.innerHTML = t;
  const n = Hp.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Qt(e, t, n, r) {
  const i = e.length;
  let o = 0, a;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(t, n), e.splice(...a);
  else
    for (n && e.splice(t, n); o < r.length; )
      a = r.slice(o, o + 1e4), a.unshift(t, 0), e.splice(...a), o += 1e4, t += 1e4;
}
function Yt(e, t) {
  return e.length > 0 ? (Qt(e, e.length, 0, t), e) : t;
}
const Vp = {}.hasOwnProperty;
function ab(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    EC(t, e[n]);
  return t;
}
function EC(e, t) {
  let n;
  for (n in t) {
    const i = (Vp.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let a;
    if (o)
      for (a in o) {
        Vp.call(i, a) || (i[a] = []);
        const s = o[a];
        kC(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function kC(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Qt(e, 0, 0, r);
}
function sb(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "�" : String.fromCodePoint(n)
  );
}
function ln(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Dt = tr(/[A-Za-z]/), Tt = tr(/[\dA-Za-z]/), CC = tr(/[#-'*+\--9=?A-Z^-~]/);
function Na(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const rc = tr(/\d/), $C = tr(/[\dA-Fa-f]/), TC = tr(/[!-/:-@[-`{-~]/);
function de(e) {
  return e !== null && e < -2;
}
function Ue(e) {
  return e !== null && (e < 0 || e === 32);
}
function be(e) {
  return e === -2 || e === -1 || e === 32;
}
const hs = tr(new RegExp("\\p{P}|\\p{S}", "u")), gr = tr(/\s/);
function tr(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function pi(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const o = e.charCodeAt(n);
    let a = "";
    if (o === 37 && Tt(e.charCodeAt(n + 1)) && Tt(e.charCodeAt(n + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const s = e.charCodeAt(n + 1);
      o < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(o, s), i = 1) : a = "�";
    } else
      a = String.fromCharCode(o);
    a && (t.push(e.slice(r, n), encodeURIComponent(a)), r = n + i + 1, a = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function Ce(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return a;
  function a(l) {
    return be(l) ? (e.enter(n), s(l)) : t(l);
  }
  function s(l) {
    return be(l) && o++ < i ? (e.consume(l), s) : (e.exit(n), t(l));
  }
}
const OC = {
  tokenize: IC
};
function IC(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return t;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Ce(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), o(s);
  }
  function o(s) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, a(s);
  }
  function a(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return de(s) ? (e.consume(s), e.exit("chunkText"), o) : (e.consume(s), a);
  }
}
const RC = {
  tokenize: PC
}, Kp = {
  tokenize: AC
};
function PC(e) {
  const t = this, n = [];
  let r = 0, i, o, a;
  return s;
  function s(w) {
    if (r < n.length) {
      const C = n[r];
      return t.containerState = C[1], e.attempt(
        C[0].continuation,
        l,
        u
      )(w);
    }
    return u(w);
  }
  function l(w) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && b();
      const C = t.events.length;
      let S = C, E;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          E = t.events[S][1].end;
          break;
        }
      m(r);
      let I = C;
      for (; I < t.events.length; )
        t.events[I][1].end = Object.assign({}, E), I++;
      return Qt(
        t.events,
        S + 1,
        0,
        t.events.slice(C)
      ), t.events.length = I, u(w);
    }
    return s(w);
  }
  function u(w) {
    if (r === n.length) {
      if (!i)
        return p(w);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return v(w);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Kp,
      c,
      f
    )(w);
  }
  function c(w) {
    return i && b(), m(r), p(w);
  }
  function f(w) {
    return t.parser.lazy[t.now().line] = r !== n.length, a = t.now().offset, v(w);
  }
  function p(w) {
    return t.containerState = {}, e.attempt(
      Kp,
      d,
      v
    )(w);
  }
  function d(w) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(w);
  }
  function v(w) {
    if (w === null) {
      i && b(), m(0), e.consume(w);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: o,
      _tokenizer: i
    }), h(w);
  }
  function h(w) {
    if (w === null) {
      g(e.exit("chunkFlow"), !0), m(0), e.consume(w);
      return;
    }
    return de(w) ? (e.consume(w), g(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(w), h);
  }
  function g(w, C) {
    const S = t.sliceStream(w);
    if (C && S.push(null), w.previous = o, o && (o.next = w), o = w, i.defineSkip(w.start), i.write(S), t.parser.lazy[w.start.line]) {
      let E = i.events.length;
      for (; E--; )
        if (
          // The token starts before the line ending…
          i.events[E][1].start.offset < a && // …and either is not ended yet…
          (!i.events[E][1].end || // …or ends after it.
          i.events[E][1].end.offset > a)
        )
          return;
      const I = t.events.length;
      let N = I, A, O;
      for (; N--; )
        if (t.events[N][0] === "exit" && t.events[N][1].type === "chunkFlow") {
          if (A) {
            O = t.events[N][1].end;
            break;
          }
          A = !0;
        }
      for (m(r), E = I; E < t.events.length; )
        t.events[E][1].end = Object.assign({}, O), E++;
      Qt(
        t.events,
        N + 1,
        0,
        t.events.slice(I)
      ), t.events.length = E;
    }
  }
  function m(w) {
    let C = n.length;
    for (; C-- > w; ) {
      const S = n[C];
      t.containerState = S[1], S[0].exit.call(t, e);
    }
    n.length = w;
  }
  function b() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function AC(e, t, n) {
  return Ce(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function La(e) {
  if (e === null || Ue(e) || gr(e))
    return 1;
  if (hs(e))
    return 2;
}
function vs(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !r.includes(o) && (t = o(t, n), r.push(o));
  }
  return t;
}
const ic = {
  name: "attention",
  tokenize: _C,
  resolveAll: DC
};
function DC(e, t) {
  let n = -1, r, i, o, a, s, l, u, c;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          qp(f, -l), qp(p, l), a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, o = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, a.start),
            end: Object.assign({}, s.end)
          }, e[r][1].end = Object.assign({}, a.start), e[n][1].start = Object.assign({}, s.end), u = [], e[r][1].end.offset - e[r][1].start.offset && (u = Yt(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = Yt(u, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["enter", o, t]]), u = Yt(u, vs(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = Yt(u, [["exit", o, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (c = 2, u = Yt(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : c = 0, Qt(e, r - 1, n - r + 3, u), n = r + u.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function _C(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = La(r);
  let o;
  return a;
  function a(l) {
    return o = l, e.enter("attentionSequence"), s(l);
  }
  function s(l) {
    if (l === o)
      return e.consume(l), s;
    const u = e.exit("attentionSequence"), c = La(l), f = !c || c === 2 && i || n.includes(l), p = !i || i === 2 && c || n.includes(r);
    return u._open = !!(o === 42 ? f : f && (i || !p)), u._close = !!(o === 42 ? p : p && (c || !f)), t(l);
  }
}
function qp(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const MC = {
  name: "autolink",
  tokenize: jC
};
function jC(e, t, n) {
  let r = 0;
  return i;
  function i(d) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(d) {
    return Dt(d) ? (e.consume(d), a) : d === 64 ? n(d) : u(d);
  }
  function a(d) {
    return d === 43 || d === 45 || d === 46 || Tt(d) ? (r = 1, s(d)) : u(d);
  }
  function s(d) {
    return d === 58 ? (e.consume(d), r = 0, l) : (d === 43 || d === 45 || d === 46 || Tt(d)) && r++ < 32 ? (e.consume(d), s) : (r = 0, u(d));
  }
  function l(d) {
    return d === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : d === null || d === 32 || d === 60 || Na(d) ? n(d) : (e.consume(d), l);
  }
  function u(d) {
    return d === 64 ? (e.consume(d), c) : CC(d) ? (e.consume(d), u) : n(d);
  }
  function c(d) {
    return Tt(d) ? f(d) : n(d);
  }
  function f(d) {
    return d === 46 ? (e.consume(d), r = 0, c) : d === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(d);
  }
  function p(d) {
    if ((d === 45 || Tt(d)) && r++ < 63) {
      const v = d === 45 ? p : f;
      return e.consume(d), v;
    }
    return n(d);
  }
}
const po = {
  tokenize: NC,
  partial: !0
};
function NC(e, t, n) {
  return r;
  function r(o) {
    return be(o) ? Ce(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || de(o) ? t(o) : n(o);
  }
}
const lb = {
  name: "blockQuote",
  tokenize: LC,
  continuation: {
    tokenize: FC
  },
  exit: BC
};
function LC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    if (a === 62) {
      const s = r.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), o;
    }
    return n(a);
  }
  function o(a) {
    return be(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a));
  }
}
function FC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return be(a) ? Ce(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : o(a);
  }
  function o(a) {
    return e.attempt(lb, t, n)(a);
  }
}
function BC(e) {
  e.exit("blockQuote");
}
const ub = {
  name: "characterEscape",
  tokenize: zC
};
function zC(e, t, n) {
  return r;
  function r(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return TC(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(o);
  }
}
const cb = {
  name: "characterReference",
  tokenize: WC
};
function WC(e, t, n) {
  const r = this;
  let i = 0, o, a;
  return s;
  function s(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), o = 31, a = Tt, c(f));
  }
  function u(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, a = $C, c) : (e.enter("characterReferenceValue"), o = 7, a = rc, c(f));
  }
  function c(f) {
    if (f === 59 && i) {
      const p = e.exit("characterReferenceValue");
      return a === Tt && !kf(r.sliceSerialize(p)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return a(f) && i++ < o ? (e.consume(f), c) : n(f);
  }
}
const Gp = {
  tokenize: HC,
  partial: !0
}, Yp = {
  name: "codeFenced",
  tokenize: UC,
  concrete: !0
};
function UC(e, t, n) {
  const r = this, i = {
    tokenize: S,
    partial: !0
  };
  let o = 0, a = 0, s;
  return l;
  function l(E) {
    return u(E);
  }
  function u(E) {
    const I = r.events[r.events.length - 1];
    return o = I && I[1].type === "linePrefix" ? I[2].sliceSerialize(I[1], !0).length : 0, s = E, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(E);
  }
  function c(E) {
    return E === s ? (a++, e.consume(E), c) : a < 3 ? n(E) : (e.exit("codeFencedFenceSequence"), be(E) ? Ce(e, f, "whitespace")(E) : f(E));
  }
  function f(E) {
    return E === null || de(E) ? (e.exit("codeFencedFence"), r.interrupt ? t(E) : e.check(Gp, h, C)(E)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(E));
  }
  function p(E) {
    return E === null || de(E) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(E)) : be(E) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Ce(e, d, "whitespace")(E)) : E === 96 && E === s ? n(E) : (e.consume(E), p);
  }
  function d(E) {
    return E === null || de(E) ? f(E) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), v(E));
  }
  function v(E) {
    return E === null || de(E) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(E)) : E === 96 && E === s ? n(E) : (e.consume(E), v);
  }
  function h(E) {
    return e.attempt(i, C, g)(E);
  }
  function g(E) {
    return e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), m;
  }
  function m(E) {
    return o > 0 && be(E) ? Ce(e, b, "linePrefix", o + 1)(E) : b(E);
  }
  function b(E) {
    return E === null || de(E) ? e.check(Gp, h, C)(E) : (e.enter("codeFlowValue"), w(E));
  }
  function w(E) {
    return E === null || de(E) ? (e.exit("codeFlowValue"), b(E)) : (e.consume(E), w);
  }
  function C(E) {
    return e.exit("codeFenced"), t(E);
  }
  function S(E, I, N) {
    let A = 0;
    return O;
    function O(_) {
      return E.enter("lineEnding"), E.consume(_), E.exit("lineEnding"), D;
    }
    function D(_) {
      return E.enter("codeFencedFence"), be(_) ? Ce(E, U, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(_) : U(_);
    }
    function U(_) {
      return _ === s ? (E.enter("codeFencedFenceSequence"), L(_)) : N(_);
    }
    function L(_) {
      return _ === s ? (A++, E.consume(_), L) : A >= a ? (E.exit("codeFencedFenceSequence"), be(_) ? Ce(E, M, "whitespace")(_) : M(_)) : N(_);
    }
    function M(_) {
      return _ === null || de(_) ? (E.exit("codeFencedFence"), I(_)) : N(_);
    }
  }
}
function HC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return a === null ? n(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o);
  }
  function o(a) {
    return r.parser.lazy[r.now().line] ? n(a) : t(a);
  }
}
const cl = {
  name: "codeIndented",
  tokenize: KC
}, VC = {
  tokenize: qC,
  partial: !0
};
function KC(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), Ce(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? a(u) : n(u);
  }
  function a(u) {
    return u === null ? l(u) : de(u) ? e.attempt(VC, a, l)(u) : (e.enter("codeFlowValue"), s(u));
  }
  function s(u) {
    return u === null || de(u) ? (e.exit("codeFlowValue"), a(u)) : (e.consume(u), s);
  }
  function l(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function qC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return r.parser.lazy[r.now().line] ? n(a) : de(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : Ce(e, o, "linePrefix", 5)(a);
  }
  function o(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : de(a) ? i(a) : n(a);
  }
}
const GC = {
  name: "codeText",
  tokenize: JC,
  resolve: YC,
  previous: XC
};
function YC(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function XC(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function JC(e, t, n) {
  let r = 0, i, o;
  return a;
  function a(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(f);
  }
  function s(f) {
    return f === 96 ? (e.consume(f), r++, s) : (e.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), l) : f === 96 ? (o = e.enter("codeTextSequence"), i = 0, c(f)) : de(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), l) : (e.enter("codeTextData"), u(f));
  }
  function u(f) {
    return f === null || f === 32 || f === 96 || de(f) ? (e.exit("codeTextData"), l(f)) : (e.consume(f), u);
  }
  function c(f) {
    return f === 96 ? (e.consume(f), i++, c) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (o.type = "codeTextData", u(f));
  }
}
class QC {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Ri(this.left, r), o.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Ri(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Ri(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        Ri(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Ri(this.left, n.reverse());
      }
  }
}
function Ri(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function fb(e) {
  const t = {};
  let n = -1, r, i, o, a, s, l, u;
  const c = new QC(e);
  for (; ++n < c.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = c.get(n), n && r[1].type === "chunkFlow" && c.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, o = 0, o < l.length && l[o][1].type === "lineEndingBlank" && (o += 2), o < l.length && l[o][1].type === "content"))
      for (; ++o < l.length && l[o][1].type !== "content"; )
        l[o][1].type === "chunkText" && (l[o][1]._isInFirstContentOfListItem = !0, o++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, ZC(c, n)), n = t[n], u = !0);
    else if (r[1]._container) {
      for (o = n, i = void 0; o-- && (a = c.get(o), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank"); )
        a[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = o);
      i && (r[1].end = Object.assign({}, c.get(i)[1].start), s = c.slice(i, n), s.unshift(r), c.splice(i, n - i + 1, s));
    }
  }
  return Qt(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function ZC(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const o = [], a = n._tokenizer || r.parser[n.contentType](n.start), s = a.events, l = [], u = {};
  let c, f, p = -1, d = n, v = 0, h = 0;
  const g = [h];
  for (; d; ) {
    for (; e.get(++i)[1] !== d; )
      ;
    o.push(i), d._tokenizer || (c = r.sliceStream(d), d.next || c.push(null), f && a.defineSkip(d.start), d._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(c), d._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), f = d, d = d.next;
  }
  for (d = n; ++p < s.length; )
    // Find a void token that includes a break.
    s[p][0] === "exit" && s[p - 1][0] === "enter" && s[p][1].type === s[p - 1][1].type && s[p][1].start.line !== s[p][1].end.line && (h = p + 1, g.push(h), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (a.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : g.pop(), p = g.length; p--; ) {
    const m = s.slice(g[p], g[p + 1]), b = o.pop();
    l.push([b, b + m.length - 1]), e.splice(b, 2, m);
  }
  for (l.reverse(), p = -1; ++p < l.length; )
    u[v + l[p][0]] = v + l[p][1], v += l[p][1] - l[p][0] - 1;
  return u;
}
const e$ = {
  tokenize: r$,
  resolve: n$
}, t$ = {
  tokenize: i$,
  partial: !0
};
function n$(e) {
  return fb(e), e;
}
function r$(e, t) {
  let n;
  return r;
  function r(s) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? o(s) : de(s) ? e.check(t$, a, o)(s) : (e.consume(s), i);
  }
  function o(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function a(s) {
    return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function i$(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Ce(e, o, "linePrefix");
  }
  function o(a) {
    if (a === null || de(a))
      return n(a);
    const s = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(r.parser.constructs.flow, n, t)(a);
  }
}
function db(e, t, n, r, i, o, a, s, l) {
  const u = l || Number.POSITIVE_INFINITY;
  let c = 0;
  return f;
  function f(m) {
    return m === 60 ? (e.enter(r), e.enter(i), e.enter(o), e.consume(m), e.exit(o), p) : m === null || m === 32 || m === 41 || Na(m) ? n(m) : (e.enter(r), e.enter(a), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), h(m));
  }
  function p(m) {
    return m === 62 ? (e.enter(o), e.consume(m), e.exit(o), e.exit(i), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), d(m));
  }
  function d(m) {
    return m === 62 ? (e.exit("chunkString"), e.exit(s), p(m)) : m === null || m === 60 || de(m) ? n(m) : (e.consume(m), m === 92 ? v : d);
  }
  function v(m) {
    return m === 60 || m === 62 || m === 92 ? (e.consume(m), d) : d(m);
  }
  function h(m) {
    return !c && (m === null || m === 41 || Ue(m)) ? (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(r), t(m)) : c < u && m === 40 ? (e.consume(m), c++, h) : m === 41 ? (e.consume(m), c--, h) : m === null || m === 32 || m === 40 || Na(m) ? n(m) : (e.consume(m), m === 92 ? g : h);
  }
  function g(m) {
    return m === 40 || m === 41 || m === 92 ? (e.consume(m), h) : h(m);
  }
}
function pb(e, t, n, r, i, o) {
  const a = this;
  let s = 0, l;
  return u;
  function u(d) {
    return e.enter(r), e.enter(i), e.consume(d), e.exit(i), e.enter(o), c;
  }
  function c(d) {
    return s > 999 || d === null || d === 91 || d === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !s && "_hiddenFootnoteSupport" in a.parser.constructs ? n(d) : d === 93 ? (e.exit(o), e.enter(i), e.consume(d), e.exit(i), e.exit(r), t) : de(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), f(d));
  }
  function f(d) {
    return d === null || d === 91 || d === 93 || de(d) || s++ > 999 ? (e.exit("chunkString"), c(d)) : (e.consume(d), l || (l = !be(d)), d === 92 ? p : f);
  }
  function p(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), s++, f) : f(d);
  }
}
function hb(e, t, n, r, i, o) {
  let a;
  return s;
  function s(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(i), e.consume(p), e.exit(i), a = p === 40 ? 41 : p, l) : n(p);
  }
  function l(p) {
    return p === a ? (e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : (e.enter(o), u(p));
  }
  function u(p) {
    return p === a ? (e.exit(o), l(a)) : p === null ? n(p) : de(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), Ce(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(p));
  }
  function c(p) {
    return p === a || p === null || de(p) ? (e.exit("chunkString"), u(p)) : (e.consume(p), p === 92 ? f : c);
  }
  function f(p) {
    return p === a || p === 92 ? (e.consume(p), c) : c(p);
  }
}
function Vi(e, t) {
  let n;
  return r;
  function r(i) {
    return de(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : be(i) ? Ce(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const o$ = {
  name: "definition",
  tokenize: s$
}, a$ = {
  tokenize: l$,
  partial: !0
};
function s$(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(d) {
    return e.enter("definition"), a(d);
  }
  function a(d) {
    return pb.call(
      r,
      e,
      s,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function s(d) {
    return i = ln(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), d === 58 ? (e.enter("definitionMarker"), e.consume(d), e.exit("definitionMarker"), l) : n(d);
  }
  function l(d) {
    return Ue(d) ? Vi(e, u)(d) : u(d);
  }
  function u(d) {
    return db(
      e,
      c,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function c(d) {
    return e.attempt(a$, f, f)(d);
  }
  function f(d) {
    return be(d) ? Ce(e, p, "whitespace")(d) : p(d);
  }
  function p(d) {
    return d === null || de(d) ? (e.exit("definition"), r.parser.defined.push(i), t(d)) : n(d);
  }
}
function l$(e, t, n) {
  return r;
  function r(s) {
    return Ue(s) ? Vi(e, i)(s) : n(s);
  }
  function i(s) {
    return hb(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
  }
  function o(s) {
    return be(s) ? Ce(e, a, "whitespace")(s) : a(s);
  }
  function a(s) {
    return s === null || de(s) ? t(s) : n(s);
  }
}
const u$ = {
  name: "hardBreakEscape",
  tokenize: c$
};
function c$(e, t, n) {
  return r;
  function r(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return de(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o);
  }
}
const f$ = {
  name: "headingAtx",
  tokenize: p$,
  resolve: d$
};
function d$(e, t) {
  let n = e.length - 2, r = 3, i, o;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, o = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Qt(e, r, n - r + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])), e;
}
function p$(e, t, n) {
  let r = 0;
  return i;
  function i(c) {
    return e.enter("atxHeading"), o(c);
  }
  function o(c) {
    return e.enter("atxHeadingSequence"), a(c);
  }
  function a(c) {
    return c === 35 && r++ < 6 ? (e.consume(c), a) : c === null || Ue(c) ? (e.exit("atxHeadingSequence"), s(c)) : n(c);
  }
  function s(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), l(c)) : c === null || de(c) ? (e.exit("atxHeading"), t(c)) : be(c) ? Ce(e, s, "whitespace")(c) : (e.enter("atxHeadingText"), u(c));
  }
  function l(c) {
    return c === 35 ? (e.consume(c), l) : (e.exit("atxHeadingSequence"), s(c));
  }
  function u(c) {
    return c === null || c === 35 || Ue(c) ? (e.exit("atxHeadingText"), s(c)) : (e.consume(c), u);
  }
}
const h$ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Xp = ["pre", "script", "style", "textarea"], v$ = {
  name: "htmlFlow",
  tokenize: b$,
  resolveTo: y$,
  concrete: !0
}, m$ = {
  tokenize: w$,
  partial: !0
}, g$ = {
  tokenize: x$,
  partial: !0
};
function y$(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function b$(e, t, n) {
  const r = this;
  let i, o, a, s, l;
  return u;
  function u(x) {
    return c(x);
  }
  function c(x) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(x), f;
  }
  function f(x) {
    return x === 33 ? (e.consume(x), p) : x === 47 ? (e.consume(x), o = !0, h) : x === 63 ? (e.consume(x), i = 3, r.interrupt ? t : y) : Dt(x) ? (e.consume(x), a = String.fromCharCode(x), g) : n(x);
  }
  function p(x) {
    return x === 45 ? (e.consume(x), i = 2, d) : x === 91 ? (e.consume(x), i = 5, s = 0, v) : Dt(x) ? (e.consume(x), i = 4, r.interrupt ? t : y) : n(x);
  }
  function d(x) {
    return x === 45 ? (e.consume(x), r.interrupt ? t : y) : n(x);
  }
  function v(x) {
    const F = "CDATA[";
    return x === F.charCodeAt(s++) ? (e.consume(x), s === F.length ? r.interrupt ? t : U : v) : n(x);
  }
  function h(x) {
    return Dt(x) ? (e.consume(x), a = String.fromCharCode(x), g) : n(x);
  }
  function g(x) {
    if (x === null || x === 47 || x === 62 || Ue(x)) {
      const F = x === 47, G = a.toLowerCase();
      return !F && !o && Xp.includes(G) ? (i = 1, r.interrupt ? t(x) : U(x)) : h$.includes(a.toLowerCase()) ? (i = 6, F ? (e.consume(x), m) : r.interrupt ? t(x) : U(x)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(x) : o ? b(x) : w(x));
    }
    return x === 45 || Tt(x) ? (e.consume(x), a += String.fromCharCode(x), g) : n(x);
  }
  function m(x) {
    return x === 62 ? (e.consume(x), r.interrupt ? t : U) : n(x);
  }
  function b(x) {
    return be(x) ? (e.consume(x), b) : O(x);
  }
  function w(x) {
    return x === 47 ? (e.consume(x), O) : x === 58 || x === 95 || Dt(x) ? (e.consume(x), C) : be(x) ? (e.consume(x), w) : O(x);
  }
  function C(x) {
    return x === 45 || x === 46 || x === 58 || x === 95 || Tt(x) ? (e.consume(x), C) : S(x);
  }
  function S(x) {
    return x === 61 ? (e.consume(x), E) : be(x) ? (e.consume(x), S) : w(x);
  }
  function E(x) {
    return x === null || x === 60 || x === 61 || x === 62 || x === 96 ? n(x) : x === 34 || x === 39 ? (e.consume(x), l = x, I) : be(x) ? (e.consume(x), E) : N(x);
  }
  function I(x) {
    return x === l ? (e.consume(x), l = null, A) : x === null || de(x) ? n(x) : (e.consume(x), I);
  }
  function N(x) {
    return x === null || x === 34 || x === 39 || x === 47 || x === 60 || x === 61 || x === 62 || x === 96 || Ue(x) ? S(x) : (e.consume(x), N);
  }
  function A(x) {
    return x === 47 || x === 62 || be(x) ? w(x) : n(x);
  }
  function O(x) {
    return x === 62 ? (e.consume(x), D) : n(x);
  }
  function D(x) {
    return x === null || de(x) ? U(x) : be(x) ? (e.consume(x), D) : n(x);
  }
  function U(x) {
    return x === 45 && i === 2 ? (e.consume(x), z) : x === 60 && i === 1 ? (e.consume(x), q) : x === 62 && i === 4 ? (e.consume(x), T) : x === 63 && i === 3 ? (e.consume(x), y) : x === 93 && i === 5 ? (e.consume(x), P) : de(x) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(m$, j, L)(x)) : x === null || de(x) ? (e.exit("htmlFlowData"), L(x)) : (e.consume(x), U);
  }
  function L(x) {
    return e.check(g$, M, j)(x);
  }
  function M(x) {
    return e.enter("lineEnding"), e.consume(x), e.exit("lineEnding"), _;
  }
  function _(x) {
    return x === null || de(x) ? L(x) : (e.enter("htmlFlowData"), U(x));
  }
  function z(x) {
    return x === 45 ? (e.consume(x), y) : U(x);
  }
  function q(x) {
    return x === 47 ? (e.consume(x), a = "", H) : U(x);
  }
  function H(x) {
    if (x === 62) {
      const F = a.toLowerCase();
      return Xp.includes(F) ? (e.consume(x), T) : U(x);
    }
    return Dt(x) && a.length < 8 ? (e.consume(x), a += String.fromCharCode(x), H) : U(x);
  }
  function P(x) {
    return x === 93 ? (e.consume(x), y) : U(x);
  }
  function y(x) {
    return x === 62 ? (e.consume(x), T) : x === 45 && i === 2 ? (e.consume(x), y) : U(x);
  }
  function T(x) {
    return x === null || de(x) ? (e.exit("htmlFlowData"), j(x)) : (e.consume(x), T);
  }
  function j(x) {
    return e.exit("htmlFlow"), t(x);
  }
}
function x$(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return de(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : n(a);
  }
  function o(a) {
    return r.parser.lazy[r.now().line] ? n(a) : t(a);
  }
}
function w$(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(po, t, n);
  }
}
const S$ = {
  name: "htmlText",
  tokenize: E$
};
function E$(e, t, n) {
  const r = this;
  let i, o, a;
  return s;
  function s(y) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(y), l;
  }
  function l(y) {
    return y === 33 ? (e.consume(y), u) : y === 47 ? (e.consume(y), S) : y === 63 ? (e.consume(y), w) : Dt(y) ? (e.consume(y), N) : n(y);
  }
  function u(y) {
    return y === 45 ? (e.consume(y), c) : y === 91 ? (e.consume(y), o = 0, v) : Dt(y) ? (e.consume(y), b) : n(y);
  }
  function c(y) {
    return y === 45 ? (e.consume(y), d) : n(y);
  }
  function f(y) {
    return y === null ? n(y) : y === 45 ? (e.consume(y), p) : de(y) ? (a = f, q(y)) : (e.consume(y), f);
  }
  function p(y) {
    return y === 45 ? (e.consume(y), d) : f(y);
  }
  function d(y) {
    return y === 62 ? z(y) : y === 45 ? p(y) : f(y);
  }
  function v(y) {
    const T = "CDATA[";
    return y === T.charCodeAt(o++) ? (e.consume(y), o === T.length ? h : v) : n(y);
  }
  function h(y) {
    return y === null ? n(y) : y === 93 ? (e.consume(y), g) : de(y) ? (a = h, q(y)) : (e.consume(y), h);
  }
  function g(y) {
    return y === 93 ? (e.consume(y), m) : h(y);
  }
  function m(y) {
    return y === 62 ? z(y) : y === 93 ? (e.consume(y), m) : h(y);
  }
  function b(y) {
    return y === null || y === 62 ? z(y) : de(y) ? (a = b, q(y)) : (e.consume(y), b);
  }
  function w(y) {
    return y === null ? n(y) : y === 63 ? (e.consume(y), C) : de(y) ? (a = w, q(y)) : (e.consume(y), w);
  }
  function C(y) {
    return y === 62 ? z(y) : w(y);
  }
  function S(y) {
    return Dt(y) ? (e.consume(y), E) : n(y);
  }
  function E(y) {
    return y === 45 || Tt(y) ? (e.consume(y), E) : I(y);
  }
  function I(y) {
    return de(y) ? (a = I, q(y)) : be(y) ? (e.consume(y), I) : z(y);
  }
  function N(y) {
    return y === 45 || Tt(y) ? (e.consume(y), N) : y === 47 || y === 62 || Ue(y) ? A(y) : n(y);
  }
  function A(y) {
    return y === 47 ? (e.consume(y), z) : y === 58 || y === 95 || Dt(y) ? (e.consume(y), O) : de(y) ? (a = A, q(y)) : be(y) ? (e.consume(y), A) : z(y);
  }
  function O(y) {
    return y === 45 || y === 46 || y === 58 || y === 95 || Tt(y) ? (e.consume(y), O) : D(y);
  }
  function D(y) {
    return y === 61 ? (e.consume(y), U) : de(y) ? (a = D, q(y)) : be(y) ? (e.consume(y), D) : A(y);
  }
  function U(y) {
    return y === null || y === 60 || y === 61 || y === 62 || y === 96 ? n(y) : y === 34 || y === 39 ? (e.consume(y), i = y, L) : de(y) ? (a = U, q(y)) : be(y) ? (e.consume(y), U) : (e.consume(y), M);
  }
  function L(y) {
    return y === i ? (e.consume(y), i = void 0, _) : y === null ? n(y) : de(y) ? (a = L, q(y)) : (e.consume(y), L);
  }
  function M(y) {
    return y === null || y === 34 || y === 39 || y === 60 || y === 61 || y === 96 ? n(y) : y === 47 || y === 62 || Ue(y) ? A(y) : (e.consume(y), M);
  }
  function _(y) {
    return y === 47 || y === 62 || Ue(y) ? A(y) : n(y);
  }
  function z(y) {
    return y === 62 ? (e.consume(y), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(y);
  }
  function q(y) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), H;
  }
  function H(y) {
    return be(y) ? Ce(e, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(y) : P(y);
  }
  function P(y) {
    return e.enter("htmlTextData"), a(y);
  }
}
const Cf = {
  name: "labelEnd",
  tokenize: I$,
  resolveTo: O$,
  resolveAll: T$
}, k$ = {
  tokenize: R$
}, C$ = {
  tokenize: P$
}, $$ = {
  tokenize: A$
};
function T$(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function O$(e, t) {
  let n = e.length, r = 0, i, o, a, s;
  for (; n--; )
    if (i = e[n][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (a = n);
  const l = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "label",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[a][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, e[o + r + 2][1].end),
    end: Object.assign({}, e[a - 2][1].start)
  };
  return s = [["enter", l, t], ["enter", u, t]], s = Yt(s, e.slice(o + 1, o + r + 3)), s = Yt(s, [["enter", c, t]]), s = Yt(s, vs(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, a - 3), t)), s = Yt(s, [["exit", c, t], e[a - 2], e[a - 1], ["exit", u, t]]), s = Yt(s, e.slice(a + 1)), s = Yt(s, [["exit", l, t]]), Qt(e, o, e.length, s), e;
}
function I$(e, t, n) {
  const r = this;
  let i = r.events.length, o, a;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return s;
  function s(p) {
    return o ? o._inactive ? f(p) : (a = r.parser.defined.includes(ln(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(p);
  }
  function l(p) {
    return p === 40 ? e.attempt(k$, c, a ? c : f)(p) : p === 91 ? e.attempt(C$, c, a ? u : f)(p) : a ? c(p) : f(p);
  }
  function u(p) {
    return e.attempt($$, c, f)(p);
  }
  function c(p) {
    return t(p);
  }
  function f(p) {
    return o._balanced = !0, n(p);
  }
}
function R$(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), i;
  }
  function i(f) {
    return Ue(f) ? Vi(e, o)(f) : o(f);
  }
  function o(f) {
    return f === 41 ? c(f) : db(e, a, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(f);
  }
  function a(f) {
    return Ue(f) ? Vi(e, l)(f) : c(f);
  }
  function s(f) {
    return n(f);
  }
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? hb(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(f) : c(f);
  }
  function u(f) {
    return Ue(f) ? Vi(e, c)(f) : c(f);
  }
  function c(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function P$(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return pb.call(r, e, o, a, "reference", "referenceMarker", "referenceString")(s);
  }
  function o(s) {
    return r.parser.defined.includes(ln(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s);
  }
  function a(s) {
    return n(s);
  }
}
function A$(e, t, n) {
  return r;
  function r(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : n(o);
  }
}
const D$ = {
  name: "labelStartImage",
  tokenize: _$,
  resolveAll: Cf.resolveAll
};
function _$(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), o;
  }
  function o(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), a) : n(s);
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const M$ = {
  name: "labelStartLink",
  tokenize: j$,
  resolveAll: Cf.resolveAll
};
function j$(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const fl = {
  name: "lineEnding",
  tokenize: N$
};
function N$(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Ce(e, t, "linePrefix");
  }
}
const ba = {
  name: "thematicBreak",
  tokenize: L$
};
function L$(e, t, n) {
  let r = 0, i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), a(u);
  }
  function a(u) {
    return i = u, s(u);
  }
  function s(u) {
    return u === i ? (e.enter("thematicBreakSequence"), l(u)) : r >= 3 && (u === null || de(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
  }
  function l(u) {
    return u === i ? (e.consume(u), r++, l) : (e.exit("thematicBreakSequence"), be(u) ? Ce(e, s, "whitespace")(u) : s(u));
  }
}
const Mt = {
  name: "list",
  tokenize: z$,
  continuation: {
    tokenize: W$
  },
  exit: H$
}, F$ = {
  tokenize: V$,
  partial: !0
}, B$ = {
  tokenize: U$,
  partial: !0
};
function z$(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return s;
  function s(d) {
    const v = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (v === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : rc(d)) {
      if (r.containerState.type || (r.containerState.type = v, e.enter(v, {
        _container: !0
      })), v === "listUnordered")
        return e.enter("listItemPrefix"), d === 42 || d === 45 ? e.check(ba, n, u)(d) : u(d);
      if (!r.interrupt || d === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(d);
    }
    return n(d);
  }
  function l(d) {
    return rc(d) && ++a < 10 ? (e.consume(d), l) : (!r.interrupt || a < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (e.exit("listItemValue"), u(d)) : n(d);
  }
  function u(d) {
    return e.enter("listItemMarker"), e.consume(d), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, e.check(
      po,
      // Can’t be empty when interrupting.
      r.interrupt ? n : c,
      e.attempt(F$, p, f)
    );
  }
  function c(d) {
    return r.containerState.initialBlankLine = !0, o++, p(d);
  }
  function f(d) {
    return be(d) ? (e.enter("listItemPrefixWhitespace"), e.consume(d), e.exit("listItemPrefixWhitespace"), p) : n(d);
  }
  function p(d) {
    return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(d);
  }
}
function W$(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(po, i, o);
  function i(s) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Ce(e, t, "listItemIndent", r.containerState.size + 1)(s);
  }
  function o(s) {
    return r.containerState.furtherBlankLines || !be(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(B$, t, a)(s));
  }
  function a(s) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Ce(e, e.attempt(Mt, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
  }
}
function U$(e, t, n) {
  const r = this;
  return Ce(e, i, "listItemIndent", r.containerState.size + 1);
  function i(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? t(o) : n(o);
  }
}
function H$(e) {
  e.exit(this.containerState.type);
}
function V$(e, t, n) {
  const r = this;
  return Ce(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const a = r.events[r.events.length - 1];
    return !be(o) && a && a[1].type === "listItemPrefixWhitespace" ? t(o) : n(o);
  }
}
const Jp = {
  name: "setextUnderline",
  tokenize: q$,
  resolveTo: K$
};
function K$(e, t) {
  let n = e.length, r, i, o;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n);
  const a = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", a, t]), e.splice(o + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[o][1].end)) : e[r][1] = a, e.push(["exit", a, t]), e;
}
function q$(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(u) {
    let c = r.events.length, f;
    for (; c--; )
      if (r.events[c][1].type !== "lineEnding" && r.events[c][1].type !== "linePrefix" && r.events[c][1].type !== "content") {
        f = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), i = u, a(u)) : n(u);
  }
  function a(u) {
    return e.enter("setextHeadingLineSequence"), s(u);
  }
  function s(u) {
    return u === i ? (e.consume(u), s) : (e.exit("setextHeadingLineSequence"), be(u) ? Ce(e, l, "lineSuffix")(u) : l(u));
  }
  function l(u) {
    return u === null || de(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
  }
}
const G$ = {
  tokenize: Y$
};
function Y$(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    po,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      Ce(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(e$, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const X$ = {
  resolveAll: mb()
}, J$ = vb("string"), Q$ = vb("text");
function vb(e) {
  return {
    tokenize: t,
    resolveAll: mb(
      e === "text" ? Z$ : void 0
    )
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], o = n.attempt(i, a, s);
    return a;
    function a(c) {
      return u(c) ? o(c) : s(c);
    }
    function s(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), l;
    }
    function l(c) {
      return u(c) ? (n.exit("data"), o(c)) : (n.consume(c), l);
    }
    function u(c) {
      if (c === null)
        return !0;
      const f = i[c];
      let p = -1;
      if (f)
        for (; ++p < f.length; ) {
          const d = f[p];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function mb(e) {
  return t;
  function t(n, r) {
    let i = -1, o;
    for (; ++i <= n.length; )
      o === void 0 ? n[i] && n[i][1].type === "data" && (o = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end, n.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(n, r) : n;
  }
}
function Z$(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let o = i.length, a = -1, s = 0, l;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (a = u.length; u.charCodeAt(a - 1) === 32; )
            s++, a--;
          if (a) break;
          a = -1;
        } else if (u === -2)
          l = !0, s++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (s) {
        const u = {
          type: n === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - s,
            offset: r.end.offset - s,
            _index: r.start._index + o,
            _bufferIndex: o ? a : r.start._bufferIndex + a
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, u.start), r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(
          n,
          0,
          ["enter", u, t],
          ["exit", u, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function eT(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, o = [];
  let a = [], s = [];
  const l = {
    consume: b,
    enter: w,
    exit: C,
    attempt: I(S),
    check: I(E),
    interrupt: I(E, {
      interrupt: !0
    })
  }, u = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: d,
    sliceSerialize: p,
    now: v,
    defineSkip: h,
    write: f
  };
  let c = t.tokenize.call(u, l);
  return t.resolveAll && o.push(t), u;
  function f(D) {
    return a = Yt(a, D), g(), a[a.length - 1] !== null ? [] : (N(t, 0), u.events = vs(o, u.events, u), u.events);
  }
  function p(D, U) {
    return nT(d(D), U);
  }
  function d(D) {
    return tT(a, D);
  }
  function v() {
    const { line: D, column: U, offset: L, _index: M, _bufferIndex: _ } = r;
    return {
      line: D,
      column: U,
      offset: L,
      _index: M,
      _bufferIndex: _
    };
  }
  function h(D) {
    i[D.line] = D.column, O();
  }
  function g() {
    let D;
    for (; r._index < a.length; ) {
      const U = a[r._index];
      if (typeof U == "string")
        for (D = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === D && r._bufferIndex < U.length; )
          m(U.charCodeAt(r._bufferIndex));
      else
        m(U);
    }
  }
  function m(D) {
    c = c(D);
  }
  function b(D) {
    de(D) ? (r.line++, r.column = 1, r.offset += D === -3 ? 2 : 1, O()) : D !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === a[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = D;
  }
  function w(D, U) {
    const L = U || {};
    return L.type = D, L.start = v(), u.events.push(["enter", L, u]), s.push(L), L;
  }
  function C(D) {
    const U = s.pop();
    return U.end = v(), u.events.push(["exit", U, u]), U;
  }
  function S(D, U) {
    N(D, U.from);
  }
  function E(D, U) {
    U.restore();
  }
  function I(D, U) {
    return L;
    function L(M, _, z) {
      let q, H, P, y;
      return Array.isArray(M) ? j(M) : "tokenize" in M ? (
        // @ts-expect-error Looks like a construct.
        j([M])
      ) : T(M);
      function T(K) {
        return Y;
        function Y(Q) {
          const Z = Q !== null && K[Q], X = Q !== null && K.null, J = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Z) ? Z : Z ? [Z] : [],
            ...Array.isArray(X) ? X : X ? [X] : []
          ];
          return j(J)(Q);
        }
      }
      function j(K) {
        return q = K, H = 0, K.length === 0 ? z : x(K[H]);
      }
      function x(K) {
        return Y;
        function Y(Q) {
          return y = A(), P = K, K.partial || (u.currentConstruct = K), K.name && u.parser.constructs.disable.null.includes(K.name) ? G() : K.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            U ? Object.assign(Object.create(u), U) : u,
            l,
            F,
            G
          )(Q);
        }
      }
      function F(K) {
        return D(P, y), _;
      }
      function G(K) {
        return y.restore(), ++H < q.length ? x(q[H]) : z;
      }
    }
  }
  function N(D, U) {
    D.resolveAll && !o.includes(D) && o.push(D), D.resolve && Qt(
      u.events,
      U,
      u.events.length - U,
      D.resolve(u.events.slice(U), u)
    ), D.resolveTo && (u.events = D.resolveTo(u.events, u));
  }
  function A() {
    const D = v(), U = u.previous, L = u.currentConstruct, M = u.events.length, _ = Array.from(s);
    return {
      restore: z,
      from: M
    };
    function z() {
      r = D, u.previous = U, u.currentConstruct = L, u.events.length = M, s = _, O();
    }
  }
  function O() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function tT(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let a;
  if (n === i)
    a = [e[n].slice(r, o)];
  else {
    if (a = e.slice(n, i), r > -1) {
      const s = a[0];
      typeof s == "string" ? a[0] = s.slice(r) : a.shift();
    }
    o > 0 && a.push(e[i].slice(0, o));
  }
  return a;
}
function nT(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const o = e[n];
    let a;
    if (typeof o == "string")
      a = o;
    else
      switch (o) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i) continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(o);
      }
    i = o === -2, r.push(a);
  }
  return r.join("");
}
const rT = {
  42: Mt,
  43: Mt,
  45: Mt,
  48: Mt,
  49: Mt,
  50: Mt,
  51: Mt,
  52: Mt,
  53: Mt,
  54: Mt,
  55: Mt,
  56: Mt,
  57: Mt,
  62: lb
}, iT = {
  91: o$
}, oT = {
  [-2]: cl,
  [-1]: cl,
  32: cl
}, aT = {
  35: f$,
  42: ba,
  45: [Jp, ba],
  60: v$,
  61: Jp,
  95: ba,
  96: Yp,
  126: Yp
}, sT = {
  38: cb,
  92: ub
}, lT = {
  [-5]: fl,
  [-4]: fl,
  [-3]: fl,
  33: D$,
  38: cb,
  42: ic,
  60: [MC, S$],
  91: M$,
  92: [u$, ub],
  93: Cf,
  95: ic,
  96: GC
}, uT = {
  null: [ic, X$]
}, cT = {
  null: [42, 95]
}, fT = {
  null: []
}, dT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: cT,
  contentInitial: iT,
  disable: fT,
  document: rT,
  flow: aT,
  flowInitial: oT,
  insideSpan: uT,
  string: sT,
  text: lT
}, Symbol.toStringTag, { value: "Module" }));
function pT(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    ab([dT, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: i(OC),
    document: i(RC),
    flow: i(G$),
    string: i(J$),
    text: i(Q$)
  };
  return r;
  function i(o) {
    return a;
    function a(s) {
      return eT(r, o, s);
    }
  }
}
function hT(e) {
  for (; !fb(e); )
    ;
  return e;
}
const Qp = /[\0\t\n\r]/g;
function vT() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(o, a, s) {
    const l = [];
    let u, c, f, p, d;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)), f = 0, t = "", n && (o.charCodeAt(0) === 65279 && f++, n = void 0); f < o.length; ) {
      if (Qp.lastIndex = f, u = Qp.exec(o), p = u && u.index !== void 0 ? u.index : o.length, d = o.charCodeAt(p), !u) {
        t = o.slice(f);
        break;
      }
      if (d === 10 && f === p && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < p && (l.push(o.slice(f, p)), e += p - f), d) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, l.push(-2); e++ < c; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = p + 1;
    }
    return s && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const mT = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function gT(e) {
  return e.replace(mT, yT);
}
function yT(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), o = i === 120 || i === 88;
    return sb(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return kf(n) || e;
}
const gb = {}.hasOwnProperty;
function bT(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), xT(n)(hT(pT(n).document().write(vT()(e, t, !0))));
}
function xT(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(Ie),
      autolinkProtocol: A,
      autolinkEmail: A,
      atxHeading: o(fe),
      blockQuote: o(X),
      characterEscape: A,
      characterReference: A,
      codeFenced: o(J),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: o(J, a),
      codeText: o(V, a),
      codeTextData: A,
      data: A,
      codeFlowValue: A,
      definition: o(ne),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: o(se),
      hardBreakEscape: o(oe),
      hardBreakTrailing: o(oe),
      htmlFlow: o(pe, a),
      htmlFlowData: A,
      htmlText: o(pe, a),
      htmlTextData: A,
      image: o(Se),
      label: a,
      link: o(Ie),
      listItem: o(St),
      listItemValue: p,
      listOrdered: o(nt, f),
      listUnordered: o(nt),
      paragraph: o(Et),
      reference: x,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: o(fe),
      strong: o(kt),
      thematicBreak: o(ue)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: S,
      autolink: l(),
      autolinkEmail: Z,
      autolinkProtocol: Q,
      blockQuote: l(),
      characterEscapeValue: O,
      characterReferenceMarkerHexadecimal: G,
      characterReferenceMarkerNumeric: G,
      characterReferenceValue: K,
      characterReference: Y,
      codeFenced: l(g),
      codeFencedFence: h,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: v,
      codeFlowValue: O,
      codeIndented: l(m),
      codeText: l(_),
      codeTextData: O,
      data: O,
      definition: l(),
      definitionDestinationString: C,
      definitionLabelString: b,
      definitionTitleString: w,
      emphasis: l(),
      hardBreakEscape: l(U),
      hardBreakTrailing: l(U),
      htmlFlow: l(L),
      htmlFlowData: O,
      htmlText: l(M),
      htmlTextData: O,
      image: l(q),
      label: P,
      labelText: H,
      lineEnding: D,
      link: l(z),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: F,
      resourceDestinationString: y,
      resourceTitleString: T,
      resource: j,
      setextHeading: l(N),
      setextHeadingLineSequence: I,
      setextHeadingText: E,
      strong: l(),
      thematicBreak: l()
    }
  };
  yb(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(W) {
    let B = {
      type: "root",
      children: []
    };
    const te = {
      stack: [B],
      tokenStack: [],
      config: t,
      enter: s,
      exit: u,
      buffer: a,
      resume: c,
      data: n
    }, ae = [];
    let ce = -1;
    for (; ++ce < W.length; )
      if (W[ce][1].type === "listOrdered" || W[ce][1].type === "listUnordered")
        if (W[ce][0] === "enter")
          ae.push(ce);
        else {
          const ve = ae.pop();
          ce = i(W, ve, ce);
        }
    for (ce = -1; ++ce < W.length; ) {
      const ve = t[W[ce][0]];
      gb.call(ve, W[ce][1].type) && ve[W[ce][1].type].call(Object.assign({
        sliceSerialize: W[ce][2].sliceSerialize
      }, te), W[ce][1]);
    }
    if (te.tokenStack.length > 0) {
      const ve = te.tokenStack[te.tokenStack.length - 1];
      (ve[1] || Zp).call(te, void 0, ve[0]);
    }
    for (B.position = {
      start: zn(W.length > 0 ? W[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: zn(W.length > 0 ? W[W.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, ce = -1; ++ce < t.transforms.length; )
      B = t.transforms[ce](B) || B;
    return B;
  }
  function i(W, B, te) {
    let ae = B - 1, ce = -1, ve = !1, qe, Ge, gt, rt;
    for (; ++ae <= te; ) {
      const Re = W[ae];
      switch (Re[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Re[0] === "enter" ? ce++ : ce--, rt = void 0;
          break;
        }
        case "lineEndingBlank": {
          Re[0] === "enter" && (qe && !rt && !ce && !gt && (gt = ae), rt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          rt = void 0;
      }
      if (!ce && Re[0] === "enter" && Re[1].type === "listItemPrefix" || ce === -1 && Re[0] === "exit" && (Re[1].type === "listUnordered" || Re[1].type === "listOrdered")) {
        if (qe) {
          let it = ae;
          for (Ge = void 0; it--; ) {
            const Ze = W[it];
            if (Ze[1].type === "lineEnding" || Ze[1].type === "lineEndingBlank") {
              if (Ze[0] === "exit") continue;
              Ge && (W[Ge][1].type = "lineEndingBlank", ve = !0), Ze[1].type = "lineEnding", Ge = it;
            } else if (!(Ze[1].type === "linePrefix" || Ze[1].type === "blockQuotePrefix" || Ze[1].type === "blockQuotePrefixWhitespace" || Ze[1].type === "blockQuoteMarker" || Ze[1].type === "listItemIndent")) break;
          }
          gt && (!Ge || gt < Ge) && (qe._spread = !0), qe.end = Object.assign({}, Ge ? W[Ge][1].start : Re[1].end), W.splice(Ge || ae, 0, ["exit", qe, Re[2]]), ae++, te++;
        }
        if (Re[1].type === "listItemPrefix") {
          const it = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Re[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          qe = it, W.splice(ae, 0, ["enter", it, Re[2]]), ae++, te++, gt = void 0, rt = !0;
        }
      }
    }
    return W[B][1]._spread = ve, te;
  }
  function o(W, B) {
    return te;
    function te(ae) {
      s.call(this, W(ae), ae), B && B.call(this, ae);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(W, B, te) {
    this.stack[this.stack.length - 1].children.push(W), this.stack.push(W), this.tokenStack.push([B, te]), W.position = {
      start: zn(B.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(W) {
    return B;
    function B(te) {
      W && W.call(this, te), u.call(this, te);
    }
  }
  function u(W, B) {
    const te = this.stack.pop(), ae = this.tokenStack.pop();
    if (ae)
      ae[0].type !== W.type && (B ? B.call(this, W, ae[0]) : (ae[1] || Zp).call(this, W, ae[0]));
    else throw new Error("Cannot close `" + W.type + "` (" + Hi({
      start: W.start,
      end: W.end
    }) + "): it’s not open");
    te.position.end = zn(W.end);
  }
  function c() {
    return Ef(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(W) {
    if (this.data.expectingFirstListItemValue) {
      const B = this.stack[this.stack.length - 2];
      B.start = Number.parseInt(this.sliceSerialize(W), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.lang = W;
  }
  function v() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.meta = W;
  }
  function h() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = W.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function m() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = W.replace(/(\r?\n|\r)$/g, "");
  }
  function b(W) {
    const B = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = B, te.identifier = ln(this.sliceSerialize(W)).toLowerCase();
  }
  function w() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.title = W;
  }
  function C() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.url = W;
  }
  function S(W) {
    const B = this.stack[this.stack.length - 1];
    if (!B.depth) {
      const te = this.sliceSerialize(W).length;
      B.depth = te;
    }
  }
  function E() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function I(W) {
    const B = this.stack[this.stack.length - 1];
    B.depth = this.sliceSerialize(W).codePointAt(0) === 61 ? 1 : 2;
  }
  function N() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function A(W) {
    const te = this.stack[this.stack.length - 1].children;
    let ae = te[te.length - 1];
    (!ae || ae.type !== "text") && (ae = ie(), ae.position = {
      start: zn(W.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, te.push(ae)), this.stack.push(ae);
  }
  function O(W) {
    const B = this.stack.pop();
    B.value += this.sliceSerialize(W), B.position.end = zn(W.end);
  }
  function D(W) {
    const B = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const te = B.children[B.children.length - 1];
      te.position.end = zn(W.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(B.type) && (A.call(this, W), O.call(this, W));
  }
  function U() {
    this.data.atHardBreak = !0;
  }
  function L() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = W;
  }
  function M() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = W;
  }
  function _() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.value = W;
  }
  function z() {
    const W = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const B = this.data.referenceType || "shortcut";
      W.type += "Reference", W.referenceType = B, delete W.url, delete W.title;
    } else
      delete W.identifier, delete W.label;
    this.data.referenceType = void 0;
  }
  function q() {
    const W = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const B = this.data.referenceType || "shortcut";
      W.type += "Reference", W.referenceType = B, delete W.url, delete W.title;
    } else
      delete W.identifier, delete W.label;
    this.data.referenceType = void 0;
  }
  function H(W) {
    const B = this.sliceSerialize(W), te = this.stack[this.stack.length - 2];
    te.label = gT(B), te.identifier = ln(B).toLowerCase();
  }
  function P() {
    const W = this.stack[this.stack.length - 1], B = this.resume(), te = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, te.type === "link") {
      const ae = W.children;
      te.children = ae;
    } else
      te.alt = B;
  }
  function y() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.url = W;
  }
  function T() {
    const W = this.resume(), B = this.stack[this.stack.length - 1];
    B.title = W;
  }
  function j() {
    this.data.inReference = void 0;
  }
  function x() {
    this.data.referenceType = "collapsed";
  }
  function F(W) {
    const B = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = B, te.identifier = ln(this.sliceSerialize(W)).toLowerCase(), this.data.referenceType = "full";
  }
  function G(W) {
    this.data.characterReferenceType = W.type;
  }
  function K(W) {
    const B = this.sliceSerialize(W), te = this.data.characterReferenceType;
    let ae;
    te ? (ae = sb(B, te === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : ae = kf(B);
    const ce = this.stack[this.stack.length - 1];
    ce.value += ae;
  }
  function Y(W) {
    const B = this.stack.pop();
    B.position.end = zn(W.end);
  }
  function Q(W) {
    O.call(this, W);
    const B = this.stack[this.stack.length - 1];
    B.url = this.sliceSerialize(W);
  }
  function Z(W) {
    O.call(this, W);
    const B = this.stack[this.stack.length - 1];
    B.url = "mailto:" + this.sliceSerialize(W);
  }
  function X() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function J() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function V() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function ne() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function se() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function fe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function oe() {
    return {
      type: "break"
    };
  }
  function pe() {
    return {
      type: "html",
      value: ""
    };
  }
  function Se() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Ie() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function nt(W) {
    return {
      type: "list",
      ordered: W.type === "listOrdered",
      start: null,
      spread: W._spread,
      children: []
    };
  }
  function St(W) {
    return {
      type: "listItem",
      spread: W._spread,
      checked: null,
      children: []
    };
  }
  function Et() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function kt() {
    return {
      type: "strong",
      children: []
    };
  }
  function ie() {
    return {
      type: "text",
      value: ""
    };
  }
  function ue() {
    return {
      type: "thematicBreak"
    };
  }
}
function zn(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function yb(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? yb(e, r) : wT(e, r);
  }
}
function wT(e, t) {
  let n;
  for (n in t)
    if (gb.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Zp(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Hi({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Hi({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Hi({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function ST(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return bT(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function ET(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function kT(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function CT(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function $T(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function TT(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function OT(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = pi(r.toLowerCase()), o = e.footnoteOrder.indexOf(r);
  let a, s = e.footnoteCounts.get(r);
  s === void 0 ? (s = 0, e.footnoteOrder.push(r), a = e.footnoteOrder.length) : a = o + 1, s += 1, e.footnoteCounts.set(r, s);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  e.patch(t, l);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function IT(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function RT(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function bb(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const a = i[i.length - 1];
  return a && a.type === "text" ? a.value += r : i.push({ type: "text", value: r }), i;
}
function PT(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return bb(e, t);
  const i = { src: pi(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function AT(e, t) {
  const n = { src: pi(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function DT(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function _T(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return bb(e, t);
  const i = { href: pi(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function MT(e, t) {
  const n = { href: pi(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function jT(e, t, n) {
  const r = e.all(t), i = n ? NT(n) : xb(t), o = {}, a = [];
  if (typeof t.checked == "boolean") {
    const c = r[0];
    let f;
    c && c.type === "element" && c.tagName === "p" ? f = c : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < r.length; ) {
    const c = r[s];
    (i || s !== 0 || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? a.push(...c.children) : a.push(c);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && a.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: o, children: a };
  return e.patch(t, u), e.applyData(t, u);
}
function NT(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = xb(n[r]);
  }
  return t;
}
function xb(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function LT(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const a = r[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function FT(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function BT(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function zT(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function WT(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], a), i.push(a);
  }
  if (n.length > 0) {
    const a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, s = bf(t.children[1]), l = Zy(t.children[t.children.length - 1]);
    s && l && (a.position = { start: s, end: l }), i.push(a);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function UT(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, s = a ? a.length : t.children.length;
  let l = -1;
  const u = [];
  for (; ++l < s; ) {
    const f = t.children[l], p = {}, d = a ? a[l] : void 0;
    d && (p.align = d);
    let v = { type: "element", tagName: o, properties: p, children: [] };
    f && (v.children = e.all(f), e.patch(f, v), v = e.applyData(f, v)), u.push(v);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function HT(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const eh = 9, th = 32;
function VT(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const o = [];
  for (; r; )
    o.push(
      nh(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return o.push(nh(t.slice(i), i > 0, !1)), o.join("");
}
function nh(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(r);
    for (; o === eh || o === th; )
      r++, o = e.codePointAt(r);
  }
  if (n) {
    let o = e.codePointAt(i - 1);
    for (; o === eh || o === th; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function KT(e, t) {
  const n = { type: "text", value: VT(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function qT(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const GT = {
  blockquote: ET,
  break: kT,
  code: CT,
  delete: $T,
  emphasis: TT,
  footnoteReference: OT,
  heading: IT,
  html: RT,
  imageReference: PT,
  image: AT,
  inlineCode: DT,
  linkReference: _T,
  link: MT,
  listItem: jT,
  list: LT,
  paragraph: FT,
  // @ts-expect-error: root is different, but hard to type.
  root: BT,
  strong: zT,
  table: WT,
  tableCell: HT,
  tableRow: UT,
  text: KT,
  thematicBreak: qT,
  toml: Wo,
  yaml: Wo,
  definition: Wo,
  footnoteDefinition: Wo
};
function Wo() {
}
const wb = -1, ms = 0, Fa = 1, Ba = 2, $f = 3, Tf = 4, Of = 5, If = 6, Sb = 7, Eb = 8, rh = typeof self == "object" ? self : globalThis, YT = (e, t) => {
  const n = (i, o) => (e.set(o, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, a] = t[i];
    switch (o) {
      case ms:
      case wb:
        return n(a, i);
      case Fa: {
        const s = n([], i);
        for (const l of a)
          s.push(r(l));
        return s;
      }
      case Ba: {
        const s = n({}, i);
        for (const [l, u] of a)
          s[r(l)] = r(u);
        return s;
      }
      case $f:
        return n(new Date(a), i);
      case Tf: {
        const { source: s, flags: l } = a;
        return n(new RegExp(s, l), i);
      }
      case Of: {
        const s = n(/* @__PURE__ */ new Map(), i);
        for (const [l, u] of a)
          s.set(r(l), r(u));
        return s;
      }
      case If: {
        const s = n(/* @__PURE__ */ new Set(), i);
        for (const l of a)
          s.add(r(l));
        return s;
      }
      case Sb: {
        const { name: s, message: l } = a;
        return n(new rh[s](l), i);
      }
      case Eb:
        return n(BigInt(a), i);
      case "BigInt":
        return n(Object(BigInt(a)), i);
    }
    return n(new rh[o](a), i);
  };
  return r;
}, ih = (e) => YT(/* @__PURE__ */ new Map(), e)(0), Or = "", { toString: XT } = {}, { keys: JT } = Object, Pi = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [ms, t];
  const n = XT.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Fa, Or];
    case "Object":
      return [Ba, Or];
    case "Date":
      return [$f, Or];
    case "RegExp":
      return [Tf, Or];
    case "Map":
      return [Of, Or];
    case "Set":
      return [If, Or];
  }
  return n.includes("Array") ? [Fa, n] : n.includes("Error") ? [Sb, n] : [Ba, n];
}, Uo = ([e, t]) => e === ms && (t === "function" || t === "symbol"), QT = (e, t, n, r) => {
  const i = (a, s) => {
    const l = r.push(a) - 1;
    return n.set(s, l), l;
  }, o = (a) => {
    if (n.has(a))
      return n.get(a);
    let [s, l] = Pi(a);
    switch (s) {
      case ms: {
        let c = a;
        switch (l) {
          case "bigint":
            s = Eb, c = a.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            c = null;
            break;
          case "undefined":
            return i([wb], a);
        }
        return i([s, c], a);
      }
      case Fa: {
        if (l)
          return i([l, [...a]], a);
        const c = [], f = i([s, c], a);
        for (const p of a)
          c.push(o(p));
        return f;
      }
      case Ba: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, a.toString()], a);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, a.valueOf()], a);
          }
        if (t && "toJSON" in a)
          return o(a.toJSON());
        const c = [], f = i([s, c], a);
        for (const p of JT(a))
          (e || !Uo(Pi(a[p]))) && c.push([o(p), o(a[p])]);
        return f;
      }
      case $f:
        return i([s, a.toISOString()], a);
      case Tf: {
        const { source: c, flags: f } = a;
        return i([s, { source: c, flags: f }], a);
      }
      case Of: {
        const c = [], f = i([s, c], a);
        for (const [p, d] of a)
          (e || !(Uo(Pi(p)) || Uo(Pi(d)))) && c.push([o(p), o(d)]);
        return f;
      }
      case If: {
        const c = [], f = i([s, c], a);
        for (const p of a)
          (e || !Uo(Pi(p))) && c.push(o(p));
        return f;
      }
    }
    const { message: u } = a;
    return i([s, { name: l, message: u }], a);
  };
  return o;
}, oh = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return QT(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, za = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? ih(oh(e, t)) : structuredClone(e)
) : (e, t) => ih(oh(e, t));
function ZT(e, t) {
  const n = [{ type: "text", value: "↩" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function eO(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function tO(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || ZT, r = e.options.footnoteBackLabel || eO, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!u)
      continue;
    const c = e.all(u), f = String(u.identifier).toUpperCase(), p = pi(f.toLowerCase());
    let d = 0;
    const v = [], h = e.footnoteCounts.get(f);
    for (; h !== void 0 && ++d <= h; ) {
      v.length > 0 && v.push({ type: "text", value: " " });
      let b = typeof n == "string" ? n : n(l, d);
      typeof b == "string" && (b = { type: "text", value: b }), v.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (d > 1 ? "-" + d : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, d),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(b) ? b : [b]
      });
    }
    const g = c[c.length - 1];
    if (g && g.type === "element" && g.tagName === "p") {
      const b = g.children[g.children.length - 1];
      b && b.type === "text" ? b.value += " " : g.children.push({ type: "text", value: " " }), g.children.push(...v);
    } else
      c.push(...v);
    const m = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(c, !0)
    };
    e.patch(u, m), s.push(m);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...za(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const gs = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return oO;
    if (typeof e == "function")
      return ys(e);
    if (typeof e == "object")
      return Array.isArray(e) ? nO(e) : rO(e);
    if (typeof e == "string")
      return iO(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function nO(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = gs(e[n]);
  return ys(r);
  function r(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function rO(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return ys(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let o;
    for (o in e)
      if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function iO(e) {
  return ys(t);
  function t(n) {
    return n && n.type === e;
  }
}
function ys(e) {
  return t;
  function t(n, r, i) {
    return !!(aO(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function oO() {
  return !0;
}
function aO(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const kb = [], sO = !0, oc = !1, lO = "skip";
function Cb(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const o = gs(i), a = r ? -1 : 1;
  s(e, void 0, [])();
  function s(l, u, c) {
    const f = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof f.type == "string") {
      const d = (
        // `hast`
        typeof f.tagName == "string" ? f.tagName : (
          // `xast`
          typeof f.name == "string" ? f.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (l.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let d = kb, v, h, g;
      if ((!t || o(l, u, c[c.length - 1] || void 0)) && (d = uO(n(l, c)), d[0] === oc))
        return d;
      if ("children" in l && l.children) {
        const m = (
          /** @type {UnistParent} */
          l
        );
        if (m.children && d[0] !== lO)
          for (h = (r ? m.children.length : -1) + a, g = c.concat(m); h > -1 && h < m.children.length; ) {
            const b = m.children[h];
            if (v = s(b, h, g)(), v[0] === oc)
              return v;
            h = typeof v[1] == "number" ? v[1] : h + a;
          }
      }
      return d;
    }
  }
}
function uO(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [sO, e] : e == null ? kb : [e];
}
function Rf(e, t, n, r) {
  let i, o, a;
  typeof t == "function" && typeof n != "function" ? (o = void 0, a = t, i = n) : (o = t, a = n, i = r), Cb(e, o, s, i);
  function s(l, u) {
    const c = u[u.length - 1], f = c ? c.children.indexOf(l) : void 0;
    return a(l, f, c);
  }
}
const ac = {}.hasOwnProperty, cO = {};
function fO(e, t) {
  const n = t || cO, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = { ...GT, ...n.handlers }, s = {
    all: u,
    applyData: pO,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: a,
    one: l,
    options: n,
    patch: dO,
    wrap: vO
  };
  return Rf(e, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const f = c.type === "definition" ? r : i, p = String(c.identifier).toUpperCase();
      f.has(p) || f.set(p, c);
    }
  }), s;
  function l(c, f) {
    const p = c.type, d = s.handlers[p];
    if (ac.call(s.handlers, p) && d)
      return d(s, c, f);
    if (s.options.passThrough && s.options.passThrough.includes(p)) {
      if ("children" in c) {
        const { children: h, ...g } = c, m = za(g);
        return m.children = s.all(c), m;
      }
      return za(c);
    }
    return (s.options.unknownHandler || hO)(s, c, f);
  }
  function u(c) {
    const f = [];
    if ("children" in c) {
      const p = c.children;
      let d = -1;
      for (; ++d < p.length; ) {
        const v = s.one(p[d], c);
        if (v) {
          if (d && p[d - 1].type === "break" && (!Array.isArray(v) && v.type === "text" && (v.value = ah(v.value)), !Array.isArray(v) && v.type === "element")) {
            const h = v.children[0];
            h && h.type === "text" && (h.value = ah(h.value));
          }
          Array.isArray(v) ? f.push(...v) : f.push(v);
        }
      }
    }
    return f;
  }
}
function dO(e, t) {
  e.position && (t.position = Qk(e));
}
function pO(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const a = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: a };
      }
    n.type === "element" && o && Object.assign(n.properties, za(o)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function hO(e, t) {
  const n = t.data || {}, r = "value" in t && !(ac.call(n, "hProperties") || ac.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function vO(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function ah(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function sh(e, t) {
  const n = fO(e, t), r = n.one(e, void 0), i = tO(n), o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function mO(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      sh(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      sh(n, { file: r, ...e || t })
    );
  };
}
function lh(e) {
  if (e)
    throw e;
}
var xa = Object.prototype.hasOwnProperty, $b = Object.prototype.toString, uh = Object.defineProperty, ch = Object.getOwnPropertyDescriptor, fh = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : $b.call(t) === "[object Array]";
}, dh = function(t) {
  if (!t || $b.call(t) !== "[object Object]")
    return !1;
  var n = xa.call(t, "constructor"), r = t.constructor && t.constructor.prototype && xa.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || xa.call(t, i);
}, ph = function(t, n) {
  uh && n.name === "__proto__" ? uh(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, hh = function(t, n) {
  if (n === "__proto__")
    if (xa.call(t, n)) {
      if (ch)
        return ch(t, n).value;
    } else return;
  return t[n];
}, gO = function e() {
  var t, n, r, i, o, a, s = arguments[0], l = 1, u = arguments.length, c = !1;
  for (typeof s == "boolean" && (c = s, s = arguments[1] || {}, l = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); l < u; ++l)
    if (t = arguments[l], t != null)
      for (n in t)
        r = hh(s, n), i = hh(t, n), s !== i && (c && i && (dh(i) || (o = fh(i))) ? (o ? (o = !1, a = r && fh(r) ? r : []) : a = r && dh(r) ? r : {}, ph(s, { name: n, newValue: e(c, a, i) })) : typeof i < "u" && ph(s, { name: n, newValue: i }));
  return s;
};
const dl = /* @__PURE__ */ $e(gO);
function sc(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function yO() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let o = -1;
    const a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    s(null, ...i);
    function s(l, ...u) {
      const c = e[++o];
      let f = -1;
      if (l) {
        a(l);
        return;
      }
      for (; ++f < i.length; )
        (u[f] === null || u[f] === void 0) && (u[f] = i[f]);
      i = u, c ? bO(c, s)(...u) : a(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function bO(e, t) {
  let n;
  return r;
  function r(...a) {
    const s = e.length > a.length;
    let l;
    s && a.push(i);
    try {
      l = e.apply(this, a);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (s && n)
        throw c;
      return i(c);
    }
    s || (l && l.then && typeof l.then == "function" ? l.then(o, i) : l instanceof Error ? i(l) : o(l));
  }
  function i(a, ...s) {
    n || (n = !0, t(a, ...s));
  }
  function o(a) {
    i(null, a);
  }
}
const yn = { basename: xO, dirname: wO, extname: SO, join: EO, sep: "/" };
function xO(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  ho(e);
  let n = 0, r = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          n = i + 1;
          break;
        }
      } else r < 0 && (o = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let a = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        n = i + 1;
        break;
      }
    } else
      a < 0 && (o = !0, a = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : (s = -1, r = a));
  return n === r ? r = a : r < 0 && (r = e.length), e.slice(n, r);
}
function wO(e) {
  if (ho(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function SO(e) {
  ho(e);
  let t = e.length, n = -1, r = 0, i = -1, o = 0, a;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (a) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (a = !0, n = t + 1), s === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function EO(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    ho(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : kO(n);
}
function kO(e) {
  ho(e);
  const t = e.codePointAt(0) === 47;
  let n = CO(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function CO(e, t) {
  let n = "", r = 0, i = -1, o = 0, a = -1, s, l;
  for (; ++a <= e.length; ) {
    if (a < e.length)
      s = e.codePointAt(a);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === a - 1 || o === 1)) if (i !== a - 1 && o === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = a, o = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = a, o = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, a) : n = e.slice(i + 1, a), r = a - i - 1;
      i = a, o = 0;
    } else s === 46 && o > -1 ? o++ : o = -1;
  }
  return n;
}
function ho(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const $O = { cwd: TO };
function TO() {
  return "/";
}
function lc(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function OO(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!lc(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return IO(e);
}
function IO(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const pl = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Tb {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? lc(t) ? n = { path: t } : typeof t == "string" || RO(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : $O.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < pl.length; ) {
      const o = pl[r];
      o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o]);
    }
    let i;
    for (i in n)
      pl.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? yn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    vl(t, "basename"), hl(t, "basename"), this.path = yn.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? yn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    vh(this.basename, "dirname"), this.path = yn.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? yn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (hl(t, "extname"), vh(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = yn.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    lc(t) && (t = OO(t)), vl(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? yn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    vl(t, "stem"), hl(t, "stem"), this.path = yn.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new It(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function hl(e, t) {
  if (e && e.includes(yn.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + yn.sep + "`"
    );
}
function vl(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function vh(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function RO(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const PO = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], o = function() {
      return i.apply(o, arguments);
    };
    return Object.setPrototypeOf(o, r), o;
  }
), AO = {}.hasOwnProperty;
class Pf extends PO {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = yO();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Pf()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(dl(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (yl("data", this.frozen), this.namespace[t] = n, this) : AO.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (yl("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Ho(t), r = this.parser || this.Parser;
    return ml("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), ml("process", this.parser || this.Parser), gl("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(o, a) {
      const s = Ho(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(s)
      );
      r.run(l, s, function(c, f, p) {
        if (c || !f || !p)
          return u(c);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), v = r.stringify(d, p);
        MO(v) ? p.value = v : p.result = v, u(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function u(c, f) {
        c || !f ? a(c) : o ? o(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), ml("processSync", this.parser || this.Parser), gl("processSync", this.compiler || this.Compiler), this.process(t, i), gh("processSync", "process", n), r;
    function i(o, a) {
      n = !0, lh(o), r = a;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    mh(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? o(void 0, r) : new Promise(o);
    function o(a, s) {
      const l = Ho(n);
      i.run(t, l, u);
      function u(c, f, p) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        c ? s(c) : a ? a(d) : r(void 0, d, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, o), gh("runSync", "run", r), i;
    function o(a, s) {
      lh(a), i = s, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Ho(n), i = this.compiler || this.Compiler;
    return gl("stringify", i), mh(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (yl("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? s(t) : a(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(u) {
      if (typeof u == "function")
        l(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [c, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          l(c, f);
        } else
          a(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function a(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(u.plugins), u.settings && (i.settings = dl(!0, i.settings, u.settings));
    }
    function s(u) {
      let c = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++c < u.length; ) {
          const f = u[c];
          o(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function l(u, c) {
      let f = -1, p = -1;
      for (; ++f < r.length; )
        if (r[f][0] === u) {
          p = f;
          break;
        }
      if (p === -1)
        r.push([u, ...c]);
      else if (c.length > 0) {
        let [d, ...v] = c;
        const h = r[p][1];
        sc(h) && sc(d) && (d = dl(!0, h, d)), r[p] = [u, d, ...v];
      }
    }
  }
}
const DO = new Pf().freeze();
function ml(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function gl(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function yl(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function mh(e) {
  if (!sc(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function gh(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Ho(e) {
  return _O(e) ? e : new Tb(e);
}
function _O(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function MO(e) {
  return typeof e == "string" || jO(e);
}
function jO(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const NO = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", yh = [], bh = { allowDangerousHtml: !0 }, LO = /^(https?|ircs?|mailto|xmpp)$/i, FO = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Ob(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, o = e.components, a = e.disallowedElements, s = e.rehypePlugins || yh, l = e.remarkPlugins || yh, u = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...bh } : bh, c = e.skipHtml, f = e.unwrapDisallowed, p = e.urlTransform || Ib, d = DO().use(ST).use(l).use(mO, u).use(s), v = new Tb();
  typeof r == "string" && (v.value = r);
  for (const b of FO)
    Object.hasOwn(e, b.from) && ("" + b.from + (b.to ? "use `" + b.to + "` instead" : "remove it") + NO + b.id, void 0);
  const h = d.parse(v);
  let g = d.runSync(h, v);
  return i && (g = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      g.type === "root" ? g.children : [g]
    )
  }), Rf(g, m), iC(g, {
    Fragment: $.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: $.jsx,
    jsxs: $.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function m(b, w, C) {
    if (b.type === "raw" && C && typeof w == "number")
      return c ? C.children.splice(w, 1) : C.children[w] = { type: "text", value: b.value }, w;
    if (b.type === "element") {
      let S;
      for (S in ul)
        if (Object.hasOwn(ul, S) && Object.hasOwn(b.properties, S)) {
          const E = b.properties[S], I = ul[S];
          (I === null || I.includes(b.tagName)) && (b.properties[S] = p(String(E || ""), S, b));
        }
    }
    if (b.type === "element") {
      let S = t ? !t.includes(b.tagName) : a ? a.includes(b.tagName) : !1;
      if (!S && n && typeof w == "number" && (S = !n(b, w, C)), S && C && typeof w == "number")
        return f && b.children ? C.children.splice(w, 1, ...b.children) : C.children.splice(w, 1), w;
    }
  }
}
function Ib(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    i > -1 && t > i || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    LO.test(e.slice(0, t)) ? e : ""
  );
}
function BO(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Rb(e, t, n) {
  const i = gs((n || {}).ignore || []), o = zO(t);
  let a = -1;
  for (; ++a < o.length; )
    Cb(e, "text", s);
  function s(u, c) {
    let f = -1, p;
    for (; ++f < c.length; ) {
      const d = c[f], v = p ? p.children : void 0;
      if (i(
        d,
        v ? v.indexOf(d) : void 0,
        p
      ))
        return;
      p = d;
    }
    if (p)
      return l(u, c);
  }
  function l(u, c) {
    const f = c[c.length - 1], p = o[a][0], d = o[a][1];
    let v = 0;
    const g = f.children.indexOf(u);
    let m = !1, b = [];
    p.lastIndex = 0;
    let w = p.exec(u.value);
    for (; w; ) {
      const C = w.index, S = {
        index: w.index,
        input: w.input,
        stack: [...c, u]
      };
      let E = d(...w, S);
      if (typeof E == "string" && (E = E.length > 0 ? { type: "text", value: E } : void 0), E === !1 ? p.lastIndex = C + 1 : (v !== C && b.push({
        type: "text",
        value: u.value.slice(v, C)
      }), Array.isArray(E) ? b.push(...E) : E && b.push(E), v = C + w[0].length, m = !0), !p.global)
        break;
      w = p.exec(u.value);
    }
    return m ? (v < u.value.length && b.push({ type: "text", value: u.value.slice(v) }), f.children.splice(g, 1, ...b)) : b = [u], g + b.length;
  }
}
function zO(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([WO(i[0]), UO(i[1])]);
  }
  return t;
}
function WO(e) {
  return typeof e == "string" ? new RegExp(BO(e), "g") : e;
}
function UO(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
function HO(e) {
  Rb(e, [/\r?\n|\r/g, VO]);
}
function VO() {
  return { type: "break" };
}
function KO() {
  return function(e) {
    HO(e);
  };
}
function xh(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
const bl = "phrasing", xl = ["autolink", "link", "image", "label"];
function qO() {
  return {
    transforms: [eI],
    enter: {
      literalAutolink: YO,
      literalAutolinkEmail: wl,
      literalAutolinkHttp: wl,
      literalAutolinkWww: wl
    },
    exit: {
      literalAutolink: ZO,
      literalAutolinkEmail: QO,
      literalAutolinkHttp: XO,
      literalAutolinkWww: JO
    }
  };
}
function GO() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: bl,
        notInConstruct: xl
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: bl,
        notInConstruct: xl
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: bl,
        notInConstruct: xl
      }
    ]
  };
}
function YO(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function wl(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function XO(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function JO(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function QO(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function ZO(e) {
  this.exit(e);
}
function eI(e) {
  Rb(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, tI],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), nI]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function tI(e, t, n, r, i) {
  let o = "";
  if (!Pb(i) || (/^w/i.test(t) && (n = t + n, t = "", o = "http://"), !rI(n)))
    return !1;
  const a = iI(n + r);
  if (!a[0]) return !1;
  const s = {
    type: "link",
    title: null,
    url: o + t + a[0],
    children: [{ type: "text", value: t + a[0] }]
  };
  return a[1] ? [s, { type: "text", value: a[1] }] : s;
}
function nI(e, t, n, r) {
  return (
    // Not an expected previous character.
    !Pb(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function rI(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function iI(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = xh(e, "(");
  let o = xh(e, ")");
  for (; r !== -1 && i > o; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), o++;
  return [e, n];
}
function Pb(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || gr(n) || hs(n)) && // If it’s an email, the previous character should not be a slash.
  (!t || n !== 47);
}
Ab.peek = vI;
function oI() {
  return {
    enter: {
      gfmFootnoteDefinition: sI,
      gfmFootnoteDefinitionLabelString: lI,
      gfmFootnoteCall: fI,
      gfmFootnoteCallString: dI
    },
    exit: {
      gfmFootnoteDefinition: cI,
      gfmFootnoteDefinitionLabelString: uI,
      gfmFootnoteCall: hI,
      gfmFootnoteCallString: pI
    }
  };
}
function aI() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: mI, footnoteReference: Ab }
  };
}
function sI(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function lI() {
  this.buffer();
}
function uI(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = ln(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function cI(e) {
  this.exit(e);
}
function fI(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function dI() {
  this.buffer();
}
function pI(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = ln(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function hI(e) {
  this.exit(e);
}
function Ab(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const a = n.enter("footnoteReference"), s = n.enter("reference");
  return o += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: o,
      after: "]"
    })
  ), s(), a(), o += i.move("]"), o;
}
function vI() {
  return "[";
}
function mI(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const a = n.enter("footnoteDefinition"), s = n.enter("label");
  return o += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: o,
      after: "]"
    })
  ), s(), o += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), o += i.move(
    n.indentLines(n.containerFlow(e, i.current()), gI)
  ), a(), o;
}
function gI(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const yI = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Db.peek = EI;
function bI() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: wI },
    exit: { strikethrough: SI }
  };
}
function xI() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: yI
      }
    ],
    handlers: { delete: Db }
  };
}
function wI(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function SI(e) {
  this.exit(e);
}
function Db(e, t, n, r) {
  const i = n.createTracker(r), o = n.enter("strikethrough");
  let a = i.move("~~");
  return a += n.containerPhrasing(e, {
    ...i.current(),
    before: a,
    after: "~"
  }), a += i.move("~~"), o(), a;
}
function EI() {
  return "~";
}
function kI(e) {
  return e.length;
}
function CI(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || kI, o = [], a = [], s = [], l = [];
  let u = 0, c = -1;
  for (; ++c < e.length; ) {
    const h = [], g = [];
    let m = -1;
    for (e[c].length > u && (u = e[c].length); ++m < e[c].length; ) {
      const b = $I(e[c][m]);
      if (n.alignDelimiters !== !1) {
        const w = i(b);
        g[m] = w, (l[m] === void 0 || w > l[m]) && (l[m] = w);
      }
      h.push(b);
    }
    a[c] = h, s[c] = g;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < u; )
      o[f] = wh(r[f]);
  else {
    const h = wh(r);
    for (; ++f < u; )
      o[f] = h;
  }
  f = -1;
  const p = [], d = [];
  for (; ++f < u; ) {
    const h = o[f];
    let g = "", m = "";
    h === 99 ? (g = ":", m = ":") : h === 108 ? g = ":" : h === 114 && (m = ":");
    let b = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[f] - g.length - m.length
    );
    const w = g + "-".repeat(b) + m;
    n.alignDelimiters !== !1 && (b = g.length + b + m.length, b > l[f] && (l[f] = b), d[f] = b), p[f] = w;
  }
  a.splice(1, 0, p), s.splice(1, 0, d), c = -1;
  const v = [];
  for (; ++c < a.length; ) {
    const h = a[c], g = s[c];
    f = -1;
    const m = [];
    for (; ++f < u; ) {
      const b = h[f] || "";
      let w = "", C = "";
      if (n.alignDelimiters !== !1) {
        const S = l[f] - (g[f] || 0), E = o[f];
        E === 114 ? w = " ".repeat(S) : E === 99 ? S % 2 ? (w = " ".repeat(S / 2 + 0.5), C = " ".repeat(S / 2 - 0.5)) : (w = " ".repeat(S / 2), C = w) : C = " ".repeat(S);
      }
      n.delimiterStart !== !1 && !f && m.push("|"), n.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && b === "") && (n.delimiterStart !== !1 || f) && m.push(" "), n.alignDelimiters !== !1 && m.push(w), m.push(b), n.alignDelimiters !== !1 && m.push(C), n.padding !== !1 && m.push(" "), (n.delimiterEnd !== !1 || f !== u - 1) && m.push("|");
    }
    v.push(
      n.delimiterEnd === !1 ? m.join("").replace(/ +$/, "") : m.join("")
    );
  }
  return v.join(`
`);
}
function $I(e) {
  return e == null ? "" : String(e);
}
function wh(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function TI(e, t, n, r) {
  const i = n.enter("blockquote"), o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const a = n.indentLines(
    n.containerFlow(e, o.current()),
    OI
  );
  return i(), a;
}
function OI(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function II(e, t) {
  return Sh(e, t.inConstruct, !0) && !Sh(e, t.notInConstruct, !1);
}
function Sh(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Eh(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && II(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function RI(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, o = 0, a = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++o > a && (a = o) : o = 1, i = r + t.length, r = n.indexOf(t, i);
  return a;
}
function PI(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function AI(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function DI(e, t, n, r) {
  const i = AI(n), o = e.value || "", a = i === "`" ? "GraveAccent" : "Tilde";
  if (PI(e, n)) {
    const f = n.enter("codeIndented"), p = n.indentLines(o, _I);
    return f(), p;
  }
  const s = n.createTracker(r), l = i.repeat(Math.max(RI(o, i) + 1, 3)), u = n.enter("codeFenced");
  let c = s.move(l);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${a}`);
    c += s.move(
      n.safe(e.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${a}`);
    c += s.move(" "), c += s.move(
      n.safe(e.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  return c += s.move(`
`), o && (c += s.move(o + `
`)), c += s.move(l), u(), c;
}
function _I(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Af(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function MI(e, t, n, r) {
  const i = Af(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("[");
  return u += l.move(
    n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...l.current()
    })
  ), u += l.move("]: "), s(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(e.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (s = n.enter("destinationRaw"), u += l.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${o}`), u += l.move(" " + i), u += l.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), s()), a(), u;
}
function jI(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
_b.peek = NI;
function _b(e, t, n, r) {
  const i = jI(n), o = n.enter("emphasis"), a = n.createTracker(r);
  let s = a.move(i);
  return s += a.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...a.current()
    })
  ), s += a.move(i), o(), s;
}
function NI(e, t, n) {
  return n.options.emphasis || "*";
}
function LI(e, t) {
  let n = !1;
  return Rf(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, oc;
  }), !!((!e.depth || e.depth < 3) && Ef(e) && (t.options.setext || n));
}
function FI(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), o = n.createTracker(r);
  if (LI(e, n)) {
    const c = n.enter("headingSetext"), f = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...o.current(),
      before: `
`,
      after: `
`
    });
    return f(), c(), p + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const a = "#".repeat(i), s = n.enter("headingAtx"), l = n.enter("phrasing");
  o.move(a + " ");
  let u = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...o.current()
  });
  return /^[\t ]/.test(u) && (u = "&#x" + u.charCodeAt(0).toString(16).toUpperCase() + ";" + u.slice(1)), u = u ? a + " " + u : a, n.options.closeAtx && (u += " " + a), l(), s(), u;
}
Mb.peek = BI;
function Mb(e) {
  return e.value || "";
}
function BI() {
  return "<";
}
jb.peek = zI;
function jb(e, t, n, r) {
  const i = Af(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("![");
  return u += l.move(
    n.safe(e.alt, { before: u, after: "]", ...l.current() })
  ), u += l.move("]("), s(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(e.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (s = n.enter("destinationRaw"), u += l.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${o}`), u += l.move(" " + i), u += l.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), s()), u += l.move(")"), a(), u;
}
function zI() {
  return "!";
}
Nb.peek = WI;
function Nb(e, t, n, r) {
  const i = e.referenceType, o = n.enter("imageReference");
  let a = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("![");
  const u = n.safe(e.alt, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(u + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return a(), n.stack = c, o(), i === "full" || !u || u !== f ? l += s.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function WI() {
  return "!";
}
Lb.peek = UI;
function Lb(e, t, n) {
  let r = e.value || "", i = "`", o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length; ) {
    const a = n.unsafe[o], s = n.compilePattern(a);
    let l;
    if (a.atBreak)
      for (; l = s.exec(r); ) {
        let u = l.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function UI() {
  return "`";
}
function Fb(e, t) {
  const n = Ef(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
Bb.peek = HI;
function Bb(e, t, n, r) {
  const i = Af(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
  let s, l;
  if (Fb(e, n)) {
    const c = n.stack;
    n.stack = [], s = n.enter("autolink");
    let f = a.move("<");
    return f += a.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...a.current()
      })
    ), f += a.move(">"), s(), n.stack = c, f;
  }
  s = n.enter("link"), l = n.enter("label");
  let u = a.move("[");
  return u += a.move(
    n.containerPhrasing(e, {
      before: u,
      after: "](",
      ...a.current()
    })
  ), u += a.move("]("), l(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), u += a.move("<"), u += a.move(
    n.safe(e.url, { before: u, after: ">", ...a.current() })
  ), u += a.move(">")) : (l = n.enter("destinationRaw"), u += a.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...a.current()
    })
  )), l(), e.title && (l = n.enter(`title${o}`), u += a.move(" " + i), u += a.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...a.current()
    })
  ), u += a.move(i), l()), u += a.move(")"), s(), u;
}
function HI(e, t, n) {
  return Fb(e, n) ? "<" : "[";
}
zb.peek = VI;
function zb(e, t, n, r) {
  const i = e.referenceType, o = n.enter("linkReference");
  let a = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("[");
  const u = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(u + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return a(), n.stack = c, o(), i === "full" || !u || u !== f ? l += s.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function VI() {
  return "[";
}
function Df(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function KI(e) {
  const t = Df(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function qI(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Wb(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function GI(e, t, n, r) {
  const i = n.enter("list"), o = n.bulletCurrent;
  let a = e.ordered ? qI(n) : Df(n);
  const s = e.ordered ? a === "." ? ")" : "." : KI(n);
  let l = t && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const c = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (a === "*" || a === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), Wb(n) === a && c
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const p = e.children[f];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (a = s), n.bulletCurrent = a;
  const u = n.containerFlow(e, r);
  return n.bulletLastUsed = a, n.bulletCurrent = o, i(), u;
}
function YI(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function XI(e, t, n, r) {
  const i = YI(n);
  let o = n.bulletCurrent || Df(n);
  t && t.type === "list" && t.ordered && (o = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + o);
  let a = o.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (a = Math.ceil(a / 4) * 4);
  const s = n.createTracker(r);
  s.move(o + " ".repeat(a - o.length)), s.shift(a);
  const l = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(e, s.current()),
    c
  );
  return l(), u;
  function c(f, p, d) {
    return p ? (d ? "" : " ".repeat(a)) + f : (d ? o : o + " ".repeat(a - o.length)) + f;
  }
}
function JI(e, t, n, r) {
  const i = n.enter("paragraph"), o = n.enter("phrasing"), a = n.containerPhrasing(e, r);
  return o(), i(), a;
}
const QI = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  gs([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function ZI(e, t, n, r) {
  return (e.children.some(function(a) {
    return QI(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function eR(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Ub.peek = tR;
function Ub(e, t, n, r) {
  const i = eR(n), o = n.enter("strong"), a = n.createTracker(r);
  let s = a.move(i + i);
  return s += a.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...a.current()
    })
  ), s += a.move(i + i), o(), s;
}
function tR(e, t, n) {
  return n.options.strong || "*";
}
function nR(e, t, n, r) {
  return n.safe(e.value, r);
}
function rR(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function iR(e, t, n) {
  const r = (Wb(n) + (n.options.ruleSpaces ? " " : "")).repeat(rR(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Hb = {
  blockquote: TI,
  break: Eh,
  code: DI,
  definition: MI,
  emphasis: _b,
  hardBreak: Eh,
  heading: FI,
  html: Mb,
  image: jb,
  imageReference: Nb,
  inlineCode: Lb,
  link: Bb,
  linkReference: zb,
  list: GI,
  listItem: XI,
  paragraph: JI,
  root: ZI,
  strong: Ub,
  text: nR,
  thematicBreak: iR
};
function oR() {
  return {
    enter: {
      table: aR,
      tableData: kh,
      tableHeader: kh,
      tableRow: lR
    },
    exit: {
      codeText: uR,
      table: sR,
      tableData: Sl,
      tableHeader: Sl,
      tableRow: Sl
    }
  };
}
function aR(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function sR(e) {
  this.exit(e), this.data.inTable = void 0;
}
function lR(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Sl(e) {
  this.exit(e);
}
function kh(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function uR(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, cR));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function cR(e, t) {
  return t === "|" ? t : e;
}
function fR(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: a,
      tableCell: l,
      tableRow: s
    }
  };
  function a(d, v, h, g) {
    return u(c(d, h, g), d.align);
  }
  function s(d, v, h, g) {
    const m = f(d, h, g), b = u([m]);
    return b.slice(0, b.indexOf(`
`));
  }
  function l(d, v, h, g) {
    const m = h.enter("tableCell"), b = h.enter("phrasing"), w = h.containerPhrasing(d, {
      ...g,
      before: o,
      after: o
    });
    return b(), m(), w;
  }
  function u(d, v) {
    return CI(d, {
      align: v,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function c(d, v, h) {
    const g = d.children;
    let m = -1;
    const b = [], w = v.enter("table");
    for (; ++m < g.length; )
      b[m] = f(g[m], v, h);
    return w(), b;
  }
  function f(d, v, h) {
    const g = d.children;
    let m = -1;
    const b = [], w = v.enter("tableRow");
    for (; ++m < g.length; )
      b[m] = l(g[m], d, v, h);
    return w(), b;
  }
  function p(d, v, h) {
    let g = Hb.inlineCode(d, v, h);
    return h.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function dR() {
  return {
    exit: {
      taskListCheckValueChecked: Ch,
      taskListCheckValueUnchecked: Ch,
      paragraph: hR
    }
  };
}
function pR() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: vR }
  };
}
function Ch(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function hR(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let o = -1, a;
      for (; ++o < i.length; ) {
        const s = i[o];
        if (s.type === "paragraph") {
          a = s;
          break;
        }
      }
      a === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function vR(e, t, n, r) {
  const i = e.children[0], o = typeof e.checked == "boolean" && i && i.type === "paragraph", a = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
  o && s.move(a);
  let l = Hb.listItem(e, t, n, {
    ...r,
    ...s.current()
  });
  return o && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l;
  function u(c) {
    return c + a;
  }
}
function mR() {
  return [
    qO(),
    oI(),
    bI(),
    oR(),
    dR()
  ];
}
function gR(e) {
  return {
    extensions: [
      GO(),
      aI(),
      xI(),
      fR(e),
      pR()
    ]
  };
}
const yR = {
  tokenize: kR,
  partial: !0
}, Vb = {
  tokenize: CR,
  partial: !0
}, Kb = {
  tokenize: $R,
  partial: !0
}, qb = {
  tokenize: TR,
  partial: !0
}, bR = {
  tokenize: OR,
  partial: !0
}, Gb = {
  name: "wwwAutolink",
  tokenize: SR,
  previous: Xb
}, Yb = {
  name: "protocolAutolink",
  tokenize: ER,
  previous: Jb
}, Nn = {
  name: "emailAutolink",
  tokenize: wR,
  previous: Qb
}, kn = {};
function xR() {
  return {
    text: kn
  };
}
let ur = 48;
for (; ur < 123; )
  kn[ur] = Nn, ur++, ur === 58 ? ur = 65 : ur === 91 && (ur = 97);
kn[43] = Nn;
kn[45] = Nn;
kn[46] = Nn;
kn[95] = Nn;
kn[72] = [Nn, Yb];
kn[104] = [Nn, Yb];
kn[87] = [Nn, Gb];
kn[119] = [Nn, Gb];
function wR(e, t, n) {
  const r = this;
  let i, o;
  return a;
  function a(f) {
    return !uc(f) || !Qb.call(r, r.previous) || _f(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(f));
  }
  function s(f) {
    return uc(f) ? (e.consume(f), s) : f === 64 ? (e.consume(f), l) : n(f);
  }
  function l(f) {
    return f === 46 ? e.check(bR, c, u)(f) : f === 45 || f === 95 || Tt(f) ? (o = !0, e.consume(f), l) : c(f);
  }
  function u(f) {
    return e.consume(f), i = !0, l;
  }
  function c(f) {
    return o && i && Dt(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function SR(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return a !== 87 && a !== 119 || !Xb.call(r, r.previous) || _f(r.events) ? n(a) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(yR, e.attempt(Vb, e.attempt(Kb, o), n), n)(a));
  }
  function o(a) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(a);
  }
}
function ER(e, t, n) {
  const r = this;
  let i = "", o = !1;
  return a;
  function a(f) {
    return (f === 72 || f === 104) && Jb.call(r, r.previous) && !_f(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(f), e.consume(f), s) : n(f);
  }
  function s(f) {
    if (Dt(f) && i.length < 5)
      return i += String.fromCodePoint(f), e.consume(f), s;
    if (f === 58) {
      const p = i.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(f), l;
    }
    return n(f);
  }
  function l(f) {
    return f === 47 ? (e.consume(f), o ? u : (o = !0, l)) : n(f);
  }
  function u(f) {
    return f === null || Na(f) || Ue(f) || gr(f) || hs(f) ? n(f) : e.attempt(Vb, e.attempt(Kb, c), n)(f);
  }
  function c(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function kR(e, t, n) {
  let r = 0;
  return i;
  function i(a) {
    return (a === 87 || a === 119) && r < 3 ? (r++, e.consume(a), i) : a === 46 && r === 3 ? (e.consume(a), o) : n(a);
  }
  function o(a) {
    return a === null ? n(a) : t(a);
  }
}
function CR(e, t, n) {
  let r, i, o;
  return a;
  function a(u) {
    return u === 46 || u === 95 ? e.check(qb, l, s)(u) : u === null || Ue(u) || gr(u) || u !== 45 && hs(u) ? l(u) : (o = !0, e.consume(u), a);
  }
  function s(u) {
    return u === 95 ? r = !0 : (i = r, r = void 0), e.consume(u), a;
  }
  function l(u) {
    return i || r || !o ? n(u) : t(u);
  }
}
function $R(e, t) {
  let n = 0, r = 0;
  return i;
  function i(a) {
    return a === 40 ? (n++, e.consume(a), i) : a === 41 && r < n ? o(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? e.check(qb, t, o)(a) : a === null || Ue(a) || gr(a) ? t(a) : (e.consume(a), i);
  }
  function o(a) {
    return a === 41 && r++, e.consume(a), i;
  }
}
function TR(e, t, n) {
  return r;
  function r(s) {
    return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), o) : s === 93 ? (e.consume(s), i) : (
      // `<` is an end.
      s === 60 || // So is whitespace.
      s === null || Ue(s) || gr(s) ? t(s) : n(s)
    );
  }
  function i(s) {
    return s === null || s === 40 || s === 91 || Ue(s) || gr(s) ? t(s) : r(s);
  }
  function o(s) {
    return Dt(s) ? a(s) : n(s);
  }
  function a(s) {
    return s === 59 ? (e.consume(s), r) : Dt(s) ? (e.consume(s), a) : n(s);
  }
}
function OR(e, t, n) {
  return r;
  function r(o) {
    return e.consume(o), i;
  }
  function i(o) {
    return Tt(o) ? n(o) : t(o);
  }
}
function Xb(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Ue(e);
}
function Jb(e) {
  return !Dt(e);
}
function Qb(e) {
  return !(e === 47 || uc(e));
}
function uc(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Tt(e);
}
function _f(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const IR = {
  tokenize: NR,
  partial: !0
};
function RR() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: _R,
        continuation: {
          tokenize: MR
        },
        exit: jR
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: DR
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: PR,
        resolveTo: AR
      }
    }
  };
}
function PR(e, t, n) {
  const r = this;
  let i = r.events.length;
  const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a;
  for (; i--; ) {
    const l = r.events[i][1];
    if (l.type === "labelImage") {
      a = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return s;
  function s(l) {
    if (!a || !a._balanced)
      return n(l);
    const u = ln(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }));
    return u.codePointAt(0) !== 94 || !o.includes(u.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function AR(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const o = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, a = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, o.start),
    end: Object.assign({}, o.end)
  }, s = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", o, t],
    ["enter", a, t],
    ["exit", a, t],
    ["exit", o, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...s), e;
}
function DR(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o = 0, a;
  return s;
  function s(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(f) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      f === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || Ue(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return i.includes(ln(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return Ue(f) || (a = !0), o++, e.consume(f), f === 92 ? c : u;
  }
  function c(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), o++, u) : u(f);
  }
}
function _R(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o, a = 0, s;
  return l;
  function l(v) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(v) {
    return v === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(v);
  }
  function c(v) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      v === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      v === null || v === 91 || Ue(v)
    )
      return n(v);
    if (v === 93) {
      e.exit("chunkString");
      const h = e.exit("gfmFootnoteDefinitionLabelString");
      return o = ln(r.sliceSerialize(h)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return Ue(v) || (s = !0), a++, e.consume(v), v === 92 ? f : c;
  }
  function f(v) {
    return v === 91 || v === 92 || v === 93 ? (e.consume(v), a++, c) : c(v);
  }
  function p(v) {
    return v === 58 ? (e.enter("definitionMarker"), e.consume(v), e.exit("definitionMarker"), i.includes(o) || i.push(o), Ce(e, d, "gfmFootnoteDefinitionWhitespace")) : n(v);
  }
  function d(v) {
    return t(v);
  }
}
function MR(e, t, n) {
  return e.check(po, t, e.attempt(IR, t, n));
}
function jR(e) {
  e.exit("gfmFootnoteDefinition");
}
function NR(e, t, n) {
  const r = this;
  return Ce(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? t(o) : n(o);
  }
}
function LR(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: o,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(a, s) {
    let l = -1;
    for (; ++l < a.length; )
      if (a[l][0] === "enter" && a[l][1].type === "strikethroughSequenceTemporary" && a[l][1]._close) {
        let u = l;
        for (; u--; )
          if (a[u][0] === "exit" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._open && // If the sizes are the same:
          a[l][1].end.offset - a[l][1].start.offset === a[u][1].end.offset - a[u][1].start.offset) {
            a[l][1].type = "strikethroughSequence", a[u][1].type = "strikethroughSequence";
            const c = {
              type: "strikethrough",
              start: Object.assign({}, a[u][1].start),
              end: Object.assign({}, a[l][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, a[u][1].end),
              end: Object.assign({}, a[l][1].start)
            }, p = [["enter", c, s], ["enter", a[u][1], s], ["exit", a[u][1], s], ["enter", f, s]], d = s.parser.constructs.insideSpan.null;
            d && Qt(p, p.length, 0, vs(d, a.slice(u + 1, l), s)), Qt(p, p.length, 0, [["exit", f, s], ["enter", a[l][1], s], ["exit", a[l][1], s], ["exit", c, s]]), Qt(a, u - 1, l - u + 3, p), l = u + p.length - 2;
            break;
          }
      }
    for (l = -1; ++l < a.length; )
      a[l][1].type === "strikethroughSequenceTemporary" && (a[l][1].type = "data");
    return a;
  }
  function o(a, s, l) {
    const u = this.previous, c = this.events;
    let f = 0;
    return p;
    function p(v) {
      return u === 126 && c[c.length - 1][1].type !== "characterEscape" ? l(v) : (a.enter("strikethroughSequenceTemporary"), d(v));
    }
    function d(v) {
      const h = La(u);
      if (v === 126)
        return f > 1 ? l(v) : (a.consume(v), f++, d);
      if (f < 2 && !n) return l(v);
      const g = a.exit("strikethroughSequenceTemporary"), m = La(v);
      return g._open = !m || m === 2 && !!h, g._close = !h || h === 2 && !!m, s(v);
    }
  }
}
class FR {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    BR(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(o, a) {
      return o[0] - a[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let i = r.pop();
    for (; i; )
      t.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function BR(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function zR(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function WR() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: UR,
        resolveAll: HR
      }
    }
  };
}
function UR(e, t, n) {
  const r = this;
  let i = 0, o = 0, a;
  return s;
  function s(O) {
    let D = r.events.length - 1;
    for (; D > -1; ) {
      const M = r.events[D][1].type;
      if (M === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      M === "linePrefix") D--;
      else break;
    }
    const U = D > -1 ? r.events[D][1].type : null, L = U === "tableHead" || U === "tableRow" ? E : l;
    return L === E && r.parser.lazy[r.now().line] ? n(O) : L(O);
  }
  function l(O) {
    return e.enter("tableHead"), e.enter("tableRow"), u(O);
  }
  function u(O) {
    return O === 124 || (a = !0, o += 1), c(O);
  }
  function c(O) {
    return O === null ? n(O) : de(O) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), d) : n(O) : be(O) ? Ce(e, c, "whitespace")(O) : (o += 1, a && (a = !1, i += 1), O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), a = !0, c) : (e.enter("data"), f(O)));
  }
  function f(O) {
    return O === null || O === 124 || Ue(O) ? (e.exit("data"), c(O)) : (e.consume(O), O === 92 ? p : f);
  }
  function p(O) {
    return O === 92 || O === 124 ? (e.consume(O), f) : f(O);
  }
  function d(O) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(O) : (e.enter("tableDelimiterRow"), a = !1, be(O) ? Ce(e, v, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : v(O));
  }
  function v(O) {
    return O === 45 || O === 58 ? g(O) : O === 124 ? (a = !0, e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), h) : S(O);
  }
  function h(O) {
    return be(O) ? Ce(e, g, "whitespace")(O) : g(O);
  }
  function g(O) {
    return O === 58 ? (o += 1, a = !0, e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), m) : O === 45 ? (o += 1, m(O)) : O === null || de(O) ? C(O) : S(O);
  }
  function m(O) {
    return O === 45 ? (e.enter("tableDelimiterFiller"), b(O)) : S(O);
  }
  function b(O) {
    return O === 45 ? (e.consume(O), b) : O === 58 ? (a = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), w) : (e.exit("tableDelimiterFiller"), w(O));
  }
  function w(O) {
    return be(O) ? Ce(e, C, "whitespace")(O) : C(O);
  }
  function C(O) {
    return O === 124 ? v(O) : O === null || de(O) ? !a || i !== o ? S(O) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(O)) : S(O);
  }
  function S(O) {
    return n(O);
  }
  function E(O) {
    return e.enter("tableRow"), I(O);
  }
  function I(O) {
    return O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), I) : O === null || de(O) ? (e.exit("tableRow"), t(O)) : be(O) ? Ce(e, I, "whitespace")(O) : (e.enter("data"), N(O));
  }
  function N(O) {
    return O === null || O === 124 || Ue(O) ? (e.exit("data"), I(O)) : (e.consume(O), O === 92 ? A : N);
  }
  function A(O) {
    return O === 92 || O === 124 ? (e.consume(O), N) : N(O);
  }
}
function HR(e, t) {
  let n = -1, r = !0, i = 0, o = [0, 0, 0, 0], a = [0, 0, 0, 0], s = !1, l = 0, u, c, f;
  const p = new FR();
  for (; ++n < e.length; ) {
    const d = e[n], v = d[1];
    d[0] === "enter" ? v.type === "tableHead" ? (s = !1, l !== 0 && ($h(p, t, l, u, c), c = void 0, l = 0), u = {
      type: "table",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, p.add(n, 0, [["enter", u, t]])) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (r = !0, f = void 0, o = [0, 0, 0, 0], a = [0, n + 1, 0, 0], s && (s = !1, c = {
      type: "tableBody",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, p.add(n, 0, [["enter", c, t]])), i = v.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : i && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") ? (r = !1, a[2] === 0 && (o[1] !== 0 && (a[0] = a[1], f = Vo(p, t, o, i, void 0, f), o = [0, 0, 0, 0]), a[2] = n)) : v.type === "tableCellDivider" && (r ? r = !1 : (o[1] !== 0 && (a[0] = a[1], f = Vo(p, t, o, i, void 0, f)), o = a, a = [o[1], n, 0, 0])) : v.type === "tableHead" ? (s = !0, l = n) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (l = n, o[1] !== 0 ? (a[0] = a[1], f = Vo(p, t, o, i, n, f)) : a[1] !== 0 && (f = Vo(p, t, a, i, n, f)), i = 0) : i && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") && (a[3] = n);
  }
  for (l !== 0 && $h(p, t, l, u, c), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const d = t.events[n];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = zR(t.events, n));
  }
  return e;
}
function Vo(e, t, n, r, i, o) {
  const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
  n[0] !== 0 && (o.end = Object.assign({}, Lr(t.events, n[0])), e.add(n[0], 0, [["exit", o, t]]));
  const l = Lr(t.events, n[1]);
  if (o = {
    type: a,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", o, t]]), n[2] !== 0) {
    const u = Lr(t.events, n[2]), c = Lr(t.events, n[3]), f = {
      type: s,
      start: Object.assign({}, u),
      end: Object.assign({}, c)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const p = t.events[n[2]], d = t.events[n[3]];
      if (p[1].end = Object.assign({}, d[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const v = n[2] + 1, h = n[3] - n[2] - 1;
        e.add(v, h, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return i !== void 0 && (o.end = Object.assign({}, Lr(t.events, i)), e.add(i, 0, [["exit", o, t]]), o = void 0), o;
}
function $h(e, t, n, r, i) {
  const o = [], a = Lr(t.events, n);
  i && (i.end = Object.assign({}, a), o.push(["exit", i, t])), r.end = Object.assign({}, a), o.push(["exit", r, t]), e.add(n + 1, 0, o);
}
function Lr(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const VR = {
  name: "tasklistCheck",
  tokenize: qR
};
function KR() {
  return {
    text: {
      91: VR
    }
  };
}
function qR(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), o)
    );
  }
  function o(l) {
    return Ue(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), a) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), a) : n(l);
  }
  function a(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(l);
  }
  function s(l) {
    return de(l) ? t(l) : be(l) ? e.check({
      tokenize: GR
    }, t, n)(l) : n(l);
  }
}
function GR(e, t, n) {
  return Ce(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function YR(e) {
  return ab([
    xR(),
    RR(),
    LR(e),
    WR(),
    KR()
  ]);
}
const XR = {};
function JR(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || XR, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(YR(n)), o.push(mR()), a.push(gR(n));
}
const we = {
  container: {
    className: "bpReset bpContainer bpFont",
    dropzone: {
      overlay: {
        className: "bpDropzoneOverlay"
      },
      container: {
        className: "bpDropzoneContainer"
      }
    }
  },
  loader: {
    className: "bpReset bpLoader"
  },
  modal: {
    overlay: {
      className: "bpModalOverlay"
    },
    dialog: {
      container: {
        className: "bpReset bpModalContainer"
      },
      title: {
        className: "bpModalTitle"
      },
      description: {
        className: "bpModalDescription"
      },
      content: {
        container: {
          className: "bpModalContentContainer"
        },
        textarea: {
          className: "bpModalContentTextArea"
        }
      },
      button: {
        container: {
          className: "bpModalButtonContainer"
        },
        confirm: {
          className: "bpModalButtonConfirm"
        },
        cancel: {
          className: "bpModalButtonCancel"
        }
      }
    }
  },
  fab: {
    container: {
      className: "bpReset bpFabContainer"
    },
    icon: {
      className: "bpFabIcon"
    },
    image: {
      className: "bpFabImage"
    }
  },
  notification: {
    container: {
      className: "bpReset bpNotificationContainer"
    },
    title: {
      className: "bpNotificationTitle"
    },
    description: {
      className: "bpNotificationDescription"
    },
    icon: {
      className: "bpNotificationIcon"
    },
    closeIcon: {
      className: "bpNotificationCloseIcon"
    }
  },
  header: {
    container: {
      className: "bpReset bpHeaderContainer bpFont"
    },
    content: {
      container: {
        className: "bpReset bpHeaderContentContainer"
      },
      title: {
        className: "bpHeaderContentTitle"
      },
      description: {
        className: "bpHeaderContentDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpHeaderContentAvatarContainer"
        },
        image: {
          className: "bpHeaderContentAvatarImage"
        },
        fallback: {
          className: "bpHeaderContentAvatarFallback"
        }
      },
      actions: {
        container: {
          className: "bpReset bpHeaderContentActionsContainer"
        },
        icons: {
          className: "bpHeaderContentActionsIcons"
        }
      }
    },
    expandedContent: {
      container: {
        className: "bpReset bpHeaderExpandedContentContainer"
      },
      descriptionItems: {
        container: {
          className: "bpReset bpHeaderExpandedContentDescriptionItemsContainer"
        },
        icon: {
          className: "bpHeaderExpandedContentDescriptionItemsIcon"
        },
        text: {
          className: "bpHeaderExpandedContentDescriptionItemsText"
        },
        link: {
          className: "bpHeaderExpandedContentDescriptionItemsLink"
        }
      },
      group: {
        className: "bpHeaderExpandedContentGroup"
      }
    },
    newConversationIcon: {
      className: "bpHeaderNewConversationIcon"
    }
  },
  composer: {
    wrapper: {
      className: "bpReset bpComposerWrapper"
    },
    container: {
      className: "bpReset bpComposerContainer bpFont"
    },
    footer: {
      className: "bpComposerFooter"
    },
    inputContainer: {
      className: "bpComposerInputContainer"
    },
    input: {
      className: "bpComposerInput"
    },
    sendbutton: {
      className: "bpComposerSendButton"
    },
    uploadButton: {
      className: "bpComposerUploadButton"
    },
    voiceButton: {
      className: "bpComposerVoiceButton"
    },
    fileContainer: {
      className: "bpComposerFileContainer"
    },
    fileWidget: {
      container: {
        className: "bpComposerFileAttachement"
      },
      loader: {
        className: "bpComposerFileLoader"
      },
      fileIcon: {
        container: {
          className: "bpComposerFileIconWrapper"
        },
        icon: {
          className: "bpComposerFileIcon"
        }
      },
      metadata: {
        container: {
          className: "bpComposerFileMetadata"
        },
        name: {
          className: "bpComposerFileName"
        },
        type: {
          className: "bpComposerFileExtension"
        }
      },
      removeIcon: {
        className: "bpComposerFileRemoveIcon"
      },
      errorIcon: {
        className: "bpComposerFileErrorIcon"
      },
      previewImage: {
        className: "bpComposerFilePreviewImage"
      }
    }
  },
  messageList: {
    scrollDownButton: {
      className: "bpMessageListScrollDownButton"
    },
    container: {
      className: "bpReset bpMessageListContainer bpFont"
    },
    viewPort: {
      className: "bpMessageListViewport"
    },
    marquee: {
      container: {
        className: "bpReset bpMessageListMarqueeContainer"
      },
      content: {
        className: "bpMessageListMarqueeContent"
      },
      title: {
        className: "bpMessageListMarqueeTitle"
      },
      description: {
        className: "bpMessageListMarqueeDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpMessageListMarqueeAvatarContainer"
        },
        image: {
          className: "bpMessageListMarqueeAvatarImage"
        },
        fallback: {
          className: "bpMessageListMarqueeAvatarFallback"
        }
      }
    },
    headerMessage: {
      className: "bpMessageListHeaderMessage"
    }
  },
  message: {
    container: {
      className: "bpReset bpMessageContainer"
    },
    avatar: {
      container: {
        className: "bpReset bpMessageAvatarContainer"
      },
      image: {
        className: "bpMessageAvatarImage"
      },
      fallback: {
        className: "bpMessageAvatarFallback"
      }
    },
    deliveryStatus: {
      className: "bpMessageDeliveryStatus"
    },
    blocks: {
      text: {
        heading1: {
          className: "bpMessageBlocksTextHeading1"
        },
        heading2: {
          className: "bpMessageBlocksTextHeading2"
        },
        heading3: {
          className: "bpMessageBlocksTextHeading3"
        },
        heading4: {
          className: "bpMessageBlocksTextHeading4"
        },
        unorderedList: {
          className: "bpMessageBlocksTextUnorderedList"
        },
        orderedList: {
          className: "bpMessageBlocksTextOrderedList"
        },
        listItem: {
          className: "bpMessageBlocksTextListItem"
        },
        link: {
          className: "bpMessageBlocksTextLink"
        },
        italic: {
          className: "bpMessageBlocksTextItalic"
        },
        bold: {
          className: "bpMessageBlocksTextBold"
        },
        text: {
          className: "bpMessageBlocksTextText"
        },
        image: {
          className: "bpMessageBlocksTextImage"
        },
        horizontalRule: {
          className: "bpMessageBlocksTextHorizontalRule"
        },
        lineBreak: {
          className: "bpMessageBlocksTextLineBreak"
        },
        input: {
          className: "bpMessageBlocksTextInput"
        },
        codeBlockContainer: {
          className: "bpMessageBlocksTextCodeBlockContainer"
        },
        codeBlockTitle: {
          className: "bpMessageBlocksTextCodeBlockTitle"
        },
        codeBlockCopyIcon: {
          className: "bpMessageBlocksTextCodeBlockCopyIcon"
        },
        codeBlock: {
          className: "bpMessageBlocksTextCodeBlock"
        },
        code: {
          className: "bpMessageBlocksTextCode"
        },
        tableContainer: {
          className: "bpMessageBlocksTextTableContainer"
        },
        table: {
          className: "bpMessageBlocksTextTable"
        },
        tableHeader: {
          className: "bpMessageBlocksTextTableHeader"
        },
        tableData: {
          className: "bpMessageBlocksTextTableData"
        },
        tableRow: {
          className: "bpMessageBlocksTextTableRow"
        }
      },
      audio: {
        className: "bpMessageBlocksAudio"
      },
      image: {
        image: {
          className: "bpMessageBlocksImageImage"
        },
        placeholder: {
          className: "bpMessageBlocksImagePlaceholder"
        }
      },
      video: {
        className: "bpMessageBlocksVideo"
      },
      location: {
        container: {
          className: "bpMessageBlocksLocationContainer"
        },
        title: {
          className: "bpMessageBlocksLocationTitle"
        },
        icon: {
          className: "bpMessageBlocksLocationIcon"
        }
      },
      file: {
        container: {
          className: "bpMessageBlocksFileContainer"
        },
        title: {
          className: "bpMessageBlocksFileTitle"
        },
        icon: {
          className: "bpMessageBlocksFileIcon"
        }
      },
      row: {
        className: "bpMessageBlocksRow"
      },
      column: {
        className: "bpMessageBlocksColumn"
      },
      bubble: {
        container: {
          className: "bpMessageBlocksBubble"
        },
        feedbackContainer: {
          className: "bpMessageBlocksBubbleFeedbackContainer"
        },
        feedbackIcon: {
          className: "bpMessageBlocksBubbleFeedbackIcon"
        }
      },
      carousel: {
        container: {
          className: "bpMessageBlocksCarouselContainer"
        },
        slidesContainer: {
          className: "bpMessageBlocksCarouselSlidesContainer"
        },
        backButton: {
          className: "bpMessageBlocksCarouselBackButton"
        },
        nextButton: {
          className: "bpMessageBlocksCarouselNextButton"
        }
      },
      dropdown: {
        button: {
          container: {
            className: "bpMessageBlocksDropdownButtonContainer"
          },
          text: {
            className: "bpMessageBlocksDropdownButtonText"
          },
          icon: {
            className: "bpMessageBlocksDropdownButtonIcon"
          }
        },
        content: {
          container: {
            className: "bpMessageBlocksDropdownContentContainer"
          },
          item: {
            className: "bpMessageBlocksDropdownContentItem"
          }
        }
      },
      button: {
        className: "bpMessageBlocksButton"
      }
    }
  },
  error: {
    container: {
      className: "bpReset bpErrorContainer"
    },
    header: {
      className: "bpErrorHeader"
    },
    content: {
      className: "bpErrorContent"
    },
    errorTitle: {
      className: "bpErrorTitle"
    },
    errorMessage: {
      className: "bpErrorMessage"
    },
    icon: {
      className: "bpErrorIcon"
    }
  },
  typingIndicator: {
    container: {
      className: "bpTypingIndicatorContainer"
    },
    loader: {
      className: "bpTypingIndicatorLoader"
    }
  }
};
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QR = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Zb = (...e) => e.filter((t, n, r) => !!t && r.indexOf(t) === n).join(" ");
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var ZR = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eP = Ot(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: o,
    iconNode: a,
    ...s
  }, l) => Xu(
    "svg",
    {
      ref: l,
      ...ZR,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: Zb("lucide", i),
      ...s
    },
    [
      ...a.map(([u, c]) => Xu(u, c)),
      ...Array.isArray(o) ? o : [o]
    ]
  )
);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ne = (e, t) => {
  const n = Ot(
    ({ className: r, ...i }, o) => Xu(eP, {
      ref: o,
      iconNode: t,
      className: Zb(`lucide-${QR(e)}`, r),
      ...i
    })
  );
  return n.displayName = `${e}`, n;
};
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tP = Ne("ArrowUp", [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Th = Ne("BotOff", [
  ["path", { d: "M13.67 8H18a2 2 0 0 1 2 2v4.33", key: "7az073" }],
  ["path", { d: "M2 14h2", key: "vft8re" }],
  ["path", { d: "M20 14h2", key: "4cs60a" }],
  ["path", { d: "M22 22 2 2", key: "1r8tn9" }],
  ["path", { d: "M8 8H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h12a2 2 0 0 0 1.414-.586", key: "s09a7a" }],
  ["path", { d: "M9 13v2", key: "rq6x2g" }],
  ["path", { d: "M9.67 4H12v2.33", key: "110xot" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nP = Ne("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rP = Ne("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iP = Ne("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oP = Ne("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aP = Ne("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ex = Ne("CircleX", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sP = Ne("CloudUpload", [
  ["path", { d: "M12 13v8", key: "1l5pq0" }],
  ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242", key: "1pljnt" }],
  ["path", { d: "m8 17 4-4 4 4", key: "1quai1" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lP = Ne("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uP = Ne("FileDown", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M12 18v-6", key: "17g6i2" }],
  ["path", { d: "m9 15 3 3 3-3", key: "1npd3o" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tx = Ne("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cP = Ne("Files", [
  ["path", { d: "M20 7h-3a2 2 0 0 1-2-2V2", key: "x099mo" }],
  ["path", { d: "M9 18a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h7l4 4v10a2 2 0 0 1-2 2Z", key: "18t6ie" }],
  ["path", { d: "M3 7.6v12.8A1.6 1.6 0 0 0 4.6 22h9.8", key: "1nja0z" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fP = Ne("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dP = Ne("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pP = Ne("Lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hP = Ne("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vP = Ne("MapPin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mP = Ne("Mic", [
  ["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z", key: "131961" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gP = Ne("MonitorCog", [
  ["path", { d: "M12 17v4", key: "1riwvh" }],
  ["path", { d: "m15.2 4.9-.9-.4", key: "12wd2u" }],
  ["path", { d: "m15.2 7.1-.9.4", key: "1r2vl7" }],
  ["path", { d: "m16.9 3.2-.4-.9", key: "3zbo91" }],
  ["path", { d: "m16.9 8.8-.4.9", key: "1qr2dn" }],
  ["path", { d: "m19.5 2.3-.4.9", key: "1rjrkq" }],
  ["path", { d: "m19.5 9.7-.4-.9", key: "heryx5" }],
  ["path", { d: "m21.7 4.5-.9.4", key: "17fqt1" }],
  ["path", { d: "m21.7 7.5-.9-.4", key: "14zyni" }],
  ["path", { d: "M22 13v2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7", key: "1tnzv8" }],
  ["path", { d: "M8 21h8", key: "1ev6f3" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yP = Ne("Phone", [
  [
    "path",
    {
      d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z",
      key: "foiqr5"
    }
  ]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bP = Ne("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xP = Ne("RotateCcw", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wP = Ne("ThumbsDown", [
  ["path", { d: "M17 14V2", key: "8ymqnk" }],
  [
    "path",
    {
      d: "M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z",
      key: "m61m77"
    }
  ]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SP = Ne("ThumbsUp", [
  ["path", { d: "M7 10v12", key: "1qc93n" }],
  [
    "path",
    {
      d: "M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z",
      key: "emmmcr"
    }
  ]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EP = Ne("Video", [
  [
    "path",
    {
      d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
      key: "ftymec"
    }
  ],
  ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kP = Ne("Volume2", [
  ["polygon", { points: "11 5 6 9 2 9 2 15 6 15 11 19 11 5", key: "16drj5" }],
  ["path", { d: "M15.54 8.46a5 5 0 0 1 0 7.07", key: "ltjumu" }],
  ["path", { d: "M19.07 4.93a10 10 0 0 1 0 14.14", key: "1kegas" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CP = Ne("WifiOff", [
  ["path", { d: "M12 20h.01", key: "zekei9" }],
  ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0", key: "1bycff" }],
  ["path", { d: "M5 12.859a10 10 0 0 1 5.17-2.69", key: "1dl1wf" }],
  ["path", { d: "M19 12.859a10 10 0 0 0-2.007-1.523", key: "4k23kn" }],
  ["path", { d: "M2 8.82a15 15 0 0 1 4.177-2.643", key: "1grhjp" }],
  ["path", { d: "M22 8.82a15 15 0 0 0-11.288-3.764", key: "z3jwby" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $P = Ne("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), TP = ({ text: e }) => {
  const {
    message: {
      blocks: { text: t }
    }
  } = we, n = {
    h1: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h1", { ...i, ...t.heading1 }),
    h2: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h2", { ...i, ...t.heading2 }),
    h3: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h3", { ...i, ...t.heading3 }),
    h4: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h4", { ...i, ...t.heading4 }),
    h5: "h4",
    h6: "h4",
    em: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("em", { ...i, ...t.italic }),
    strong: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("strong", { ...i, ...t.bold }),
    p: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("p", { ...i, ...t.text }),
    hr: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("hr", { ...i, ...t.horizontalRule }),
    a: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("a", { ...i, ...t.link, target: "_blank", rel: "noreferrer noopener" }),
    img: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("img", { ...i, ...t.image }),
    ol: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("ol", { ...i, ...t.orderedList }),
    ul: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("ul", { ...i, ...t.unorderedList }),
    li: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("li", { ...i, ...t.listItem }),
    br: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("br", { ...i, ...t.lineBreak }),
    pre: ({ node: r, ...i }) => {
      var f, p;
      const o = r == null ? void 0 : r.children[0], a = OP(((p = (f = o == null ? void 0 : o.properties) == null ? void 0 : f.className) == null ? void 0 : p[0]) || ""), [s, l] = ge(!1), u = Ke(null), c = () => {
        if (!u.current) return;
        const d = u.current.textContent || "";
        navigator.clipboard.writeText(d).then(() => {
          l(!0), setTimeout(() => {
            l(!1);
          }, 1500);
        }).catch((v) => {
          console.error("Failed to copy code to clipboard:", v);
        });
      };
      return /* @__PURE__ */ $.jsxs("div", { ...t.codeBlockContainer, children: [
        /* @__PURE__ */ $.jsxs("div", { ...t.codeBlockTitle, children: [
          a ? /* @__PURE__ */ $.jsx("span", { children: a }) : "Code",
          s ? /* @__PURE__ */ $.jsx(nP, { ...t.codeBlockCopyIcon }) : /* @__PURE__ */ $.jsx(cP, { ...t.codeBlockCopyIcon, onClick: c })
        ] }),
        /* @__PURE__ */ $.jsx("pre", { ref: u, ...i, ...t.codeBlock })
      ] });
    },
    input: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("input", { ...i, ...t.input, disabled: !1 }),
    code: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("code", { ...i, ...t.code }),
    table: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("div", { ...t.tableContainer, children: /* @__PURE__ */ $.jsx("table", { ...i, ...t.table }) }),
    th: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("th", { ...i, ...t.tableHeader }),
    tr: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("tr", { ...i, ...t.tableRow }),
    td: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("td", { ...i, ...t.tableData })
  };
  return /* @__PURE__ */ $.jsx(
    Ob,
    {
      urlTransform: (r) => r.startsWith("tel:") ? r : Ib(r),
      components: n,
      remarkPlugins: [JR, KO],
      children: e
    }
  );
}, OP = (e) => {
  if (!e) return "";
  const t = e.match(/language-(\w+)/);
  return t ? t[1] : "";
}, IP = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, Oh = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, f) => {
    const p = typeof c == "function" ? c(t) : c;
    if (!Object.is(p, t)) {
      const d = t;
      t = f ?? (typeof p != "object" || p === null) ? p : Object.assign({}, t, p), n.forEach((v) => v(t, d));
    }
  }, i = () => t, l = { setState: r, getState: i, getInitialState: () => u, subscribe: (c) => (n.add(c), () => n.delete(c)), destroy: () => {
    (IP ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, u = t = e(r, i, l);
  return l;
}, RP = (e) => e ? Oh(e) : Oh;
var cc = { exports: {} }, El = {}, Ko = { exports: {} }, kl = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ih;
function PP() {
  if (Ih) return kl;
  Ih = 1;
  var e = Le;
  function t(f, p) {
    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, a = e.useDebugValue;
  function s(f, p) {
    var d = p(), v = r({ inst: { value: d, getSnapshot: p } }), h = v[0].inst, g = v[1];
    return o(function() {
      h.value = d, h.getSnapshot = p, l(h) && g({ inst: h });
    }, [f, d, p]), i(function() {
      return l(h) && g({ inst: h }), f(function() {
        l(h) && g({ inst: h });
      });
    }, [f]), a(d), d;
  }
  function l(f) {
    var p = f.getSnapshot;
    f = f.value;
    try {
      var d = p();
      return !n(f, d);
    } catch {
      return !0;
    }
  }
  function u(f, p) {
    return p();
  }
  var c = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : s;
  return kl.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : c, kl;
}
var Cl = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rh;
function AP() {
  return Rh || (Rh = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Le, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(w) {
      {
        for (var C = arguments.length, S = new Array(C > 1 ? C - 1 : 0), E = 1; E < C; E++)
          S[E - 1] = arguments[E];
        r("error", w, S);
      }
    }
    function r(w, C, S) {
      {
        var E = t.ReactDebugCurrentFrame, I = E.getStackAddendum();
        I !== "" && (C += "%s", S = S.concat([I]));
        var N = S.map(function(A) {
          return String(A);
        });
        N.unshift("Warning: " + C), Function.prototype.apply.call(console[w], console, N);
      }
    }
    function i(w, C) {
      return w === C && (w !== 0 || 1 / w === 1 / C) || w !== w && C !== C;
    }
    var o = typeof Object.is == "function" ? Object.is : i, a = e.useState, s = e.useEffect, l = e.useLayoutEffect, u = e.useDebugValue, c = !1, f = !1;
    function p(w, C, S) {
      c || e.startTransition !== void 0 && (c = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var E = C();
      if (!f) {
        var I = C();
        o(E, I) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var N = a({
        inst: {
          value: E,
          getSnapshot: C
        }
      }), A = N[0].inst, O = N[1];
      return l(function() {
        A.value = E, A.getSnapshot = C, d(A) && O({
          inst: A
        });
      }, [w, E, C]), s(function() {
        d(A) && O({
          inst: A
        });
        var D = function() {
          d(A) && O({
            inst: A
          });
        };
        return w(D);
      }, [w]), u(E), E;
    }
    function d(w) {
      var C = w.getSnapshot, S = w.value;
      try {
        var E = C();
        return !o(S, E);
      } catch {
        return !0;
      }
    }
    function v(w, C, S) {
      return C();
    }
    var h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !h, m = g ? v : p, b = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m;
    Cl.useSyncExternalStore = b, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Cl;
}
var Ph;
function nx() {
  return Ph || (Ph = 1, process.env.NODE_ENV === "production" ? Ko.exports = PP() : Ko.exports = AP()), Ko.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ah;
function DP() {
  if (Ah) return El;
  Ah = 1;
  var e = Le, t = nx();
  function n(u, c) {
    return u === c && (u !== 0 || 1 / u === 1 / c) || u !== u && c !== c;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, l = e.useDebugValue;
  return El.useSyncExternalStoreWithSelector = function(u, c, f, p, d) {
    var v = o(null);
    if (v.current === null) {
      var h = { hasValue: !1, value: null };
      v.current = h;
    } else h = v.current;
    v = s(function() {
      function m(E) {
        if (!b) {
          if (b = !0, w = E, E = p(E), d !== void 0 && h.hasValue) {
            var I = h.value;
            if (d(I, E)) return C = I;
          }
          return C = E;
        }
        if (I = C, r(w, E)) return I;
        var N = p(E);
        return d !== void 0 && d(I, N) ? I : (w = E, C = N);
      }
      var b = !1, w, C, S = f === void 0 ? null : f;
      return [function() {
        return m(c());
      }, S === null ? void 0 : function() {
        return m(S());
      }];
    }, [c, f, p, d]);
    var g = i(u, v[0], v[1]);
    return a(function() {
      h.hasValue = !0, h.value = g;
    }, [g]), l(g), g;
  }, El;
}
var $l = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dh;
function _P() {
  return Dh || (Dh = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Le, t = nx();
    function n(c, f) {
      return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, l = e.useDebugValue;
    function u(c, f, p, d, v) {
      var h = o(null), g;
      h.current === null ? (g = {
        hasValue: !1,
        value: null
      }, h.current = g) : g = h.current;
      var m = s(function() {
        var S = !1, E, I, N = function(U) {
          if (!S) {
            S = !0, E = U;
            var L = d(U);
            if (v !== void 0 && g.hasValue) {
              var M = g.value;
              if (v(M, L))
                return I = M, M;
            }
            return I = L, L;
          }
          var _ = E, z = I;
          if (r(_, U))
            return z;
          var q = d(U);
          return v !== void 0 && v(z, q) ? z : (E = U, I = q, q);
        }, A = p === void 0 ? null : p, O = function() {
          return N(f());
        }, D = A === null ? void 0 : function() {
          return N(A());
        };
        return [O, D];
      }, [f, p, d, v]), b = m[0], w = m[1], C = i(c, b, w);
      return a(function() {
        g.hasValue = !0, g.value = C;
      }, [C]), l(C), C;
    }
    $l.useSyncExternalStoreWithSelector = u, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), $l;
}
process.env.NODE_ENV === "production" ? cc.exports = DP() : cc.exports = _P();
var MP = cc.exports;
const jP = /* @__PURE__ */ $e(MP), rx = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, { useDebugValue: NP } = Le, { useSyncExternalStoreWithSelector: LP } = jP;
let _h = !1;
const FP = (e) => e;
function BP(e, t = FP, n) {
  (rx ? "production" : void 0) !== "production" && n && !_h && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), _h = !0);
  const r = LP(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return NP(r), r;
}
const zP = (e) => {
  (rx ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? RP(e) : e, n = (r, i) => BP(t, r, i);
  return Object.assign(n, t), n;
}, wr = (e) => zP, wa = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, fc = /* @__PURE__ */ new Map(), qo = (e) => {
  const t = fc.get(e);
  return t ? Object.fromEntries(
    Object.entries(t.stores).map(([n, r]) => [n, r.getState()])
  ) : {};
}, WP = (e, t, n) => {
  if (e === void 0)
    return {
      type: "untracked",
      connection: t.connect(n)
    };
  const r = fc.get(n.name);
  if (r)
    return { type: "tracked", store: e, ...r };
  const i = {
    connection: t.connect(n),
    stores: {}
  };
  return fc.set(n.name, i), { type: "tracked", store: e, ...i };
}, UP = (e, t = {}) => (n, r, i) => {
  const { enabled: o, anonymousActionType: a, store: s, ...l } = t;
  let u;
  try {
    u = (o ?? (wa ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!u)
    return (wa ? "production" : void 0) !== "production" && o && console.warn(
      "[zustand devtools middleware] Please install/enable Redux devtools extension"
    ), e(n, r, i);
  const { connection: c, ...f } = WP(s, u, l);
  let p = !0;
  i.setState = (h, g, m) => {
    const b = n(h, g);
    if (!p) return b;
    const w = m === void 0 ? { type: a || "anonymous" } : typeof m == "string" ? { type: m } : m;
    return s === void 0 ? (c == null || c.send(w, r()), b) : (c == null || c.send(
      {
        ...w,
        type: `${s}/${w.type}`
      },
      {
        ...qo(l.name),
        [s]: i.getState()
      }
    ), b);
  };
  const d = (...h) => {
    const g = p;
    p = !1, n(...h), p = g;
  }, v = e(i.setState, r, i);
  if (f.type === "untracked" ? c == null || c.init(v) : (f.stores[f.store] = i, c == null || c.init(
    Object.fromEntries(
      Object.entries(f.stores).map(([h, g]) => [
        h,
        h === f.store ? v : g.getState()
      ])
    )
  )), i.dispatchFromDevtools && typeof i.dispatch == "function") {
    let h = !1;
    const g = i.dispatch;
    i.dispatch = (...m) => {
      (wa ? "production" : void 0) !== "production" && m[0].type === "__setState" && !h && (console.warn(
        '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
      ), h = !0), g(...m);
    };
  }
  return c.subscribe((h) => {
    var g;
    switch (h.type) {
      case "ACTION":
        if (typeof h.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return Tl(
          h.payload,
          (m) => {
            if (m.type === "__setState") {
              if (s === void 0) {
                d(m.state);
                return;
              }
              Object.keys(m.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const b = m.state[s];
              if (b == null)
                return;
              JSON.stringify(i.getState()) !== JSON.stringify(b) && d(b);
              return;
            }
            i.dispatchFromDevtools && typeof i.dispatch == "function" && i.dispatch(m);
          }
        );
      case "DISPATCH":
        switch (h.payload.type) {
          case "RESET":
            return d(v), s === void 0 ? c == null ? void 0 : c.init(i.getState()) : c == null ? void 0 : c.init(qo(l.name));
          case "COMMIT":
            if (s === void 0) {
              c == null || c.init(i.getState());
              return;
            }
            return c == null ? void 0 : c.init(qo(l.name));
          case "ROLLBACK":
            return Tl(h.state, (m) => {
              if (s === void 0) {
                d(m), c == null || c.init(i.getState());
                return;
              }
              d(m[s]), c == null || c.init(qo(l.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return Tl(h.state, (m) => {
              if (s === void 0) {
                d(m);
                return;
              }
              JSON.stringify(i.getState()) !== JSON.stringify(m[s]) && d(m[s]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState: m } = h.payload, b = (g = m.computedStates.slice(-1)[0]) == null ? void 0 : g.state;
            if (!b) return;
            d(s === void 0 ? b : b[s]), c == null || c.send(
              null,
              // FIXME no-any
              m
            );
            return;
          }
          case "PAUSE_RECORDING":
            return p = !p;
        }
        return;
    }
  }), v;
}, bs = UP, Tl = (e, t) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      r
    );
  }
  n !== void 0 && t(n);
};
function ix(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var o;
      const a = (l) => l === null ? null : JSON.parse(l, void 0), s = (o = n.getItem(i)) != null ? o : null;
      return s instanceof Promise ? s.then(a) : a(s);
    },
    setItem: (i, o) => n.setItem(
      i,
      JSON.stringify(o, void 0)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const Qi = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return Qi(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return Qi(r)(n);
      }
    };
  }
}, HP = (e, t) => (n, r, i) => {
  let o = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (g) => g,
    version: 0,
    merge: (g, m) => ({
      ...m,
      ...g
    }),
    ...t
  }, a = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let u;
  try {
    u = o.getStorage();
  } catch {
  }
  if (!u)
    return e(
      (...g) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
        ), n(...g);
      },
      r,
      i
    );
  const c = Qi(o.serialize), f = () => {
    const g = o.partialize({ ...r() });
    let m;
    const b = c({ state: g, version: o.version }).then(
      (w) => u.setItem(o.name, w)
    ).catch((w) => {
      m = w;
    });
    if (m)
      throw m;
    return b;
  }, p = i.setState;
  i.setState = (g, m) => {
    p(g, m), f();
  };
  const d = e(
    (...g) => {
      n(...g), f();
    },
    r,
    i
  );
  let v;
  const h = () => {
    var g;
    if (!u) return;
    a = !1, s.forEach((b) => b(r()));
    const m = ((g = o.onRehydrateStorage) == null ? void 0 : g.call(o, r())) || void 0;
    return Qi(u.getItem.bind(u))(o.name).then((b) => {
      if (b)
        return o.deserialize(b);
    }).then((b) => {
      if (b)
        if (typeof b.version == "number" && b.version !== o.version) {
          if (o.migrate)
            return o.migrate(
              b.state,
              b.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return b.state;
    }).then((b) => {
      var w;
      return v = o.merge(
        b,
        (w = r()) != null ? w : d
      ), n(v, !0), f();
    }).then(() => {
      m == null || m(v, void 0), a = !0, l.forEach((b) => b(v));
    }).catch((b) => {
      m == null || m(void 0, b);
    });
  };
  return i.persist = {
    setOptions: (g) => {
      o = {
        ...o,
        ...g
      }, g.getStorage && (u = g.getStorage());
    },
    clearStorage: () => {
      u == null || u.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => h(),
    hasHydrated: () => a,
    onHydrate: (g) => (s.add(g), () => {
      s.delete(g);
    }),
    onFinishHydration: (g) => (l.add(g), () => {
      l.delete(g);
    })
  }, h(), v || d;
}, VP = (e, t) => (n, r, i) => {
  let o = {
    storage: ix(() => localStorage),
    partialize: (h) => h,
    version: 0,
    merge: (h, g) => ({
      ...g,
      ...h
    }),
    ...t
  }, a = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let u = o.storage;
  if (!u)
    return e(
      (...h) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
        ), n(...h);
      },
      r,
      i
    );
  const c = () => {
    const h = o.partialize({ ...r() });
    return u.setItem(o.name, {
      state: h,
      version: o.version
    });
  }, f = i.setState;
  i.setState = (h, g) => {
    f(h, g), c();
  };
  const p = e(
    (...h) => {
      n(...h), c();
    },
    r,
    i
  );
  i.getInitialState = () => p;
  let d;
  const v = () => {
    var h, g;
    if (!u) return;
    a = !1, s.forEach((b) => {
      var w;
      return b((w = r()) != null ? w : p);
    });
    const m = ((g = o.onRehydrateStorage) == null ? void 0 : g.call(o, (h = r()) != null ? h : p)) || void 0;
    return Qi(u.getItem.bind(u))(o.name).then((b) => {
      if (b)
        if (typeof b.version == "number" && b.version !== o.version) {
          if (o.migrate)
            return [
              !0,
              o.migrate(
                b.state,
                b.version
              )
            ];
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, b.state];
      return [!1, void 0];
    }).then((b) => {
      var w;
      const [C, S] = b;
      if (d = o.merge(
        S,
        (w = r()) != null ? w : p
      ), n(d, !0), C)
        return c();
    }).then(() => {
      m == null || m(d, void 0), d = r(), a = !0, l.forEach((b) => b(d));
    }).catch((b) => {
      m == null || m(void 0, b);
    });
  };
  return i.persist = {
    setOptions: (h) => {
      o = {
        ...o,
        ...h
      }, h.storage && (u = h.storage);
    },
    clearStorage: () => {
      u == null || u.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => v(),
    hasHydrated: () => a,
    onHydrate: (h) => (s.add(h), () => {
      s.delete(h);
    }),
    onFinishHydration: (h) => (l.add(h), () => {
      l.delete(h);
    })
  }, o.skipHydration || v(), d || p;
}, KP = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? ((wa ? "production" : void 0) !== "production" && console.warn(
  "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
), HP(e, t)) : VP(e, t), ox = KP, ax = wr()(
  bs(
    ox(
      (e) => ({
        messageHistory: [],
        addMessageToHistory: (t) => e((n) => ({
          ...n,
          messageHistory: [t, ...(n.messageHistory ?? []).slice(0, 100)]
        }))
      }),
      {
        name: "botpress-message-history"
        // Dynamically set the store name
      }
    )
  )
);
function dc(e) {
  var a;
  const { metadata: t, conversationId: n, userId: r } = e, { payload: i, disableInput: o } = qP(e.payload);
  return {
    id: e.id,
    conversationId: n,
    authorId: r,
    timestamp: new Date(e.createdAt),
    block: i,
    feedback: (a = e.feedback) == null ? void 0 : a.value,
    disableInput: o,
    metadata: t
  };
}
const qP = (e) => {
  switch (e.type) {
    case "audio":
      return sx(e);
    case "card":
      return GP(e);
    case "carousel":
      return YP(e);
    case "choice":
      return XP(e);
    case "dropdown":
      return JP(e);
    case "file":
      return lx(e);
    case "image":
      return ux(e);
    case "location":
      return cx(e);
    case "markdown":
      return fx(e);
    case "text":
      return dx(e);
    case "video":
      return px(e);
    case "bloc":
      return QP(e);
    case "custom":
      return { payload: e };
    default: {
      const t = e;
      throw new Error(`Unsuported message type ${t}`);
    }
  }
}, vo = (e) => ({
  block: e,
  type: "bubble"
}), sx = (e) => ({
  payload: { type: "audio", url: e.audioUrl }
}), GP = (e) => ({
  payload: vo(hx(e))
}), YP = (e) => ({
  payload: {
    type: "carousel",
    blocks: e.items.map((t) => hx({ type: "card", ...t }))
  }
}), XP = (e) => {
  const t = e.options.map((o) => ({ title: o.label, value: o.value })), n = e.text, r = Uy(), i = vo({
    type: "text",
    text: n
  });
  return t.length === 0 ? {
    disableInput: e.disableFreeText,
    payload: i
  } : {
    disableInput: e.disableFreeText,
    payload: {
      type: "column",
      blocks: [
        i,
        {
          type: "row",
          blocks: t.map(({ title: o, value: a }) => ({
            type: "button",
            variant: "action",
            text: o,
            buttonValue: a,
            groupId: r
          }))
        }
      ]
    }
  };
}, JP = (e) => {
  const t = e.options.map((i) => ({ label: i.label, value: i.value })), n = e.text, r = [
    {
      type: "dropdown",
      label: n ?? "Select an option",
      options: t
    }
  ];
  return n && r.unshift({
    type: "text",
    text: n
  }), {
    disableInput: !0,
    payload: vo({
      type: "column",
      blocks: r
    })
  };
}, lx = (e) => ({
  payload: {
    type: "file",
    url: e.fileUrl,
    title: e.title
  }
}), ux = (e) => ({
  payload: { type: "image", url: e.imageUrl }
}), cx = (e) => ({
  payload: {
    type: "location",
    latitude: e.latitude,
    longitude: e.longitude,
    title: e.title ?? e.address ?? "View on map"
  }
}), fx = (e) => ({
  payload: vo({ type: "text", text: e.markdown })
}), dx = (e) => ({
  payload: vo({ type: "text", text: e.text, value: e.value })
}), px = (e) => ({
  payload: { type: "video", url: e.videoUrl }
}), QP = (e) => ({ payload: {
  type: "column",
  blocks: e.items.map((n) => {
    switch (n.type) {
      case "audio":
        return sx({ ...n.payload, type: n.type }).payload;
      case "file":
        return lx({ ...n.payload, type: n.type }).payload;
      case "image":
        return ux({ ...n.payload, type: n.type }).payload;
      case "location":
        return cx({ ...n.payload, type: n.type }).payload;
      case "markdown":
        return fx({ ...n.payload, type: n.type }).payload;
      case "text":
        return dx({ ...n.payload, type: n.type }).payload;
      case "video":
        return px({ ...n.payload, type: n.type }).payload;
      default:
        throw new Error("Unsuported message type");
    }
  })
} }), hx = (e) => {
  const t = e.title, n = e.subtitle, r = e.imageUrl, i = e.actions.map((a) => {
    switch (a.action) {
      case "postback":
        return {
          type: "button",
          variant: "action",
          text: a.label,
          buttonValue: a.value,
          reusable: !0
        };
      case "url":
        return {
          type: "button",
          variant: "link",
          text: a.label,
          buttonValue: a.value,
          reusable: !0
        };
      case "say":
        return {
          type: "button",
          variant: "action",
          text: a.label,
          buttonValue: a.value,
          reusable: !0
        };
      default:
        throw new Error(`Unknown action type ${a.action}`);
    }
  }), o = [];
  return r && o.push({
    type: "image",
    url: r
  }), t && o.push({
    type: "text",
    text: `#### ${t}`
  }), n && o.push({
    type: "text",
    text: n
  }), i.length > 0 && o.push({
    type: "row",
    blocks: i
  }), {
    type: "column",
    horizontalAlignment: "center",
    blocks: [...o]
  };
}, cr = wr()(
  bs(
    (e) => ({
      messages: [],
      isFetching: !1,
      setMessages: (t) => e({ messages: t }),
      saveMessage: (t) => e(({ messages: n }) => {
        var i;
        const r = (i = t.metadata) == null ? void 0 : i.clientMessageId;
        if (r) {
          const o = n.findIndex((s) => {
            var l;
            return ((l = s.metadata) == null ? void 0 : l.clientMessageId) === r;
          }), a = n[o];
          if (o !== -1)
            return {
              messages: [
                ...n.slice(0, o),
                { ...a, ...t },
                ...n.slice(o + 1)
              ]
            };
        }
        return { messages: [...n.filter((o) => o.id !== t.id), t] };
      }),
      updateMessage: (t, n) => e(({ messages: r }) => ({
        messages: r.map((i) => i.id === t ? { ...i, ...n } : i)
      })),
      clearMessages: () => e({ messages: [] }),
      fetchMessages: async ({ client: t, conversationId: n }) => {
        const r = [];
        e({ isFetching: !0 });
        let i;
        do {
          const { messages: o, meta: a } = await t.listConversationMessages({ conversationId: n, nextToken: i });
          r.push(...o), i = a.nextToken;
        } while (i);
        return e({ isFetching: !1 }), r.reverse().map((o) => dc(o)).filter(Boolean);
      }
    }),
    { name: "messagesStore" }
  )
), ZP = (e, t) => wr()(
  bs(
    ox(
      (n) => ({
        setUser: (r) => n((i) => ({
          ...i,
          user: r
        })),
        setConversationId: (r) => n((i) => ({
          ...i,
          conversationId: r
        })),
        clearAll: () => {
          n((r) => ({
            ...r,
            user: void 0,
            conversationId: void 0
          }));
        }
      }),
      {
        name: e,
        storage: ix(() => t === "sessionStorage" ? sessionStorage : localStorage)
      }
    )
  )
), Vr = class Vr {
  constructor() {
  }
  static getInstance(t = "bp-webchat", n) {
    return Vr._instances[t] || (Vr._instances[t] = ZP(t, n)), Vr._instances[t];
  }
};
yp(Vr, "_instances", {});
let pc = Vr;
const eA = pc.getInstance, vx = () => {
  const e = {};
  return { on: (i, o) => {
    var a;
    return e[i] || (e[i] = /* @__PURE__ */ new Set()), (a = e[i]) == null || a.add(o), () => {
      var s;
      return (s = e[i]) == null ? void 0 : s.delete(o);
    };
  }, emit: (i, o) => {
    var a, s;
    (a = e[i]) == null || a.forEach((l) => l(o)), (s = e["*"]) == null || s.forEach((l) => l({ type: i, payload: o }));
  }, removeAllListeners: (i) => {
    var o;
    i ? (o = e[i]) == null || o.clear() : Object.keys(e).forEach((a) => {
      var s;
      (s = e[a]) == null || s.clear();
    });
  } };
}, Mf = wr()(
  bs(
    (e) => ({
      eventEmitter: vx(),
      messageContainerRef: sE(),
      setMessageContainerRef: (t) => e({ messageContainerRef: t })
    }),
    { name: "webchatStore" }
  )
), tA = 8, Bi = wr()((e, t) => ({
  files: [],
  setFiles: (n) => e({ files: n }),
  upsertFile: (n) => e(({ files: r }) => ({ files: r.some((a) => a.name === n.name) ? r.map((a) => a.name === n.name ? { ...a, ...n } : a) : [...r, { ...n }] })),
  uploadFile: async (n, r) => {
    const i = t().files.some((a) => a.name === n.name), o = t().files.length === tA;
    if (!(!i && o)) {
      t().upsertFile({
        name: n.name,
        type: "file",
        instance: n,
        status: "loading"
      });
      try {
        const { fileUrl: a, type: s } = await r(n);
        t().upsertFile({
          name: n.name,
          type: s,
          url: a,
          instance: n,
          status: "uploaded"
        });
      } catch (a) {
        console.error("Error sending file:", a), t().upsertFile({
          name: n.name,
          type: "file",
          instance: n,
          status: "error"
        });
      }
    }
  },
  deleteFile: (n) => e(({ files: r }) => ({ files: r.filter((i) => i.name != n) }))
})), Go = wr()((e) => ({
  participants: [],
  setParticipants: (t) => e({ participants: t }),
  addParticipant: (t) => e((n) => ({ participants: [...n.participants, t] })),
  removeParticipant: (t) => e((n) => ({ participants: n.participants.filter((r) => r.id !== t) }))
})), nA = ({ text: e, buttonValue: t, variant: n, groupId: r, reusable: i, sendMessage: o, isReadOnly: a, ...s }) => {
  const l = Mf((w) => w.eventEmitter), [u, c] = ge(!1), [f, p] = ge(!1), [d, v] = ge(!1), {
    message: {
      blocks: { button: h }
    }
  } = we;
  vt(() => {
    if (r)
      return l.on(`button-group-${r}-click`, () => {
        p(!0), i || v(!0);
      });
  }, [l, r, i]);
  const m = {
    ...s,
    onClick: (w) => {
      if ((d || a) && n === "link") {
        w.preventDefault();
        return;
      }
      c(!0), i || v(!0), r && l.emit(`button-group-${r}-click`), n !== "link" && o && (o == null || o({ type: "text", text: e, value: t }));
    },
    "data-activated": u ? "" : void 0,
    "data-group-activated": f ? "" : void 0,
    "data-type": n,
    ...h
  }, b = d || a;
  return n === "link" ? /* @__PURE__ */ $.jsx(
    "a",
    {
      ...m,
      style: a ? { pointerEvents: "none" } : void 0,
      href: t,
      target: "_blank",
      rel: "noopener noreferrer",
      children: e
    }
  ) : /* @__PURE__ */ $.jsx("button", { ...m, style: a ? { pointerEvents: "none" } : void 0, disabled: b, children: e });
}, mx = Dy(null);
function rA() {
  const e = ci(mx);
  if (!e)
    throw new Error("useMessageContext must be used within a Message");
  return e;
}
const gx = Dy({
  open: void 0,
  showModal: void 0,
  hideModal: void 0
});
function jf() {
  return ci(gx);
}
const yx = Ot(
  ({
    block: e,
    direction: t,
    sender: n,
    timestamp: r,
    messageId: i,
    feedback: o,
    metadata: a,
    isReadOnly: s,
    sendMessage: l,
    addMessageFeedback: u,
    ...c
  }, f) => {
    const [p, d] = ge(""), { showModal: v, hideModal: h } = jf(), {
      message: {
        blocks: {
          bubble: { container: g, feedbackContainer: m, feedbackIcon: b }
        }
      }
    } = we;
    return t == "incoming" ? /* @__PURE__ */ $.jsxs("div", { "data-direction": "incoming", "data-feedback": !!o, ...c, ...g, ref: f, children: [
      /* @__PURE__ */ $.jsx(
        ii,
        {
          block: {
            ...e,
            direction: t,
            timestamp: r,
            sender: n,
            messageId: i,
            isReadOnly: s,
            metadata: a,
            sendMessage: l
          }
        }
      ),
      u && v && h && e.type === "text" && /* @__PURE__ */ $.jsxs("div", { ...m, children: [
        /* @__PURE__ */ $.jsx(
          SP,
          {
            ...b,
            "data-selected": o === "positive",
            onClick: () => {
              u(i, { value: "positive" });
            }
          }
        ),
        /* @__PURE__ */ $.jsx(
          wP,
          {
            ...b,
            "data-selected": o === "negative",
            onClick: () => v({
              title: "Help us improve",
              description: "Please provide feedback to help us improve.",
              confirmButton: "Send feedback",
              cancelButton: "Cancel",
              onConfirm: () => {
                u(i, { value: "negative", comment: p }), h();
              },
              content: /* @__PURE__ */ $.jsx(iA, { setFeedbackComment: d })
            })
          }
        )
      ] })
    ] }) : /* @__PURE__ */ $.jsx("div", { "data-direction": "outgoing", ...c, ...g, ref: f, children: /* @__PURE__ */ $.jsx(
      ii,
      {
        block: {
          ...e,
          direction: t,
          timestamp: r,
          sender: n,
          messageId: i,
          isReadOnly: s,
          metadata: a,
          sendMessage: l,
          addMessageFeedback: u
        }
      }
    ) });
  }
);
yx.displayName = "Bubble";
const iA = ({ setFeedbackComment: e }) => {
  const {
    modal: {
      dialog: { content: t }
    }
  } = we;
  return /* @__PURE__ */ $.jsx(
    "textarea",
    {
      ...t.textarea,
      placeholder: "Let us know what went wrong...",
      onChange: (n) => e(n.target.value)
    }
  );
};
var Jt = function() {
  return Jt = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Jt.apply(this, arguments);
};
function bx(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function hi(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(a) {
      a(o);
    });
  }
  return new (n || (n = Promise))(function(o, a) {
    function s(c) {
      try {
        u(r.next(c));
      } catch (f) {
        a(f);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (f) {
        a(f);
      }
    }
    function u(c) {
      c.done ? o(c.value) : i(c.value).then(s, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function vi(e, t) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, a = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return a.next = s(0), a.throw = s(1), a.return = s(2), typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function s(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, u[0] && (n = 0)), n; ) try {
      if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done) return o;
      switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
        case 0:
        case 1:
          o = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, i = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < o[1]) {
            n.label = o[1], o = u;
            break;
          }
          if (o && n.label < o[2]) {
            n.label = o[2], n.ops.push(u);
            break;
          }
          o[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], i = 0;
    } finally {
      r = o = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Mh(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e), i, o = [], a;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) o.push(i.value);
  } catch (s) {
    a = { error: s };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (a) throw a.error;
    }
  }
  return o;
}
function hc(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)
    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
function oA() {
  var e = Ke(!1), t = Oe(function() {
    return e.current;
  }, []);
  return vt(function() {
    return e.current = !0, function() {
      e.current = !1;
    };
  }, []), t;
}
function aA(e, t, n) {
  t === void 0 && (t = []), n === void 0 && (n = { loading: !1 });
  var r = Ke(0), i = oA(), o = ge(n), a = o[0], s = o[1], l = Oe(function() {
    for (var u = [], c = 0; c < arguments.length; c++)
      u[c] = arguments[c];
    var f = ++r.current;
    return a.loading || s(function(p) {
      return Jt(Jt({}, p), { loading: !0 });
    }), e.apply(void 0, u).then(function(p) {
      return i() && f === r.current && s({ value: p, loading: !1 }), p;
    }, function(p) {
      return i() && f === r.current && s({ error: p, loading: !1 }), p;
    });
  }, t);
  return [a, l];
}
function xx(e, t) {
  t === void 0 && (t = []);
  var n = aA(e, t, {
    loading: !0
  }), r = n[0], i = n[1];
  return vt(function() {
    i();
  }, [i]), r;
}
const wx = Ot(({ url: e, type: t, orientation: n = "auto", ...r }, i) => {
  const o = lE(), { setIsLoading: a } = rA(), [s, l] = ge(n), [u, c] = ge(!1), {
    message: {
      blocks: { image: f }
    }
  } = we;
  return fi(() => {
    a((p) => [...p, o]);
  }, []), xx(async () => {
    if (e) {
      try {
        const { width: p, height: d } = await lk(e);
        s === "auto" && l(sA(p, d));
      } catch (p) {
        l("square"), console.error(p);
      }
      a((p) => p.filter((d) => d !== o));
    }
  }, [e]), /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    u ? null : /* @__PURE__ */ $.jsx("div", { "data-orientation": s, ...f.placeholder }),
    /* @__PURE__ */ $.jsx(
      "img",
      {
        "data-orientation": s,
        "data-loaded": u,
        ...r,
        ...f.image,
        src: e,
        alt: "",
        ref: i,
        loading: "lazy",
        onLoad: () => {
          c(!0);
        }
      }
    )
  ] });
});
wx.displayName = "Image";
function sA(e, t) {
  const n = {
    square: 1,
    portrait: 0.75,
    landscape: 1.3333333333333333
  }, r = e / t;
  return Object.keys(n).reduce((o, a) => Math.abs(n[a] - r) < Math.abs(n[o] - r) ? a : o);
}
const Sx = Ot(({ url: e, isReadOnly: t, ...n }, r) => {
  const {
    message: {
      blocks: { video: i }
    }
  } = we;
  return /* @__PURE__ */ $.jsx("div", { children: /* @__PURE__ */ $.jsx(
    "video",
    {
      ...n,
      "data-chromatic": "ignore",
      style: t ? { pointerEvents: "none" } : void 0,
      controls: !0,
      src: e,
      ...i,
      ref: r
    }
  ) });
});
Sx.displayName = "Video";
const Ex = Ot(({ url: e, isReadOnly: t, ...n }, r) => {
  const {
    message: {
      blocks: { audio: i }
    }
  } = we;
  return /* @__PURE__ */ $.jsx("div", { children: /* @__PURE__ */ $.jsx(
    "audio",
    {
      ...n,
      controls: !0,
      style: t ? { pointerEvents: "none" } : void 0,
      src: e,
      ...i,
      ref: r
    }
  ) });
});
Ex.displayName = "Audio";
const kx = Ot(
  ({ latitude: e, longitude: t, title: n, isReadOnly: r, ...i }, o) => {
    const a = `https://www.google.com/maps/search/?api=1&query=${e},${t}`, {
      message: {
        blocks: { location: s }
      }
    } = we;
    return /* @__PURE__ */ $.jsxs(
      "a",
      {
        ...i,
        ...s.container,
        style: r ? { pointerEvents: "none" } : void 0,
        href: a,
        type: "_blank",
        rel: "noopener",
        ref: o,
        children: [
          /* @__PURE__ */ $.jsx("p", { ...s.title, children: n }),
          /* @__PURE__ */ $.jsx(vP, { ...s.icon })
        ]
      }
    );
  }
);
kx.displayName = "Location";
const Cx = Ot(
  ({
    blocks: e,
    horizontalAlignment: t,
    verticalAlignment: n,
    direction: r,
    sender: i,
    timestamp: o,
    messageId: a,
    isReadOnly: s,
    sendMessage: l,
    ...u
  }, c) => {
    const {
      message: {
        blocks: { column: f }
      }
    } = we;
    return /* @__PURE__ */ $.jsx("div", { "data-horizontal": t, "data-vertical": n, ...u, ...f, ref: c, children: e.map((p, d) => /* @__PURE__ */ $.jsx(
      ii,
      {
        block: {
          ...p,
          direction: r,
          timestamp: o,
          sender: i,
          messageId: a,
          isReadOnly: s,
          sendMessage: l
        }
      },
      d
    )) });
  }
);
Cx.displayName = "Column";
const $x = Ot(
  ({
    blocks: e,
    horizontalAlignment: t,
    verticalAlignment: n,
    direction: r,
    sender: i,
    timestamp: o,
    metadata: a,
    messageId: s,
    isReadOnly: l,
    sendMessage: u,
    ...c
  }, f) => {
    const {
      message: {
        blocks: { row: p }
      }
    } = we;
    return /* @__PURE__ */ $.jsx("div", { "data-horizontal": t, "data-vertical": n, ...c, ...p, ref: f, children: e.map((d, v) => /* @__PURE__ */ $.jsx(ii, { block: { ...d, direction: r, timestamp: o, sender: i, messageId: s, isReadOnly: l, sendMessage: u } }, v)) });
  }
);
$x.displayName = "Row";
function lA(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function jh(e) {
  return lA(e) || Array.isArray(e);
}
function uA() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Nf(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return !1;
  const i = JSON.stringify(Object.keys(e.breakpoints || {})), o = JSON.stringify(Object.keys(t.breakpoints || {}));
  return i !== o ? !1 : n.every((a) => {
    const s = e[a], l = t[a];
    return typeof s == "function" ? `${s}` == `${l}` : !jh(s) || !jh(l) ? s === l : Nf(s, l);
  });
}
function Nh(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function cA(e, t) {
  if (e.length !== t.length) return !1;
  const n = Nh(e), r = Nh(t);
  return n.every((i, o) => {
    const a = r[o];
    return Nf(i, a);
  });
}
function Lf(e) {
  return typeof e == "number";
}
function Lh(e) {
  return typeof e == "string";
}
function Ff(e) {
  return typeof e == "boolean";
}
function Fh(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function et(e) {
  return Math.abs(e);
}
function Bf(e) {
  return Math.sign(e);
}
function Sa(e, t) {
  return et(e - t);
}
function fA(e, t) {
  if (e === 0 || t === 0 || et(e) <= et(t)) return 0;
  const n = Sa(et(e), et(t));
  return et(n / e);
}
function Zi(e) {
  return Wa(e).map(Number);
}
function Dn(e) {
  return e[xs(e)];
}
function xs(e) {
  return Math.max(0, e.length - 1);
}
function Wa(e) {
  return Object.keys(e);
}
function Tx(e, t) {
  return [e, t].reduce((n, r) => (Wa(r).forEach((i) => {
    const o = n[i], a = r[i], s = Fh(o) && Fh(a);
    n[i] = s ? Tx(o, a) : a;
  }), n), {});
}
function Ox(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function dA(e, t) {
  const n = {
    start: r,
    center: i,
    end: o
  };
  function r() {
    return 0;
  }
  function i(u) {
    return o(u) / 2;
  }
  function o(u) {
    return t - u;
  }
  function a() {
    return t * Number(e);
  }
  function s(u) {
    return Lf(e) ? a() : n[e](u);
  }
  return {
    measure: s
  };
}
function pA(e, t) {
  const n = e === "y" ? "y" : "x", r = e === "y" ? "x" : "y", i = s(), o = l();
  function a(c) {
    const {
      width: f,
      height: p
    } = c;
    return n === "x" ? f : p;
  }
  function s() {
    return n === "y" ? "top" : t === "rtl" ? "right" : "left";
  }
  function l() {
    return n === "y" ? "bottom" : t === "rtl" ? "left" : "right";
  }
  return {
    scroll: n,
    cross: r,
    startEdge: i,
    endEdge: o,
    measureSize: a
  };
}
function Zn(e, t) {
  const n = et(e - t);
  function r(u) {
    return u < e;
  }
  function i(u) {
    return u > t;
  }
  function o(u) {
    return r(u) || i(u);
  }
  function a(u) {
    return o(u) ? r(u) ? e : t : u;
  }
  function s(u) {
    return n ? u - n * Math.ceil((u - t) / n) : u;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: a,
    reachedAny: o,
    reachedMax: i,
    reachedMin: r,
    removeOffset: s
  };
}
function Ix(e, t, n) {
  const {
    constrain: r
  } = Zn(0, e), i = e + 1;
  let o = a(t);
  function a(p) {
    return n ? et((i + p) % i) : r(p);
  }
  function s() {
    return o;
  }
  function l(p) {
    return o = a(p), f;
  }
  function u(p) {
    return c().set(s() + p);
  }
  function c() {
    return Ix(e, s(), n);
  }
  const f = {
    get: s,
    set: l,
    add: u,
    clone: c
  };
  return f;
}
function hA(e) {
  const t = e === "rtl" ? -1 : 1;
  function n(i) {
    return i * t;
  }
  return {
    apply: n
  };
}
function eo() {
  let e = [];
  function t(i, o, a, s = {
    passive: !0
  }) {
    return i.addEventListener(o, a, s), e.push(() => i.removeEventListener(o, a, s)), r;
  }
  function n() {
    e = e.filter((i) => i());
  }
  const r = {
    add: t,
    clear: n
  };
  return r;
}
function vA(e, t, n, r, i, o, a, s, l, u, c, f, p, d, v, h, g, m, b) {
  const {
    cross: w
  } = e, C = ["INPUT", "SELECT", "TEXTAREA"], S = {
    passive: !1
  }, E = eo(), I = eo(), N = Zn(50, 225).constrain(v.measure(20)), A = {
    mouse: 300,
    touch: 400
  }, O = {
    mouse: 500,
    touch: 600
  }, D = h ? 43 : 25;
  let U = !1, L = 0, M = 0, _ = !1, z = !1, q = !1, H = !1;
  function P(J, V) {
    if (!V) return;
    function ne(fe) {
      (Ff(V) || V(J, fe)) && G(fe);
    }
    const se = n;
    E.add(se, "dragstart", (fe) => fe.preventDefault(), S).add(se, "touchmove", () => {
    }, S).add(se, "touchend", () => {
    }).add(se, "touchstart", ne).add(se, "mousedown", ne).add(se, "touchcancel", Y).add(se, "contextmenu", Y).add(se, "click", Q, !0);
  }
  function y() {
    E.clear(), I.clear();
  }
  function T() {
    const J = H ? r : n;
    I.add(J, "touchmove", K, S).add(J, "touchend", Y).add(J, "mousemove", K, S).add(J, "mouseup", Y);
  }
  function j(J) {
    const V = J.nodeName || "";
    return C.includes(V);
  }
  function x() {
    return (h ? O : A)[H ? "mouse" : "touch"];
  }
  function F(J, V) {
    const ne = p.add(Bf(J) * -1), se = f.byDistance(J, !h).distance;
    return h || et(J) < N ? se : m && V ? se * 0.5 : f.byIndex(ne.get(), 0).distance;
  }
  function G(J) {
    const V = Ox(J, i);
    H = V, !(V && J.button !== 0) && (j(J.target) || (q = h && V && !J.buttons && U, U = Sa(o.get(), s.get()) >= 2, _ = !0, a.pointerDown(J), c.useFriction(0).useDuration(0), o.set(s), T(), L = a.readPoint(J), M = a.readPoint(J, w), d.emit("pointerDown")));
  }
  function K(J) {
    const V = a.readPoint(J), ne = a.readPoint(J, w), se = Sa(V, L), fe = Sa(ne, M);
    if (!z && !H && (!J.cancelable || (z = se > fe, !z)))
      return Y(J);
    const oe = a.pointerMove(J);
    se > g && (q = !0), c.useFriction(0.3).useDuration(1), l.start(), o.add(t.apply(oe)), J.preventDefault();
  }
  function Y(J) {
    const ne = f.byDistance(0, !1).index !== p.get(), se = a.pointerUp(J) * x(), fe = F(t.apply(se), ne), oe = fA(se, fe), pe = D - 10 * oe, Se = b + oe / 50;
    z = !1, _ = !1, I.clear(), c.useDuration(pe).useFriction(Se), u.distance(fe, !h), H = !1, d.emit("pointerUp");
  }
  function Q(J) {
    q && (J.stopPropagation(), J.preventDefault());
  }
  function Z() {
    return _;
  }
  return {
    init: P,
    pointerDown: Z,
    destroy: y
  };
}
function mA(e, t) {
  let r, i;
  function o(f) {
    return f.timeStamp;
  }
  function a(f, p) {
    const v = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (Ox(f, t) ? f : f.touches[0])[v];
  }
  function s(f) {
    return r = f, i = f, a(f);
  }
  function l(f) {
    const p = a(f) - a(i), d = o(f) - o(r) > 170;
    return i = f, d && (r = f), p;
  }
  function u(f) {
    if (!r || !i) return 0;
    const p = a(i) - a(r), d = o(f) - o(r), v = o(f) - o(i) > 170, h = p / d;
    return d && !v && et(h) > 0.1 ? h : 0;
  }
  return {
    pointerDown: s,
    pointerMove: l,
    pointerUp: u,
    readPoint: a
  };
}
function gA(e) {
  function t(r) {
    return e * (r / 100);
  }
  return {
    measure: t
  };
}
function yA(e, t, n, r, i) {
  let o, a, s = [], l = !1;
  function u(d) {
    return i.measureSize(d.getBoundingClientRect());
  }
  function c(d, v) {
    if (!v) return;
    a = u(e), s = r.map(u);
    function h(m) {
      for (const b of m) {
        const w = b.target === e, C = r.indexOf(b.target), S = w ? a : s[C], E = u(w ? e : r[C]);
        if (S !== E) {
          n.requestAnimationFrame(() => {
            d.reInit(), t.emit("resize");
          });
          break;
        }
      }
    }
    o = new ResizeObserver((m) => {
      l || (Ff(v) || v(d, m)) && h(m);
    }), [e].concat(r).forEach((m) => o.observe(m));
  }
  function f() {
    o && o.disconnect(), l = !0;
  }
  return {
    init: c,
    destroy: f
  };
}
function bA(e, t, n, r) {
  let i = !0, o = 0, a = 0, s = n, l = r, u = e.get(), c = 0;
  function f() {
    const S = t.get() - e.get(), E = !s;
    let I = 0;
    return E ? (o = 0, e.set(t), I = S) : (o += S / s, o *= l, u += o, e.add(o), I = u - c), a = Bf(I), c = u, i = et(S) < 1e-3, C;
  }
  function p() {
    return i;
  }
  function d() {
    return s;
  }
  function v() {
    return a;
  }
  function h() {
    return o;
  }
  function g() {
    return b(n);
  }
  function m() {
    return w(r);
  }
  function b(S) {
    return s = S, C;
  }
  function w(S) {
    return l = S, C;
  }
  const C = {
    direction: v,
    duration: d,
    velocity: h,
    seek: f,
    settled: p,
    useBaseFriction: m,
    useBaseDuration: g,
    useFriction: w,
    useDuration: b
  };
  return C;
}
function xA(e, t, n, r, i) {
  const o = i.measure(10), a = i.measure(50), s = Zn(0.1, 0.99);
  let l = !1;
  function u() {
    return !(l || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function c(d) {
    if (!u()) return;
    const v = e.reachedMin(t.get()) ? "min" : "max", h = et(e[v] - t.get()), g = n.get() - t.get(), m = s.constrain(h / a);
    n.subtract(g * m), !d && et(g) < o && (n.set(e.constrain(n.get())), r.useDuration(25).useBaseFriction());
  }
  function f(d) {
    l = !d;
  }
  return {
    constrain: c,
    toggleActive: f
  };
}
function wA(e, t, n, r) {
  const i = Zn(-t + e, n[0]), o = l(), a = u();
  function s() {
    const f = o[0], p = Dn(o), d = o.lastIndexOf(f), v = o.indexOf(p) + 1;
    return Zn(d, v);
  }
  function l() {
    return n.map(i.constrain).map((f) => parseFloat(f.toFixed(3)));
  }
  function u() {
    if (t <= e) return [i.max];
    if (r === "keepSnaps") return o;
    const {
      min: f,
      max: p
    } = s();
    return o.slice(f, p);
  }
  return {
    snapsContained: a
  };
}
function SA(e, t, n) {
  const r = t[0], i = n ? r - e : Dn(t);
  return {
    limit: Zn(i, r)
  };
}
function EA(e, t, n, r) {
  const o = t.min + 0.1, a = t.max + 0.1, {
    reachedMin: s,
    reachedMax: l
  } = Zn(o, a);
  function u(p) {
    return p === 1 ? l(n.get()) : p === -1 ? s(n.get()) : !1;
  }
  function c(p) {
    if (!u(p)) return;
    const d = e * (p * -1);
    r.forEach((v) => v.add(d));
  }
  return {
    loop: c
  };
}
function kA(e) {
  const {
    max: t,
    length: n
  } = e;
  function r(o) {
    return (o - t) / -n;
  }
  return {
    get: r
  };
}
function CA(e, t, n, r, i, o, a) {
  const {
    startEdge: s,
    endEdge: l
  } = e, {
    groupSlides: u
  } = o, c = d().map(t.measure), f = v(), p = h();
  function d() {
    return u(r).map((m) => Dn(m)[l] - m[0][s]).map(et);
  }
  function v() {
    return r.map((m) => n[s] - m[s]).map((m) => -et(m));
  }
  function h() {
    const b = Dn(f) - Dn(i);
    return u(f).map((w) => w[0]).map((w, C, S) => {
      const E = !C, I = C === xs(S);
      return a && E ? 0 : a && I ? b : w + c[C];
    });
  }
  return {
    snaps: f,
    snapsAligned: p
  };
}
function $A(e, t, n, r, i) {
  const {
    reachedAny: o,
    removeOffset: a,
    constrain: s
  } = r;
  function l(v) {
    return v.concat().sort((h, g) => et(h) - et(g))[0];
  }
  function u(v) {
    const h = e ? a(v) : s(v), g = t.map((b) => b - h).map((b) => c(b, 0)).map((b, w) => ({
      diff: b,
      index: w
    })).sort((b, w) => et(b.diff) - et(w.diff)), {
      index: m
    } = g[0];
    return {
      index: m,
      distance: h
    };
  }
  function c(v, h) {
    const g = [v, v + n, v - n];
    if (!e) return g[0];
    if (!h) return l(g);
    const m = g.filter((b) => Bf(b) === h);
    return l(m);
  }
  function f(v, h) {
    const g = t[v] - i.get(), m = c(g, h);
    return {
      index: v,
      distance: m
    };
  }
  function p(v, h) {
    const g = i.get() + v, {
      index: m,
      distance: b
    } = u(g), w = !e && o(g);
    if (!h || w) return {
      index: m,
      distance: v
    };
    const C = t[m] - b, S = v + c(C, 0);
    return {
      index: m,
      distance: S
    };
  }
  return {
    byDistance: p,
    byIndex: f,
    shortcut: c
  };
}
function TA(e, t, n, r, i, o, a) {
  function s(f) {
    const p = f.distance, d = f.index !== t.get();
    o.add(p), p && (i.duration() ? e.start() : (e.update(), e.render(1), e.update())), d && (n.set(t.get()), t.set(f.index), a.emit("select"));
  }
  function l(f, p) {
    const d = r.byDistance(f, p);
    s(d);
  }
  function u(f, p) {
    const d = t.clone().set(f), v = r.byIndex(d.get(), p);
    s(v);
  }
  return {
    distance: l,
    index: u
  };
}
function Ea(e) {
  let t = e;
  function n() {
    return t;
  }
  function r(l) {
    t = a(l);
  }
  function i(l) {
    t += a(l);
  }
  function o(l) {
    t -= a(l);
  }
  function a(l) {
    return Lf(l) ? l : l.get();
  }
  return {
    get: n,
    set: r,
    add: i,
    subtract: o
  };
}
function Rx(e, t, n) {
  const r = e.scroll === "x" ? a : s, i = n.style;
  let o = !1;
  function a(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function s(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function l(p) {
    o || (i.transform = r(t.apply(p)));
  }
  function u(p) {
    o = !p;
  }
  function c() {
    o || (i.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: c,
    to: l,
    toggleActive: u
  };
}
function OA(e, t, n, r, i, o, a, s, l) {
  const u = Zi(i), c = Zi(i).reverse(), f = h().concat(g());
  function p(S, E) {
    return S.reduce((I, N) => I - i[N], E);
  }
  function d(S, E) {
    return S.reduce((I, N) => p(I, E) > 0 ? I.concat([N]) : I, []);
  }
  function v(S, E) {
    const I = E === "start", N = I ? -r : r, A = a.findSlideBounds([N]);
    return S.map((O) => {
      const D = I ? 0 : -r, U = I ? r : 0, M = A.filter((_) => _.index === O)[0][I ? "end" : "start"];
      return {
        index: O,
        slideLocation: Ea(-1),
        translate: Rx(e, t, l[O]),
        target: () => s.get() > M ? D : U
      };
    });
  }
  function h() {
    const S = o[0] - 1, E = d(c, S);
    return v(E, "end");
  }
  function g() {
    const S = n - o[0] - 1, E = d(u, S);
    return v(E, "start");
  }
  function m() {
    return f.every(({
      index: S
    }) => {
      const E = u.filter((I) => I !== S);
      return p(E, n) <= 0.1;
    });
  }
  function b() {
    f.forEach((S) => {
      const {
        target: E,
        translate: I,
        slideLocation: N
      } = S, A = E();
      A !== N.get() && (I.to(A), N.set(A));
    });
  }
  function w() {
    f.forEach((S) => S.translate.clear());
  }
  return {
    canLoop: m,
    clear: w,
    loop: b,
    loopPoints: f
  };
}
function IA(e, t) {
  let n, r = !1;
  function i(s, l) {
    if (!l) return;
    function u(c) {
      for (const f of c)
        if (f.type === "childList") {
          s.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    n = new MutationObserver((c) => {
      r || (Ff(l) || l(s, c)) && u(c);
    }), n.observe(e, {
      childList: !0
    });
  }
  function o() {
    n && n.disconnect(), r = !0;
  }
  return {
    init: i,
    destroy: o
  };
}
function RA(e, t, n, r, i, o, a) {
  const {
    removeOffset: s,
    constrain: l
  } = i, u = 0.5, c = o ? [0, t, -t] : [0], f = d(c, a);
  function p(g) {
    const m = g || 0;
    return n.map((b) => Zn(u, b - u).constrain(b * m));
  }
  function d(g, m) {
    const b = g || c, w = p(m);
    return b.reduce((C, S) => {
      const E = r.map((I, N) => ({
        start: I - n[N] + w[N] + S,
        end: I + e - w[N] + S,
        index: N
      }));
      return C.concat(E);
    }, []);
  }
  function v(g, m) {
    const b = o ? s(g) : l(g);
    return (m || f).reduce((C, S) => {
      const {
        index: E,
        start: I,
        end: N
      } = S, A = C.includes(E), O = I < b && N > b;
      return !A && O ? C.concat([E]) : C;
    }, []);
  }
  return {
    check: v,
    findSlideBounds: d
  };
}
function PA(e, t, n, r, i, o) {
  const {
    measureSize: a,
    startEdge: s,
    endEdge: l
  } = e, u = n[0] && i, c = v(), f = h(), p = n.map(a), d = g();
  function v() {
    if (!u) return 0;
    const b = n[0];
    return et(t[s] - b[s]);
  }
  function h() {
    if (!u) return 0;
    const b = o.getComputedStyle(Dn(r));
    return parseFloat(b.getPropertyValue(`margin-${l}`));
  }
  function g() {
    return n.map((b, w, C) => {
      const S = !w, E = w === xs(C);
      return S ? p[w] + c : E ? p[w] + f : C[w + 1][s] - b[s];
    }).map(et);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: d
  };
}
function AA(e, t, n) {
  const r = Lf(n);
  function i(l, u) {
    return Zi(l).filter((c) => c % u === 0).map((c) => l.slice(c, c + u));
  }
  function o(l) {
    return Zi(l).reduce((u, c) => {
      const p = t.slice(Dn(u), c + 1).reduce((d, v) => d + v, 0);
      return !c || p > e ? u.concat(c) : u;
    }, []).map((u, c, f) => l.slice(u, f[c + 1]));
  }
  function a(l) {
    return r ? i(l, n) : o(l);
  }
  return {
    groupSlides: a
  };
}
function DA(e, t, n, r, i, o, a, s) {
  const {
    align: l,
    axis: u,
    direction: c,
    startIndex: f,
    inViewThreshold: p,
    loop: d,
    duration: v,
    dragFree: h,
    dragThreshold: g,
    slidesToScroll: m,
    skipSnaps: b,
    containScroll: w
  } = o, C = t.getBoundingClientRect(), S = n.map((Se) => Se.getBoundingClientRect()), E = hA(c), I = pA(u, c), N = I.measureSize(C), A = gA(N), O = dA(l, N), D = !d && !!w, U = d || !!w, {
    slideSizes: L,
    slideSizesWithGaps: M
  } = PA(I, C, S, n, U, i), _ = AA(N, M, m), {
    snaps: z,
    snapsAligned: q
  } = CA(I, O, C, S, M, _, D), H = -Dn(z) + Dn(M), {
    snapsContained: P
  } = wA(N, H, q, w), y = D ? P : q, {
    limit: T
  } = SA(H, y, d), j = Ix(xs(y), f, d), x = j.clone(), F = Zi(n), G = ({
    dragHandler: Se,
    scrollBody: Ie,
    scrollBounds: nt,
    eventHandler: St,
    animation: Et,
    options: {
      loop: kt
    }
  }) => {
    const ie = Se.pointerDown();
    kt || nt.constrain(ie);
    const ue = Ie.seek().settled();
    ue && !ie && (Et.stop(), St.emit("settle")), ue || St.emit("scroll");
  }, K = ({
    scrollBody: Se,
    translate: Ie,
    location: nt,
    offsetLocation: St,
    scrollLooper: Et,
    slideLooper: kt,
    options: {
      loop: ie
    }
  }, ue) => {
    const W = Se.velocity();
    St.set(nt.get() - W + W * ue), ie && (Et.loop(Se.direction()), kt.loop()), Ie.to(St.get());
  }, Y = {
    start: () => s.start(pe),
    stop: () => s.stop(pe),
    update: () => G(pe),
    render: (Se) => K(pe, Se)
  }, Q = 0.68, Z = y[j.get()], X = Ea(Z), J = Ea(Z), V = Ea(Z), ne = bA(X, V, v, Q), se = $A(d, y, H, T, V), fe = TA(Y, j, x, se, ne, V, a), oe = RA(N, H, L, z, T, d, p), pe = {
    ownerDocument: r,
    ownerWindow: i,
    eventHandler: a,
    containerRect: C,
    slideRects: S,
    animation: Y,
    axis: I,
    direction: E,
    dragHandler: vA(I, E, e, r, i, V, mA(I, i), X, Y, fe, ne, se, j, a, A, h, g, b, Q),
    eventStore: eo(),
    percentOfView: A,
    index: j,
    indexPrevious: x,
    limit: T,
    location: X,
    offsetLocation: J,
    options: o,
    resizeHandler: yA(t, a, i, n, I),
    scrollBody: ne,
    scrollBounds: xA(T, X, V, ne, A),
    scrollLooper: EA(H, T, J, [X, J, V]),
    scrollProgress: kA(T),
    scrollSnaps: y,
    scrollTarget: se,
    scrollTo: fe,
    slideLooper: OA(I, E, N, H, M, y, oe, J, n),
    slidesHandler: IA(t, a),
    slidesInView: oe,
    slideIndexes: F,
    slidesToScroll: _,
    target: V,
    translate: Rx(I, E, t)
  };
  return pe;
}
function _A(e) {
  const t = 16.666666666666668;
  let n = [], r = null, i = 0, o = 0;
  function a(f) {
    r || (r = f);
    const p = f - r;
    for (r = f, i += p; i >= t; )
      n.forEach(({
        animation: v
      }) => v.update()), i -= t;
    const d = et(i / t);
    n.forEach(({
      animation: v
    }) => v.render(d)), o && e.requestAnimationFrame(a);
  }
  function s(f) {
    n.includes(f) || n.push(f), !o && (o = e.requestAnimationFrame(a));
  }
  function l(f) {
    n = n.filter((p) => p !== f), !n.length && (e.cancelAnimationFrame(o), r = null, i = 0, o = 0);
  }
  function u() {
    r = null, i = 0;
  }
  return {
    start: s,
    stop: l,
    reset: u,
    window: e
  };
}
function MA() {
  const e = {};
  let t;
  function n(l) {
    t = l;
  }
  function r(l) {
    return e[l] || [];
  }
  function i(l) {
    return r(l).forEach((u) => u(t, l)), s;
  }
  function o(l, u) {
    return e[l] = r(l).concat([u]), s;
  }
  function a(l, u) {
    return e[l] = r(l).filter((c) => c !== u), s;
  }
  const s = {
    init: n,
    emit: i,
    off: a,
    on: o
  };
  return s;
}
const jA = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  inViewThreshold: 0,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0
};
function NA(e) {
  function t(o, a) {
    return Tx(o, a || {});
  }
  function n(o) {
    const a = o.breakpoints || {}, s = Wa(a).filter((l) => e.matchMedia(l).matches).map((l) => a[l]).reduce((l, u) => t(l, u), {});
    return t(o, s);
  }
  function r(o) {
    return o.map((a) => Wa(a.breakpoints || {})).reduce((a, s) => a.concat(s), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: r
  };
}
function LA(e) {
  let t = [];
  function n(o, a) {
    return t = o.filter(({
      options: s
    }) => e.optionsAtMedia(s).active !== !1), t.forEach((s) => s.init(a, e)), o.reduce((s, l) => Object.assign(s, {
      [l.name]: l
    }), {});
  }
  function r() {
    t = t.filter((o) => o.destroy());
  }
  return {
    init: n,
    destroy: r
  };
}
function Zr(e, t, n) {
  const r = e.ownerDocument, i = r.defaultView, o = NA(i), a = LA(o), s = eo(), l = eo(), u = MA(), {
    animationRealms: c
  } = Zr, {
    mergeOptions: f,
    optionsAtMedia: p,
    optionsMediaQueries: d
  } = o, {
    on: v,
    off: h,
    emit: g
  } = u, m = L;
  let b = !1, w, C = f(jA, Zr.globalOptions), S = f(C), E = [], I, N, A;
  function O() {
    const {
      container: ne,
      slides: se
    } = S;
    N = (Lh(ne) ? e.querySelector(ne) : ne) || e.children[0];
    const oe = Lh(se) ? N.querySelectorAll(se) : se;
    A = [].slice.call(oe || N.children);
  }
  function D(ne, se) {
    const fe = DA(e, N, A, r, i, ne, u, se);
    if (ne.loop && !fe.slideLooper.canLoop()) {
      const oe = Object.assign({}, ne, {
        loop: !1
      });
      return D(oe, se);
    }
    return fe;
  }
  function U(ne, se) {
    if (b) return;
    const fe = c.find((pe) => pe.window === i), oe = fe || _A(i);
    fe || c.push(oe), C = f(C, ne), S = p(C), E = se || E, O(), w = D(S, oe), d([C, ...E.map(({
      options: pe
    }) => pe)]).forEach((pe) => s.add(pe, "change", L)), S.active && (w.translate.to(w.location.get()), w.eventHandler.init(V), w.resizeHandler.init(V, S.watchResize), w.slidesHandler.init(V, S.watchSlides), l.add(r, "visibilitychange", () => {
      r.hidden && oe.reset();
    }), w.options.loop && w.slideLooper.loop(), N.offsetParent && A.length && w.dragHandler.init(V, S.watchDrag), I = a.init(E, V));
  }
  function L(ne, se) {
    const fe = G();
    M(), U(f({
      startIndex: fe
    }, ne), se), u.emit("reInit");
  }
  function M() {
    w.dragHandler.destroy(), w.animation.stop(), w.eventStore.clear(), w.translate.clear(), w.slideLooper.clear(), w.resizeHandler.destroy(), w.slidesHandler.destroy(), a.destroy(), s.clear(), l.clear();
  }
  function _() {
    b || (b = !0, s.clear(), M(), u.emit("destroy"));
  }
  function z(ne) {
    const se = w[ne ? "target" : "location"].get(), fe = S.loop ? "removeOffset" : "constrain";
    return w.slidesInView.check(w.limit[fe](se));
  }
  function q(ne) {
    const se = z(ne);
    return w.slideIndexes.filter((fe) => !se.includes(fe));
  }
  function H(ne, se, fe) {
    !S.active || b || (w.scrollBody.useBaseFriction().useDuration(se ? 0 : S.duration), w.scrollTo.index(ne, fe || 0));
  }
  function P(ne) {
    const se = w.index.add(1).get();
    H(se, ne === !0, -1);
  }
  function y(ne) {
    const se = w.index.add(-1).get();
    H(se, ne === !0, 1);
  }
  function T() {
    return w.index.add(1).get() !== G();
  }
  function j() {
    return w.index.add(-1).get() !== G();
  }
  function x() {
    return w.scrollSnaps.map(w.scrollProgress.get);
  }
  function F() {
    return w.scrollProgress.get(w.location.get());
  }
  function G() {
    return w.index.get();
  }
  function K() {
    return w.indexPrevious.get();
  }
  function Y() {
    return I;
  }
  function Q() {
    return w;
  }
  function Z() {
    return e;
  }
  function X() {
    return N;
  }
  function J() {
    return A;
  }
  const V = {
    canScrollNext: T,
    canScrollPrev: j,
    containerNode: X,
    internalEngine: Q,
    destroy: _,
    off: h,
    on: v,
    emit: g,
    plugins: Y,
    previousScrollSnap: K,
    reInit: m,
    rootNode: Z,
    scrollNext: P,
    scrollPrev: y,
    scrollProgress: F,
    scrollSnapList: x,
    scrollTo: H,
    selectedScrollSnap: G,
    slideNodes: J,
    slidesInView: z,
    slidesNotInView: q
  };
  return U(t, n), setTimeout(() => u.emit("init"), 0), V;
}
Zr.animationRealms = [];
Zr.globalOptions = void 0;
function zf(e = {}, t = []) {
  const n = Ke(e), r = Ke(t), [i, o] = ge(), [a, s] = ge(), l = Oe(() => {
    i && i.reInit(n.current, r.current);
  }, [i]);
  return vt(() => {
    if (uA() && a) {
      Zr.globalOptions = zf.globalOptions;
      const u = Zr(a, n.current, r.current);
      return o(u), () => u.destroy();
    } else
      o(void 0);
  }, [a, o]), vt(() => {
    Nf(n.current, e) || (n.current = e, l());
  }, [e, l]), vt(() => {
    cA(r.current, t) || (r.current = t, l());
  }, [t, l]), [s, i];
}
zf.globalOptions = void 0;
const Px = Ot(
  ({ blocks: e, direction: t, sender: n, timestamp: r, messageId: i, isReadOnly: o, sendMessage: a, addMessageFeedback: s }, l) => {
    const [u, c] = zf({ skipSnaps: !0, loop: !0 }), [f, p] = ge(!0), [d, v] = ge(!0), h = Oe(() => c == null ? void 0 : c.scrollPrev(), [c]), g = Oe(() => c == null ? void 0 : c.scrollNext(), [c]), {
      message: {
        blocks: { carousel: m }
      }
    } = we, b = Oe((w) => {
      p(!w.canScrollPrev()), v(!w.canScrollNext());
    }, []);
    return vt(() => {
      c && (b(c), c.on("reInit", b), c.on("select", b));
    }, [c, b]), /* @__PURE__ */ $.jsxs("div", { ...m == null ? void 0 : m.container, "data-container": "carousel", ref: u, children: [
      /* @__PURE__ */ $.jsx("div", { ref: l, ...m == null ? void 0 : m.slidesContainer, children: e.map((w, C) => /* @__PURE__ */ $.jsx(ii, { block: { ...w, direction: t, timestamp: r, sender: n, messageId: i, sendMessage: a, isReadOnly: o } }, C)) }),
      e.length > 1 && /* @__PURE__ */ $.jsxs($.Fragment, { children: [
        /* @__PURE__ */ $.jsx(
          iP,
          {
            ...m == null ? void 0 : m.backButton,
            "data-disabled": f ? "" : void 0,
            onClick: h
          }
        ),
        /* @__PURE__ */ $.jsx(
          oP,
          {
            ...m == null ? void 0 : m.nextButton,
            "data-disabled": d ? "" : void 0,
            onClick: g
          }
        )
      ] })
    ] });
  }
);
Px.displayName = "Carousel";
const Bh = Math.floor;
function Ax(e) {
  return Dx(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function mo(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function FA(e) {
  var t;
  return (t = (Dx(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Dx(e) {
  return e instanceof Node || e instanceof mo(e).Node;
}
function Xt(e) {
  return e instanceof Element || e instanceof mo(e).Element;
}
function ei(e) {
  return e instanceof HTMLElement || e instanceof mo(e).HTMLElement;
}
function vc(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof mo(e).ShadowRoot;
}
function BA(e) {
  return ["html", "body", "#document"].includes(Ax(e));
}
function zA(e) {
  return mo(e).getComputedStyle(e);
}
function WA(e) {
  if (Ax(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    vc(e) && e.host || // Fallback.
    FA(e)
  );
  return vc(t) ? t.host : t;
}
function Hn(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var n, r;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function jt(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && vc(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function _x() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function UA() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function Mx(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(_x()) || t.test(UA())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function jx(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function Nx() {
  return /apple/i.test(navigator.vendor);
}
function HA() {
  return _x().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function zh(e, t) {
  return ["mouse", "pen"].includes(e);
}
function VA(e) {
  return "nativeEvent" in e;
}
function KA(e) {
  return e.matches("html,body");
}
function on(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Ol(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function Lx(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const qA = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function Fx(e) {
  return ei(e) && e.matches(qA);
}
function bt(e) {
  e.preventDefault(), e.stopPropagation();
}
const ti = Math.min, Wt = Math.max, Ua = Math.round, Yo = Math.floor, wn = (e) => ({
  x: e,
  y: e
});
function Wh(e, t, n) {
  return Wt(e, ti(t, n));
}
function ws(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function go(e) {
  return e.split("-")[0];
}
function Wf(e) {
  return e.split("-")[1];
}
function Bx(e) {
  return e === "x" ? "y" : "x";
}
function GA(e) {
  return e === "y" ? "height" : "width";
}
function yo(e) {
  return ["top", "bottom"].includes(go(e)) ? "y" : "x";
}
function YA(e) {
  return Bx(yo(e));
}
function XA(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function JA(e) {
  return typeof e != "number" ? XA(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Ha(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function Uh(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = yo(t), a = YA(t), s = GA(a), l = go(t), u = o === "y", c = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, p = r[s] / 2 - i[s] / 2;
  let d;
  switch (l) {
    case "top":
      d = {
        x: c,
        y: r.y - i.height
      };
      break;
    case "bottom":
      d = {
        x: c,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      d = {
        x: r.x - i.width,
        y: f
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      };
  }
  switch (Wf(t)) {
    case "start":
      d[a] -= p * (n && u ? -1 : 1);
      break;
    case "end":
      d[a] += p * (n && u ? -1 : 1);
      break;
  }
  return d;
}
const QA = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: a
  } = n, s = o.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let u = await a.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: c,
    y: f
  } = Uh(u, r, l), p = r, d = {}, v = 0;
  for (let h = 0; h < s.length; h++) {
    const {
      name: g,
      fn: m
    } = s[h], {
      x: b,
      y: w,
      data: C,
      reset: S
    } = await m({
      x: c,
      y: f,
      initialPlacement: r,
      placement: p,
      strategy: i,
      middlewareData: d,
      rects: u,
      platform: a,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = b ?? c, f = w ?? f, d = {
      ...d,
      [g]: {
        ...d[g],
        ...C
      }
    }, S && v <= 50 && (v++, typeof S == "object" && (S.placement && (p = S.placement), S.rects && (u = S.rects === !0 ? await a.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : S.rects), {
      x: c,
      y: f
    } = Uh(u, p, l)), h = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: i,
    middlewareData: d
  };
};
async function zx(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: a,
    elements: s,
    strategy: l
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: d = 0
  } = ws(t, e), v = JA(d), g = s[p ? f === "floating" ? "reference" : "floating" : f], m = Ha(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(g))) == null || n ? g : g.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(s.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), b = f === "floating" ? {
    x: r,
    y: i,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, w = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(s.floating)), C = await (o.isElement == null ? void 0 : o.isElement(w)) ? await (o.getScale == null ? void 0 : o.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = Ha(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: b,
    offsetParent: w,
    strategy: l
  }) : b);
  return {
    top: (m.top - S.top + v.top) / C.y,
    bottom: (S.bottom - m.bottom + v.bottom) / C.y,
    left: (m.left - S.left + v.left) / C.x,
    right: (S.right - m.right + v.right) / C.x
  };
}
async function ZA(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), a = go(n), s = Wf(n), l = yo(n) === "y", u = ["left", "top"].includes(a) ? -1 : 1, c = o && l ? -1 : 1, f = ws(t, e);
  let {
    mainAxis: p,
    crossAxis: d,
    alignmentAxis: v
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return s && typeof v == "number" && (d = s === "end" ? v * -1 : v), l ? {
    x: d * c,
    y: p * u
  } : {
    x: p * u,
    y: d * c
  };
}
const eD = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: a,
        middlewareData: s
      } = t, l = await ZA(t, e);
      return a === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: i + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, tD = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: o = !0,
        crossAxis: a = !1,
        limiter: s = {
          fn: (g) => {
            let {
              x: m,
              y: b
            } = g;
            return {
              x: m,
              y: b
            };
          }
        },
        ...l
      } = ws(e, t), u = {
        x: n,
        y: r
      }, c = await zx(t, l), f = yo(go(i)), p = Bx(f);
      let d = u[p], v = u[f];
      if (o) {
        const g = p === "y" ? "top" : "left", m = p === "y" ? "bottom" : "right", b = d + c[g], w = d - c[m];
        d = Wh(b, d, w);
      }
      if (a) {
        const g = f === "y" ? "top" : "left", m = f === "y" ? "bottom" : "right", b = v + c[g], w = v - c[m];
        v = Wh(b, v, w);
      }
      const h = s.fn({
        ...t,
        [p]: d,
        [f]: v
      });
      return {
        ...h,
        data: {
          x: h.x - n,
          y: h.y - r,
          enabled: {
            [p]: o,
            [f]: a
          }
        }
      };
    }
  };
}, nD = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: o,
        platform: a,
        elements: s
      } = t, {
        apply: l = () => {
        },
        ...u
      } = ws(e, t), c = await zx(t, u), f = go(i), p = Wf(i), d = yo(i) === "y", {
        width: v,
        height: h
      } = o.floating;
      let g, m;
      f === "top" || f === "bottom" ? (g = f, m = p === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (m = f, g = p === "end" ? "top" : "bottom");
      const b = h - c.top - c.bottom, w = v - c.left - c.right, C = ti(h - c[g], b), S = ti(v - c[m], w), E = !t.middlewareData.shift;
      let I = C, N = S;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (N = w), (r = t.middlewareData.shift) != null && r.enabled.y && (I = b), E && !p) {
        const O = Wt(c.left, 0), D = Wt(c.right, 0), U = Wt(c.top, 0), L = Wt(c.bottom, 0);
        d ? N = v - 2 * (O !== 0 || D !== 0 ? O + D : Wt(c.left, c.right)) : I = h - 2 * (U !== 0 || L !== 0 ? U + L : Wt(c.top, c.bottom));
      }
      await l({
        ...t,
        availableWidth: N,
        availableHeight: I
      });
      const A = await a.getDimensions(s.floating);
      return v !== A.width || h !== A.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ss() {
  return typeof window < "u";
}
function mi(e) {
  return Wx(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ut(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Cn(e) {
  var t;
  return (t = (Wx(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Wx(e) {
  return Ss() ? e instanceof Node || e instanceof Ut(e).Node : !1;
}
function un(e) {
  return Ss() ? e instanceof Element || e instanceof Ut(e).Element : !1;
}
function En(e) {
  return Ss() ? e instanceof HTMLElement || e instanceof Ut(e).HTMLElement : !1;
}
function Hh(e) {
  return !Ss() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ut(e).ShadowRoot;
}
function bo(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = cn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function rD(e) {
  return ["table", "td", "th"].includes(mi(e));
}
function Es(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Uf(e) {
  const t = Hf(), n = un(e) ? cn(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function iD(e) {
  let t = er(e);
  for (; En(t) && !ni(t); ) {
    if (Uf(t))
      return t;
    if (Es(t))
      return null;
    t = er(t);
  }
  return null;
}
function Hf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ni(e) {
  return ["html", "body", "#document"].includes(mi(e));
}
function cn(e) {
  return Ut(e).getComputedStyle(e);
}
function ks(e) {
  return un(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function er(e) {
  if (mi(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Hh(e) && e.host || // Fallback.
    Cn(e)
  );
  return Hh(t) ? t.host : t;
}
function Ux(e) {
  const t = er(e);
  return ni(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : En(t) && bo(t) ? t : Ux(t);
}
function qn(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = Ux(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), a = Ut(i);
  if (o) {
    const s = mc(a);
    return t.concat(a, a.visualViewport || [], bo(i) ? i : [], s && n ? qn(s) : []);
  }
  return t.concat(i, qn(i, [], n));
}
function mc(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Hx(e) {
  const t = cn(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = En(e), o = i ? e.offsetWidth : n, a = i ? e.offsetHeight : r, s = Ua(n) !== o || Ua(r) !== a;
  return s && (n = o, r = a), {
    width: n,
    height: r,
    $: s
  };
}
function Vf(e) {
  return un(e) ? e : e.contextElement;
}
function qr(e) {
  const t = Vf(e);
  if (!En(t))
    return wn(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = Hx(t);
  let a = (o ? Ua(n.width) : n.width) / r, s = (o ? Ua(n.height) : n.height) / i;
  return (!a || !Number.isFinite(a)) && (a = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: a,
    y: s
  };
}
const oD = /* @__PURE__ */ wn(0);
function Vx(e) {
  const t = Ut(e);
  return !Hf() || !t.visualViewport ? oD : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function aD(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Ut(e) ? !1 : t;
}
function yr(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = Vf(e);
  let a = wn(1);
  t && (r ? un(r) && (a = qr(r)) : a = qr(e));
  const s = aD(o, n, r) ? Vx(o) : wn(0);
  let l = (i.left + s.x) / a.x, u = (i.top + s.y) / a.y, c = i.width / a.x, f = i.height / a.y;
  if (o) {
    const p = Ut(o), d = r && un(r) ? Ut(r) : r;
    let v = p, h = mc(v);
    for (; h && r && d !== v; ) {
      const g = qr(h), m = h.getBoundingClientRect(), b = cn(h), w = m.left + (h.clientLeft + parseFloat(b.paddingLeft)) * g.x, C = m.top + (h.clientTop + parseFloat(b.paddingTop)) * g.y;
      l *= g.x, u *= g.y, c *= g.x, f *= g.y, l += w, u += C, v = Ut(h), h = mc(v);
    }
  }
  return Ha({
    width: c,
    height: f,
    x: l,
    y: u
  });
}
function Kf(e, t) {
  const n = ks(e).scrollLeft;
  return t ? t.left + n : yr(Cn(e)).left + n;
}
function Kx(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Kf(e, r)
  )), o = r.top + t.scrollTop;
  return {
    x: i,
    y: o
  };
}
function sD(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const o = i === "fixed", a = Cn(r), s = t ? Es(t.floating) : !1;
  if (r === a || s && o)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = wn(1);
  const c = wn(0), f = En(r);
  if ((f || !f && !o) && ((mi(r) !== "body" || bo(a)) && (l = ks(r)), En(r))) {
    const d = yr(r);
    u = qr(r), c.x = d.x + r.clientLeft, c.y = d.y + r.clientTop;
  }
  const p = a && !f && !o ? Kx(a, l, !0) : wn(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - l.scrollLeft * u.x + c.x + p.x,
    y: n.y * u.y - l.scrollTop * u.y + c.y + p.y
  };
}
function lD(e) {
  return Array.from(e.getClientRects());
}
function uD(e) {
  const t = Cn(e), n = ks(e), r = e.ownerDocument.body, i = Wt(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = Wt(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let a = -n.scrollLeft + Kf(e);
  const s = -n.scrollTop;
  return cn(r).direction === "rtl" && (a += Wt(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: a,
    y: s
  };
}
function cD(e, t) {
  const n = Ut(e), r = Cn(e), i = n.visualViewport;
  let o = r.clientWidth, a = r.clientHeight, s = 0, l = 0;
  if (i) {
    o = i.width, a = i.height;
    const u = Hf();
    (!u || u && t === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: o,
    height: a,
    x: s,
    y: l
  };
}
function fD(e, t) {
  const n = yr(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = En(e) ? qr(e) : wn(1), a = e.clientWidth * o.x, s = e.clientHeight * o.y, l = i * o.x, u = r * o.y;
  return {
    width: a,
    height: s,
    x: l,
    y: u
  };
}
function Vh(e, t, n) {
  let r;
  if (t === "viewport")
    r = cD(e, n);
  else if (t === "document")
    r = uD(Cn(e));
  else if (un(t))
    r = fD(t, n);
  else {
    const i = Vx(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return Ha(r);
}
function qx(e, t) {
  const n = er(e);
  return n === t || !un(n) || ni(n) ? !1 : cn(n).position === "fixed" || qx(n, t);
}
function dD(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = qn(e, [], !1).filter((s) => un(s) && mi(s) !== "body"), i = null;
  const o = cn(e).position === "fixed";
  let a = o ? er(e) : e;
  for (; un(a) && !ni(a); ) {
    const s = cn(a), l = Uf(a);
    !l && s.position === "fixed" && (i = null), (o ? !l && !i : !l && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || bo(a) && !l && qx(e, a)) ? r = r.filter((c) => c !== a) : i = s, a = er(a);
  }
  return t.set(e, r), r;
}
function pD(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const a = [...n === "clippingAncestors" ? Es(t) ? [] : dD(t, this._c) : [].concat(n), r], s = a[0], l = a.reduce((u, c) => {
    const f = Vh(t, c, i);
    return u.top = Wt(f.top, u.top), u.right = ti(f.right, u.right), u.bottom = ti(f.bottom, u.bottom), u.left = Wt(f.left, u.left), u;
  }, Vh(t, s, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function hD(e) {
  const {
    width: t,
    height: n
  } = Hx(e);
  return {
    width: t,
    height: n
  };
}
function vD(e, t, n) {
  const r = En(t), i = Cn(t), o = n === "fixed", a = yr(e, !0, o, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = wn(0);
  function u() {
    l.x = Kf(i);
  }
  if (r || !r && !o)
    if ((mi(t) !== "body" || bo(i)) && (s = ks(t)), r) {
      const d = yr(t, !0, o, t);
      l.x = d.x + t.clientLeft, l.y = d.y + t.clientTop;
    } else i && u();
  o && !r && i && u();
  const c = i && !r && !o ? Kx(i, s) : wn(0), f = a.left + s.scrollLeft - l.x - c.x, p = a.top + s.scrollTop - l.y - c.y;
  return {
    x: f,
    y: p,
    width: a.width,
    height: a.height
  };
}
function Il(e) {
  return cn(e).position === "static";
}
function Kh(e, t) {
  if (!En(e) || cn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Cn(e) === n && (n = n.ownerDocument.body), n;
}
function Gx(e, t) {
  const n = Ut(e);
  if (Es(e))
    return n;
  if (!En(e)) {
    let i = er(e);
    for (; i && !ni(i); ) {
      if (un(i) && !Il(i))
        return i;
      i = er(i);
    }
    return n;
  }
  let r = Kh(e, t);
  for (; r && rD(r) && Il(r); )
    r = Kh(r, t);
  return r && ni(r) && Il(r) && !Uf(r) ? n : r || iD(e) || n;
}
const mD = async function(e) {
  const t = this.getOffsetParent || Gx, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: vD(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function gD(e) {
  return cn(e).direction === "rtl";
}
const yD = {
  convertOffsetParentRelativeRectToViewportRelativeRect: sD,
  getDocumentElement: Cn,
  getClippingRect: pD,
  getOffsetParent: Gx,
  getElementRects: mD,
  getClientRects: lD,
  getDimensions: hD,
  getScale: qr,
  isElement: un,
  isRTL: gD
};
function Yx(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function bD(e, t) {
  let n = null, r;
  const i = Cn(e);
  function o() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function a(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), o();
    const u = e.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: d
    } = u;
    if (s || t(), !p || !d)
      return;
    const v = Yo(f), h = Yo(i.clientWidth - (c + p)), g = Yo(i.clientHeight - (f + d)), m = Yo(c), w = {
      rootMargin: -v + "px " + -h + "px " + -g + "px " + -m + "px",
      threshold: Wt(0, ti(1, l)) || 1
    };
    let C = !0;
    function S(E) {
      const I = E[0].intersectionRatio;
      if (I !== l) {
        if (!C)
          return a();
        I ? a(!1, I) : r = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      I === 1 && !Yx(u, e.getBoundingClientRect()) && a(), C = !1;
    }
    try {
      n = new IntersectionObserver(S, {
        ...w,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, w);
    }
    n.observe(e);
  }
  return a(!0), o;
}
function xD(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, u = Vf(e), c = i || o ? [...u ? qn(u) : [], ...qn(t)] : [];
  c.forEach((m) => {
    i && m.addEventListener("scroll", n, {
      passive: !0
    }), o && m.addEventListener("resize", n);
  });
  const f = u && s ? bD(u, n) : null;
  let p = -1, d = null;
  a && (d = new ResizeObserver((m) => {
    let [b] = m;
    b && b.target === u && d && (d.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var w;
      (w = d) == null || w.observe(t);
    })), n();
  }), u && !l && d.observe(u), d.observe(t));
  let v, h = l ? yr(e) : null;
  l && g();
  function g() {
    const m = yr(e);
    h && !Yx(h, m) && n(), h = m, v = requestAnimationFrame(g);
  }
  return n(), () => {
    var m;
    c.forEach((b) => {
      i && b.removeEventListener("scroll", n), o && b.removeEventListener("resize", n);
    }), f == null || f(), (m = d) == null || m.disconnect(), d = null, l && cancelAnimationFrame(v);
  };
}
const wD = eD, SD = tD, ED = nD, kD = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: yD,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return QA(e, t, {
    ...i,
    platform: o
  });
};
var ka = typeof document < "u" ? fi : vt;
function Va(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Va(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !Va(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Xx(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function qh(e, t) {
  const n = Xx(e);
  return Math.round(t * n) / n;
}
function Rl(e) {
  const t = k.useRef(e);
  return ka(() => {
    t.current = e;
  }), t;
}
function CD(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: a
    } = {},
    transform: s = !0,
    whileElementsMounted: l,
    open: u
  } = e, [c, f] = k.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, d] = k.useState(r);
  Va(p, r) || d(r);
  const [v, h] = k.useState(null), [g, m] = k.useState(null), b = k.useCallback((H) => {
    H !== E.current && (E.current = H, h(H));
  }, []), w = k.useCallback((H) => {
    H !== I.current && (I.current = H, m(H));
  }, []), C = o || v, S = a || g, E = k.useRef(null), I = k.useRef(null), N = k.useRef(c), A = l != null, O = Rl(l), D = Rl(i), U = Rl(u), L = k.useCallback(() => {
    if (!E.current || !I.current)
      return;
    const H = {
      placement: t,
      strategy: n,
      middleware: p
    };
    D.current && (H.platform = D.current), kD(E.current, I.current, H).then((P) => {
      const y = {
        ...P,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: U.current !== !1
      };
      M.current && !Va(N.current, y) && (N.current = y, _y.flushSync(() => {
        f(y);
      }));
    });
  }, [p, t, n, D, U]);
  ka(() => {
    u === !1 && N.current.isPositioned && (N.current.isPositioned = !1, f((H) => ({
      ...H,
      isPositioned: !1
    })));
  }, [u]);
  const M = k.useRef(!1);
  ka(() => (M.current = !0, () => {
    M.current = !1;
  }), []), ka(() => {
    if (C && (E.current = C), S && (I.current = S), C && S) {
      if (O.current)
        return O.current(C, S, L);
      L();
    }
  }, [C, S, L, O, A]);
  const _ = k.useMemo(() => ({
    reference: E,
    floating: I,
    setReference: b,
    setFloating: w
  }), [b, w]), z = k.useMemo(() => ({
    reference: C,
    floating: S
  }), [C, S]), q = k.useMemo(() => {
    const H = {
      position: n,
      left: 0,
      top: 0
    };
    if (!z.floating)
      return H;
    const P = qh(z.floating, c.x), y = qh(z.floating, c.y);
    return s ? {
      ...H,
      transform: "translate(" + P + "px, " + y + "px)",
      ...Xx(z.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: P,
      top: y
    };
  }, [n, s, z.floating, c.x, c.y]);
  return k.useMemo(() => ({
    ...c,
    update: L,
    refs: _,
    elements: z,
    floatingStyles: q
  }), [c, L, _, z, q]);
}
const $D = (e, t) => ({
  ...wD(e),
  options: [e, t]
}), TD = (e, t) => ({
  ...SD(e),
  options: [e, t]
}), OD = (e, t) => ({
  ...ED(e),
  options: [e, t]
});
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var ID = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], gc = /* @__PURE__ */ ID.join(","), Jx = typeof Element > "u", to = Jx ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Ka = !Jx && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, qa = function e(t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"), o = i === "" || i === "true", a = o || n && t && e(t.parentNode);
  return a;
}, RD = function(t) {
  var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return r === "" || r === "true";
}, PD = function(t, n, r) {
  if (qa(t))
    return [];
  var i = Array.prototype.slice.apply(t.querySelectorAll(gc));
  return n && to.call(t, gc) && i.unshift(t), i = i.filter(r), i;
}, AD = function e(t, n, r) {
  for (var i = [], o = Array.from(t); o.length; ) {
    var a = o.shift();
    if (!qa(a, !1))
      if (a.tagName === "SLOT") {
        var s = a.assignedElements(), l = s.length ? s : a.children, u = e(l, !0, r);
        r.flatten ? i.push.apply(i, u) : i.push({
          scopeParent: a,
          candidates: u
        });
      } else {
        var c = to.call(a, gc);
        c && r.filter(a) && (n || !t.includes(a)) && i.push(a);
        var f = a.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(a), p = !qa(f, !1) && (!r.shadowRootFilter || r.shadowRootFilter(a));
        if (f && p) {
          var d = e(f === !0 ? a.children : f.children, !0, r);
          r.flatten ? i.push.apply(i, d) : i.push({
            scopeParent: a,
            candidates: d
          });
        } else
          o.unshift.apply(o, a.children);
      }
  }
  return i;
}, Qx = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, Zx = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || RD(t)) && !Qx(t) ? 0 : t.tabIndex;
}, DD = function(t, n) {
  var r = Zx(t);
  return r < 0 && n && !Qx(t) ? 0 : r;
}, _D = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, ew = function(t) {
  return t.tagName === "INPUT";
}, MD = function(t) {
  return ew(t) && t.type === "hidden";
}, jD = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, ND = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, LD = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || Ka(t), r = function(s) {
    return n.querySelectorAll('input[type="radio"][name="' + s + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(t.name));
  else
    try {
      i = r(t.name);
    } catch (a) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1;
    }
  var o = ND(i, t.form);
  return !o || o === t;
}, FD = function(t) {
  return ew(t) && t.type === "radio";
}, BD = function(t) {
  return FD(t) && !LD(t);
}, zD = function(t) {
  var n, r = t && Ka(t), i = (n = r) === null || n === void 0 ? void 0 : n.host, o = !1;
  if (r && r !== t) {
    var a, s, l;
    for (o = !!((a = i) !== null && a !== void 0 && (s = a.ownerDocument) !== null && s !== void 0 && s.contains(i) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !o && i; ) {
      var u, c, f;
      r = Ka(i), i = (u = r) === null || u === void 0 ? void 0 : u.host, o = !!((c = i) !== null && c !== void 0 && (f = c.ownerDocument) !== null && f !== void 0 && f.contains(i));
    }
  }
  return o;
}, Gh = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, WD = function(t, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var o = to.call(t, "details>summary:first-of-type"), a = o ? t.parentElement : t;
  if (to.call(a, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof i == "function") {
      for (var s = t; t; ) {
        var l = t.parentElement, u = Ka(t);
        if (l && !l.shadowRoot && i(l) === !0)
          return Gh(t);
        t.assignedSlot ? t = t.assignedSlot : !l && u !== t.ownerDocument ? t = u.host : t = l;
      }
      t = s;
    }
    if (zD(t))
      return !t.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return Gh(t);
  return !1;
}, UD = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return to.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, HD = function(t, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  qa(n) || MD(n) || WD(n, t) || // For a details element with a summary, the summary element gets the focus
  jD(n) || UD(n));
}, Yh = function(t, n) {
  return !(BD(n) || Zx(n) < 0 || !HD(t, n));
}, VD = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, KD = function e(t) {
  var n = [], r = [];
  return t.forEach(function(i, o) {
    var a = !!i.scopeParent, s = a ? i.scopeParent : i, l = DD(s, a), u = a ? e(i.candidates) : s;
    l === 0 ? a ? n.push.apply(n, u) : n.push(s) : r.push({
      documentOrder: o,
      tabIndex: l,
      item: i,
      isScope: a,
      content: u
    });
  }), r.sort(_D).reduce(function(i, o) {
    return o.isScope ? i.push.apply(i, o.content) : i.push(o.content), i;
  }, []).concat(n);
}, qf = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = AD([t], n.includeContainer, {
    filter: Yh.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: VD
  }) : r = PD(t, n.includeContainer, Yh.bind(null, n)), KD(r);
};
const Gf = "ArrowUp", Cs = "ArrowDown", ri = "ArrowLeft", xo = "ArrowRight";
function Xo(e, t, n) {
  return Math.floor(e / t) !== n;
}
function Ki(e, t) {
  return t < 0 || t >= e.current.length;
}
function Pl(e, t) {
  return $t(e, {
    disabledIndices: t
  });
}
function Xh(e, t) {
  return $t(e, {
    decrement: !0,
    startingIndex: e.current.length,
    disabledIndices: t
  });
}
function $t(e, t) {
  let {
    startingIndex: n = -1,
    decrement: r = !1,
    disabledIndices: i,
    amount: o = 1
  } = t === void 0 ? {} : t;
  const a = e.current;
  let s = n;
  do {
    var l, u;
    s = s + (r ? -o : o);
  } while (s >= 0 && s <= a.length - 1 && (i ? i.includes(s) : a[s] == null || (l = a[s]) != null && l.hasAttribute("disabled") || ((u = a[s]) == null ? void 0 : u.getAttribute("aria-disabled")) === "true"));
  return s;
}
function qD(e, t) {
  let {
    event: n,
    orientation: r,
    loop: i,
    cols: o,
    disabledIndices: a,
    minIndex: s,
    maxIndex: l,
    prevIndex: u,
    stopEvent: c = !1
  } = t, f = u;
  if (n.key === Gf) {
    if (c && bt(n), u === -1)
      f = l;
    else if (f = $t(e, {
      startingIndex: f,
      amount: o,
      decrement: !0,
      disabledIndices: a
    }), i && (u - o < s || f < 0)) {
      const p = u % o, d = l % o, v = l - (d - p);
      d === p ? f = l : f = d > p ? v : v - o;
    }
    Ki(e, f) && (f = u);
  }
  if (n.key === Cs && (c && bt(n), u === -1 ? f = s : (f = $t(e, {
    startingIndex: u,
    amount: o,
    disabledIndices: a
  }), i && u + o > l && (f = $t(e, {
    startingIndex: u % o - o,
    amount: o,
    disabledIndices: a
  }))), Ki(e, f) && (f = u)), r === "both") {
    const p = Bh(u / o);
    n.key === xo && (c && bt(n), u % o !== o - 1 ? (f = $t(e, {
      startingIndex: u,
      disabledIndices: a
    }), i && Xo(f, o, p) && (f = $t(e, {
      startingIndex: u - u % o - 1,
      disabledIndices: a
    }))) : i && (f = $t(e, {
      startingIndex: u - u % o - 1,
      disabledIndices: a
    })), Xo(f, o, p) && (f = u)), n.key === ri && (c && bt(n), u % o !== 0 ? (f = $t(e, {
      startingIndex: u,
      disabledIndices: a,
      decrement: !0
    }), i && Xo(f, o, p) && (f = $t(e, {
      startingIndex: u + (o - u % o),
      decrement: !0,
      disabledIndices: a
    }))) : i && (f = $t(e, {
      startingIndex: u + (o - u % o),
      decrement: !0,
      disabledIndices: a
    })), Xo(f, o, p) && (f = u));
    const d = Bh(l / o) === p;
    Ki(e, f) && (i && d ? f = n.key === ri ? l : $t(e, {
      startingIndex: u - u % o - 1,
      disabledIndices: a
    }) : f = u);
  }
  return f;
}
let Jh = 0;
function An(e, t) {
  t === void 0 && (t = {});
  const {
    preventScroll: n = !1,
    cancelPrevious: r = !0,
    sync: i = !1
  } = t;
  r && cancelAnimationFrame(Jh);
  const o = () => e == null ? void 0 : e.focus({
    preventScroll: n
  });
  i ? o() : Jh = requestAnimationFrame(o);
}
var ct = typeof document < "u" ? fi : vt;
function Ga() {
  return Ga = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ga.apply(this, arguments);
}
let Al = !1, GD = 0;
const Qh = () => "floating-ui-" + GD++;
function YD() {
  const [e, t] = k.useState(() => Al ? Qh() : void 0);
  return ct(() => {
    e == null && t(Qh());
  }, []), k.useEffect(() => {
    Al || (Al = !0);
  }, []), e;
}
const XD = k.useId, Yf = XD || YD;
function JD() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((i) => i(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var r;
      e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((i) => i !== n)) || []);
    }
  };
}
const QD = /* @__PURE__ */ k.createContext(null), ZD = /* @__PURE__ */ k.createContext(null), tw = () => {
  var e;
  return ((e = k.useContext(QD)) == null ? void 0 : e.id) || null;
}, $s = () => k.useContext(ZD);
function no(e) {
  return "data-floating-ui-" + e;
}
function Gn(e) {
  const t = Ke(e);
  return ct(() => {
    t.current = e;
  }), t;
}
function e_(e, t) {
  var n;
  let r = [], i = (n = e.find((o) => o.id === t)) == null ? void 0 : n.parentId;
  for (; i; ) {
    const o = e.find((a) => a.id === i);
    i = o == null ? void 0 : o.parentId, o && (r = r.concat(o));
  }
  return r;
}
function Gr(e, t) {
  let n = e.filter((i) => {
    var o;
    return i.parentId === t && ((o = i.context) == null ? void 0 : o.open);
  }), r = n;
  for (; r.length; )
    r = e.filter((i) => {
      var o;
      return (o = r) == null ? void 0 : o.some((a) => {
        var s;
        return i.parentId === a.id && ((s = i.context) == null ? void 0 : s.open);
      });
    }), n = n.concat(r);
  return n;
}
function t_(e, t) {
  let n, r = -1;
  function i(o, a) {
    a > r && (n = o, r = a), Gr(e, o).forEach((l) => {
      i(l.id, a + 1);
    });
  }
  return i(t, 0), e.find((o) => o.id === n);
}
let Ir = /* @__PURE__ */ new WeakMap(), Jo = /* @__PURE__ */ new WeakSet(), Qo = {}, Dl = 0;
const n_ = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, nw = (e) => e && (e.host || nw(e.parentNode)), r_ = (e, t) => t.map((n) => {
  if (e.contains(n))
    return n;
  const r = nw(n);
  return e.contains(r) ? r : null;
}).filter((n) => n != null);
function i_(e, t, n, r) {
  const i = "data-floating-ui-inert", o = r ? "inert" : n ? "aria-hidden" : null, a = r_(t, e), s = /* @__PURE__ */ new Set(), l = new Set(a), u = [];
  Qo[i] || (Qo[i] = /* @__PURE__ */ new WeakMap());
  const c = Qo[i];
  a.forEach(f), p(t), s.clear();
  function f(d) {
    !d || s.has(d) || (s.add(d), d.parentNode && f(d.parentNode));
  }
  function p(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, (v) => {
      if (s.has(v))
        p(v);
      else {
        const h = o ? v.getAttribute(o) : null, g = h !== null && h !== "false", m = (Ir.get(v) || 0) + 1, b = (c.get(v) || 0) + 1;
        Ir.set(v, m), c.set(v, b), u.push(v), m === 1 && g && Jo.add(v), b === 1 && v.setAttribute(i, ""), !g && o && v.setAttribute(o, "true");
      }
    });
  }
  return Dl++, () => {
    u.forEach((d) => {
      const v = (Ir.get(d) || 0) - 1, h = (c.get(d) || 0) - 1;
      Ir.set(d, v), c.set(d, h), v || (!Jo.has(d) && o && d.removeAttribute(o), Jo.delete(d)), h || d.removeAttribute(i);
    }), Dl--, Dl || (Ir = /* @__PURE__ */ new WeakMap(), Ir = /* @__PURE__ */ new WeakMap(), Jo = /* @__PURE__ */ new WeakSet(), Qo = {});
  };
}
function Zh(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = on(e[0]).body;
  return i_(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const Xf = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function rw(e, t) {
  const n = qf(e, Xf());
  t === "prev" && n.reverse();
  const r = n.indexOf(Hn(on(e)));
  return n.slice(r + 1)[0];
}
function iw() {
  return rw(document.body, "next");
}
function ow() {
  return rw(document.body, "prev");
}
function qi(e, t) {
  const n = t || e.currentTarget, r = e.relatedTarget;
  return !r || !jt(n, r);
}
function o_(e) {
  qf(e, Xf()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function a_(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
const Jf = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let s_;
function ev(e) {
  e.key === "Tab" && (e.target, clearTimeout(s_));
}
const Ya = /* @__PURE__ */ k.forwardRef(function(t, n) {
  const [r, i] = k.useState();
  ct(() => (Nx() && i("button"), document.addEventListener("keydown", ev), () => {
    document.removeEventListener("keydown", ev);
  }), []);
  const o = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [no("focus-guard")]: "",
    style: Jf
  };
  return /* @__PURE__ */ k.createElement("span", Ga({}, t, o));
}), aw = /* @__PURE__ */ k.createContext(null);
function l_(e) {
  let {
    id: t,
    root: n
  } = e === void 0 ? {} : e;
  const [r, i] = k.useState(null), o = Yf(), a = sw(), s = k.useMemo(() => ({
    id: t,
    root: n,
    portalContext: a,
    uniqueId: o
  }), [t, n, a, o]), l = k.useRef();
  return ct(() => () => {
    r == null || r.remove();
  }, [r, s]), ct(() => {
    if (l.current === s) return;
    l.current = s;
    const {
      id: u,
      root: c,
      portalContext: f,
      uniqueId: p
    } = s, d = u ? document.getElementById(u) : null, v = no("portal");
    if (d) {
      const h = document.createElement("div");
      h.id = p, h.setAttribute(v, ""), d.appendChild(h), i(h);
    } else {
      let h = c || (f == null ? void 0 : f.portalNode);
      h && !Xt(h) && (h = h.current), h = h || document.body;
      let g = null;
      u && (g = document.createElement("div"), g.id = u, h.appendChild(g));
      const m = document.createElement("div");
      m.id = p, m.setAttribute(v, ""), h = g || h, h.appendChild(m), i(m);
    }
  }, [s]), r;
}
function u_(e) {
  let {
    children: t,
    id: n,
    root: r = null,
    preserveTabOrder: i = !0
  } = e;
  const o = l_({
    id: n,
    root: r
  }), [a, s] = k.useState(null), l = k.useRef(null), u = k.useRef(null), c = k.useRef(null), f = k.useRef(null), p = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!a && // Guards are only for non-modal focus management.
    !a.modal && // Don't render if unmount is transitioning.
    a.open && i && !!(r || o)
  );
  return k.useEffect(() => {
    if (!o || !i || a != null && a.modal)
      return;
    function d(v) {
      o && qi(v) && (v.type === "focusin" ? a_ : o_)(o);
    }
    return o.addEventListener("focusin", d, !0), o.addEventListener("focusout", d, !0), () => {
      o.removeEventListener("focusin", d, !0), o.removeEventListener("focusout", d, !0);
    };
  }, [o, i, a == null ? void 0 : a.modal]), /* @__PURE__ */ k.createElement(aw.Provider, {
    value: k.useMemo(() => ({
      preserveTabOrder: i,
      beforeOutsideRef: l,
      afterOutsideRef: u,
      beforeInsideRef: c,
      afterInsideRef: f,
      portalNode: o,
      setFocusManagerState: s
    }), [i, o])
  }, p && o && /* @__PURE__ */ k.createElement(Ya, {
    "data-type": "outside",
    ref: l,
    onFocus: (d) => {
      if (qi(d, o)) {
        var v;
        (v = c.current) == null || v.focus();
      } else {
        const h = ow() || (a == null ? void 0 : a.refs.domReference.current);
        h == null || h.focus();
      }
    }
  }), p && o && /* @__PURE__ */ k.createElement("span", {
    "aria-owns": o.id,
    style: Jf
  }), o && /* @__PURE__ */ dE(t, o), p && o && /* @__PURE__ */ k.createElement(Ya, {
    "data-type": "outside",
    ref: u,
    onFocus: (d) => {
      if (qi(d, o)) {
        var v;
        (v = f.current) == null || v.focus();
      } else {
        const h = iw() || (a == null ? void 0 : a.refs.domReference.current);
        h == null || h.focus(), a != null && a.closeOnFocusOut && (a == null || a.onOpenChange(!1, d.nativeEvent));
      }
    }
  }));
}
const sw = () => k.useContext(aw), c_ = /* @__PURE__ */ k.forwardRef(function(t, n) {
  return /* @__PURE__ */ k.createElement("button", Ga({}, t, {
    type: "button",
    ref: n,
    tabIndex: -1,
    style: Jf
  }));
});
function f_(e) {
  const {
    context: t,
    children: n,
    disabled: r = !1,
    order: i = ["content"],
    guards: o = !0,
    initialFocus: a = 0,
    returnFocus: s = !0,
    modal: l = !0,
    visuallyHiddenDismiss: u = !1,
    closeOnFocusOut: c = !0
  } = e, {
    open: f,
    refs: p,
    nodeId: d,
    onOpenChange: v,
    events: h,
    dataRef: g,
    elements: {
      domReference: m,
      floating: b
    }
  } = t, w = n_() ? o : !0, C = Gn(i), S = Gn(a), E = Gn(s), I = $s(), N = sw(), A = typeof a == "number" && a < 0, O = k.useRef(null), D = k.useRef(null), U = k.useRef(!1), L = k.useRef(null), M = k.useRef(!1), _ = N != null, z = m && m.getAttribute("role") === "combobox" && Fx(m) && A, q = k.useCallback(function(T) {
    return T === void 0 && (T = b), T ? qf(T, Xf()) : [];
  }, [b]), H = k.useCallback((T) => {
    const j = q(T);
    return C.current.map((x) => m && x === "reference" ? m : b && x === "floating" ? b : j).filter(Boolean).flat();
  }, [m, b, C, q]);
  k.useEffect(() => {
    if (r || !l) return;
    function T(x) {
      if (x.key === "Tab") {
        jt(b, Hn(on(b))) && q().length === 0 && !z && bt(x);
        const F = H(), G = Lx(x);
        C.current[0] === "reference" && G === m && (bt(x), x.shiftKey ? An(F[F.length - 1]) : An(F[1])), C.current[1] === "floating" && G === b && x.shiftKey && (bt(x), An(F[0]));
      }
    }
    const j = on(b);
    return j.addEventListener("keydown", T), () => {
      j.removeEventListener("keydown", T);
    };
  }, [r, m, b, l, C, p, z, q, H]), k.useEffect(() => {
    if (r || !c) return;
    function T() {
      M.current = !0, setTimeout(() => {
        M.current = !1;
      });
    }
    function j(x) {
      const F = x.relatedTarget;
      queueMicrotask(() => {
        const G = !(jt(m, F) || jt(b, F) || jt(F, b) || jt(N == null ? void 0 : N.portalNode, F) || F != null && F.hasAttribute(no("focus-guard")) || I && (Gr(I.nodesRef.current, d).find((K) => {
          var Y, Q;
          return jt((Y = K.context) == null ? void 0 : Y.elements.floating, F) || jt((Q = K.context) == null ? void 0 : Q.elements.domReference, F);
        }) || e_(I.nodesRef.current, d).find((K) => {
          var Y, Q;
          return ((Y = K.context) == null ? void 0 : Y.elements.floating) === F || ((Q = K.context) == null ? void 0 : Q.elements.domReference) === F;
        })));
        F && G && !M.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        F !== L.current && (U.current = !0, v(!1, x));
      });
    }
    if (b && ei(m))
      return m.addEventListener("focusout", j), m.addEventListener("pointerdown", T), !l && b.addEventListener("focusout", j), () => {
        m.removeEventListener("focusout", j), m.removeEventListener("pointerdown", T), !l && b.removeEventListener("focusout", j);
      };
  }, [r, m, b, l, d, I, N, v, c]), k.useEffect(() => {
    var T;
    if (r) return;
    const j = Array.from((N == null || (T = N.portalNode) == null ? void 0 : T.querySelectorAll("[" + no("portal") + "]")) || []);
    if (b) {
      const x = [b, ...j, O.current, D.current, C.current.includes("reference") || z ? m : null].filter((G) => G != null), F = l ? Zh(x, w, !w) : Zh(x);
      return () => {
        F();
      };
    }
  }, [r, m, b, l, C, N, z, w]), ct(() => {
    if (r || !b) return;
    const T = on(b), j = Hn(T);
    queueMicrotask(() => {
      const x = H(b), F = S.current, G = (typeof F == "number" ? x[F] : F.current) || b, K = jt(b, j);
      !A && !K && f && An(G, {
        preventScroll: G === b
      });
    });
  }, [r, f, b, A, H, S]), ct(() => {
    if (r || !b) return;
    let T = !1;
    const j = on(b), x = Hn(j), F = g.current;
    L.current = x;
    function G(K) {
      if (K.type === "escapeKey" && p.domReference.current && (L.current = p.domReference.current), ["referencePress", "escapeKey"].includes(K.type))
        return;
      const Y = K.data.returnFocus;
      typeof Y == "object" ? (U.current = !1, T = Y.preventScroll) : U.current = !Y;
    }
    return h.on("dismiss", G), () => {
      h.off("dismiss", G);
      const K = Hn(j);
      (jt(b, K) || I && Gr(I.nodesRef.current, d).some((Q) => {
        var Z;
        return jt((Z = Q.context) == null ? void 0 : Z.elements.floating, K);
      }) || F.openEvent && ["click", "mousedown"].includes(F.openEvent.type)) && p.domReference.current && (L.current = p.domReference.current), // eslint-disable-next-line react-hooks/exhaustive-deps
      E.current && ei(L.current) && !U.current && An(L.current, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored — leaving the root
        // reference focused as desired.
        cancelPrevious: !1,
        preventScroll: T
      });
    };
  }, [r, b, E, g, p, h, I, d]), ct(() => {
    if (!(r || !N))
      return N.setFocusManagerState({
        modal: l,
        closeOnFocusOut: c,
        open: f,
        onOpenChange: v,
        refs: p
      }), () => {
        N.setFocusManagerState(null);
      };
  }, [r, N, l, f, v, p, c]), ct(() => {
    if (!r && b && typeof MutationObserver == "function" && !A) {
      const T = () => {
        const x = b.getAttribute("tabindex");
        C.current.includes("floating") || Hn(on(b)) !== p.domReference.current && q().length === 0 ? x !== "0" && b.setAttribute("tabindex", "0") : x !== "-1" && b.setAttribute("tabindex", "-1");
      };
      T();
      const j = new MutationObserver(T);
      return j.observe(b, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }), () => {
        j.disconnect();
      };
    }
  }, [r, b, p, C, q, A]);
  function P(T) {
    return r || !u || !l ? null : /* @__PURE__ */ k.createElement(c_, {
      ref: T === "start" ? O : D,
      onClick: (j) => v(!1, j.nativeEvent)
    }, typeof u == "string" ? u : "Dismiss");
  }
  const y = !r && w && !z && (_ || l);
  return /* @__PURE__ */ k.createElement(k.Fragment, null, y && /* @__PURE__ */ k.createElement(Ya, {
    "data-type": "inside",
    ref: N == null ? void 0 : N.beforeInsideRef,
    onFocus: (T) => {
      if (l) {
        const x = H();
        An(i[0] === "reference" ? x[0] : x[x.length - 1]);
      } else if (N != null && N.preserveTabOrder && N.portalNode)
        if (U.current = !1, qi(T, N.portalNode)) {
          const x = iw() || m;
          x == null || x.focus();
        } else {
          var j;
          (j = N.beforeOutsideRef.current) == null || j.focus();
        }
    }
  }), !z && P("start"), n, P("end"), y && /* @__PURE__ */ k.createElement(Ya, {
    "data-type": "inside",
    ref: N == null ? void 0 : N.afterInsideRef,
    onFocus: (T) => {
      if (l)
        An(H()[0]);
      else if (N != null && N.preserveTabOrder && N.portalNode)
        if (c && (U.current = !0), qi(T, N.portalNode)) {
          const x = ow() || m;
          x == null || x.focus();
        } else {
          var j;
          (j = N.afterOutsideRef.current) == null || j.focus();
        }
    }
  }));
}
function tv(e) {
  return ei(e.target) && e.target.tagName === "BUTTON";
}
function nv(e) {
  return Fx(e);
}
function d_(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: i,
    elements: {
      domReference: o
    }
  } = e, {
    enabled: a = !0,
    event: s = "click",
    toggle: l = !0,
    ignoreMouse: u = !1,
    keyboardHandlers: c = !0
  } = t, f = k.useRef(), p = k.useRef(!1);
  return k.useMemo(() => a ? {
    reference: {
      onPointerDown(d) {
        f.current = d.pointerType;
      },
      onMouseDown(d) {
        d.button === 0 && (zh(f.current) && u || s !== "click" && (n && l && (!i.current.openEvent || i.current.openEvent.type === "mousedown") ? r(!1, d.nativeEvent) : (d.preventDefault(), r(!0, d.nativeEvent))));
      },
      onClick(d) {
        if (s === "mousedown" && f.current) {
          f.current = void 0;
          return;
        }
        zh(f.current) && u || (n && l && (!i.current.openEvent || i.current.openEvent.type === "click") ? r(!1, d.nativeEvent) : r(!0, d.nativeEvent));
      },
      onKeyDown(d) {
        f.current = void 0, !(d.defaultPrevented || !c || tv(d)) && (d.key === " " && !nv(o) && (d.preventDefault(), p.current = !0), d.key === "Enter" && r(!(n && l), d.nativeEvent));
      },
      onKeyUp(d) {
        d.defaultPrevented || !c || tv(d) || nv(o) || d.key === " " && p.current && (p.current = !1, r(!(n && l), d.nativeEvent));
      }
    }
  } : {}, [a, i, s, u, c, o, l, n, r]);
}
const p_ = k.useInsertionEffect, h_ = p_ || ((e) => e());
function Yn(e) {
  const t = k.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return h_(() => {
    t.current = e;
  }), k.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
const v_ = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, m_ = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, g_ = (e) => {
  var t, n;
  return {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePressBubbles: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function y_(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    events: i,
    nodeId: o,
    elements: {
      reference: a,
      domReference: s,
      floating: l
    },
    dataRef: u
  } = e, {
    enabled: c = !0,
    escapeKey: f = !0,
    outsidePress: p = !0,
    outsidePressEvent: d = "pointerdown",
    referencePress: v = !1,
    referencePressEvent: h = "pointerdown",
    ancestorScroll: g = !1,
    bubbles: m
  } = t, b = $s(), w = tw() != null, C = Yn(typeof p == "function" ? p : () => !1), S = typeof p == "function" ? C : p, E = k.useRef(!1), {
    escapeKeyBubbles: I,
    outsidePressBubbles: N
  } = g_(m), A = Yn((D) => {
    if (!n || !c || !f || D.key !== "Escape")
      return;
    const U = b ? Gr(b.nodesRef.current, o) : [];
    if (!I && (D.stopPropagation(), U.length > 0)) {
      let L = !0;
      if (U.forEach((M) => {
        var _;
        if ((_ = M.context) != null && _.open && !M.context.dataRef.current.__escapeKeyBubbles) {
          L = !1;
          return;
        }
      }), !L)
        return;
    }
    i.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: !1
        }
      }
    }), r(!1, VA(D) ? D.nativeEvent : D);
  }), O = Yn((D) => {
    const U = E.current;
    if (E.current = !1, U || typeof S == "function" && !S(D))
      return;
    const L = Lx(D), M = "[" + no("inert") + "]", _ = on(l).querySelectorAll(M);
    let z = Xt(L) ? L : null;
    for (; z && !BA(z); ) {
      const P = WA(z);
      if (P === on(l).body || !Xt(P))
        break;
      z = P;
    }
    if (_.length && Xt(L) && !KA(L) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !jt(L, l) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(_).every((P) => !jt(z, P)))
      return;
    if (ei(L) && l) {
      const P = L.clientWidth > 0 && L.scrollWidth > L.clientWidth, y = L.clientHeight > 0 && L.scrollHeight > L.clientHeight;
      let T = y && D.offsetX > L.clientWidth;
      if (y && zA(L).direction === "rtl" && (T = D.offsetX <= L.offsetWidth - L.clientWidth), T || P && D.offsetY > L.clientHeight)
        return;
    }
    const q = b && Gr(b.nodesRef.current, o).some((P) => {
      var y;
      return Ol(D, (y = P.context) == null ? void 0 : y.elements.floating);
    });
    if (Ol(D, l) || Ol(D, s) || q)
      return;
    const H = b ? Gr(b.nodesRef.current, o) : [];
    if (H.length > 0) {
      let P = !0;
      if (H.forEach((y) => {
        var T;
        if ((T = y.context) != null && T.open && !y.context.dataRef.current.__outsidePressBubbles) {
          P = !1;
          return;
        }
      }), !P)
        return;
    }
    i.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: w ? {
          preventScroll: !0
        } : Mx(D) || jx(D)
      }
    }), r(!1, D);
  });
  return k.useEffect(() => {
    if (!n || !c)
      return;
    u.current.__escapeKeyBubbles = I, u.current.__outsidePressBubbles = N;
    function D(M) {
      r(!1, M);
    }
    const U = on(l);
    f && U.addEventListener("keydown", A), S && U.addEventListener(d, O);
    let L = [];
    return g && (Xt(s) && (L = qn(s)), Xt(l) && (L = L.concat(qn(l))), !Xt(a) && a && a.contextElement && (L = L.concat(qn(a.contextElement)))), L = L.filter((M) => {
      var _;
      return M !== ((_ = U.defaultView) == null ? void 0 : _.visualViewport);
    }), L.forEach((M) => {
      M.addEventListener("scroll", D, {
        passive: !0
      });
    }), () => {
      f && U.removeEventListener("keydown", A), S && U.removeEventListener(d, O), L.forEach((M) => {
        M.removeEventListener("scroll", D);
      });
    };
  }, [u, l, s, a, f, S, d, n, r, g, c, I, N, A, O]), k.useEffect(() => {
    E.current = !1;
  }, [S, d]), k.useMemo(() => c ? {
    reference: {
      onKeyDown: A,
      [v_[h]]: (D) => {
        v && (i.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), r(!1, D.nativeEvent));
      }
    },
    floating: {
      onKeyDown: A,
      [m_[d]]: () => {
        E.current = !0;
      }
    }
  } : {}, [c, i, v, d, h, r, A]);
}
let yc;
process.env.NODE_ENV !== "production" && (yc = /* @__PURE__ */ new Set());
function b_(e) {
  var t;
  e === void 0 && (e = {});
  const {
    open: n = !1,
    onOpenChange: r,
    nodeId: i
  } = e;
  if (process.env.NODE_ENV !== "production") {
    var o;
    const I = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((o = e.elements) != null && o.reference && !Xt(e.elements.reference)) {
      var a;
      if (!((a = yc) != null && a.has(I))) {
        var s;
        (s = yc) == null || s.add(I), console.error(I);
      }
    }
  }
  const [l, u] = k.useState(null), c = ((t = e.elements) == null ? void 0 : t.reference) || l, f = CD(e), p = $s(), d = Yn((I, N) => {
    I && (h.current.openEvent = N), r == null || r(I, N);
  }), v = k.useRef(null), h = k.useRef({}), g = k.useState(() => JD())[0], m = Yf(), b = k.useCallback((I) => {
    const N = Xt(I) ? {
      getBoundingClientRect: () => I.getBoundingClientRect(),
      contextElement: I
    } : I;
    f.refs.setReference(N);
  }, [f.refs]), w = k.useCallback((I) => {
    (Xt(I) || I === null) && (v.current = I, u(I)), (Xt(f.refs.reference.current) || f.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    I !== null && !Xt(I)) && f.refs.setReference(I);
  }, [f.refs]), C = k.useMemo(() => ({
    ...f.refs,
    setReference: w,
    setPositionReference: b,
    domReference: v
  }), [f.refs, w, b]), S = k.useMemo(() => ({
    ...f.elements,
    domReference: c
  }), [f.elements, c]), E = k.useMemo(() => ({
    ...f,
    refs: C,
    elements: S,
    dataRef: h,
    nodeId: i,
    floatingId: m,
    events: g,
    open: n,
    onOpenChange: d
  }), [f, i, m, g, n, d, C, S]);
  return ct(() => {
    const I = p == null ? void 0 : p.nodesRef.current.find((N) => N.id === i);
    I && (I.context = E);
  }), k.useMemo(() => ({
    ...f,
    context: E,
    refs: C,
    elements: S
  }), [f, C, S, E]);
}
function _l(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  return {
    ...n === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((i) => i ? i[n] : null).concat(e).reduce((i, o) => (o && Object.entries(o).forEach((a) => {
      let [s, l] = a;
      if (s.indexOf("on") === 0) {
        if (r.has(s) || r.set(s, []), typeof l == "function") {
          var u;
          (u = r.get(s)) == null || u.push(l), i[s] = function() {
            for (var c, f = arguments.length, p = new Array(f), d = 0; d < f; d++)
              p[d] = arguments[d];
            return (c = r.get(s)) == null ? void 0 : c.map((v) => v(...p)).find((v) => v !== void 0);
          };
        }
      } else
        i[s] = l;
    }), i), {})
  };
}
function x_(e) {
  e === void 0 && (e = []);
  const t = e, n = k.useCallback(
    (o) => _l(o, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), r = k.useCallback(
    (o) => _l(o, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = k.useCallback(
    (o) => _l(o, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((o) => o == null ? void 0 : o.item)
  );
  return k.useMemo(() => ({
    getReferenceProps: n,
    getFloatingProps: r,
    getItemProps: i
  }), [n, r, i]);
}
let rv = !1;
function Ts(e, t, n) {
  switch (e) {
    case "vertical":
      return t;
    case "horizontal":
      return n;
    default:
      return t || n;
  }
}
function iv(e, t) {
  return Ts(t, e === Gf || e === Cs, e === ri || e === xo);
}
function Ml(e, t, n) {
  return Ts(t, e === Cs, n ? e === ri : e === xo) || e === "Enter" || e == " " || e === "";
}
function w_(e, t, n) {
  return Ts(t, n ? e === ri : e === xo, e === Cs);
}
function ov(e, t, n) {
  return Ts(t, n ? e === xo : e === ri, e === Gf);
}
function S_(e, t) {
  const {
    open: n,
    onOpenChange: r,
    refs: i,
    elements: {
      domReference: o,
      floating: a
    }
  } = e, {
    listRef: s,
    activeIndex: l,
    onNavigate: u = () => {
    },
    enabled: c = !0,
    selectedIndex: f = null,
    allowEscape: p = !1,
    loop: d = !1,
    nested: v = !1,
    rtl: h = !1,
    virtual: g = !1,
    focusItemOnOpen: m = "auto",
    focusItemOnHover: b = !0,
    openOnArrowKeyDown: w = !0,
    disabledIndices: C = void 0,
    orientation: S = "vertical",
    cols: E = 1,
    scrollItemIntoView: I = !0,
    virtualItemRef: N
  } = t;
  process.env.NODE_ENV !== "production" && (p && (d || console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" ")), g || console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "))), S === "vertical" && E > 1 && console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" ")));
  const A = tw(), O = $s(), D = Yn(u), U = k.useRef(m), L = k.useRef(f ?? -1), M = k.useRef(null), _ = k.useRef(!0), z = k.useRef(D), q = k.useRef(!!a), H = k.useRef(!1), P = k.useRef(!1), y = Gn(C), T = Gn(n), j = Gn(I), [x, F] = k.useState(), [G, K] = k.useState(), Y = Yn(function(X, J, V) {
    V === void 0 && (V = !1);
    const ne = X.current[J.current];
    ne && (g ? (F(ne.id), O == null || O.events.emit("virtualfocus", ne), N && (N.current = ne)) : An(ne, {
      preventScroll: !0,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: HA() && Nx() ? rv || H.current : !1
    }), requestAnimationFrame(() => {
      const se = j.current;
      se && ne && (V || !_.current) && (ne.scrollIntoView == null || ne.scrollIntoView(typeof se == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : se));
    }));
  });
  ct(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return rv = !0, !1;
      }
    });
  }, []), ct(() => {
    c && (n && a ? U.current && f != null && (P.current = !0, D(f)) : q.current && (L.current = -1, z.current(null)));
  }, [c, n, a, f, D]), ct(() => {
    if (c && n && a)
      if (l == null) {
        if (H.current = !1, f != null)
          return;
        if (q.current && (L.current = -1, Y(s, L)), !q.current && U.current && (M.current != null || U.current === !0 && M.current == null)) {
          let X = 0;
          const J = () => {
            s.current[0] == null ? (X < 2 && (X ? requestAnimationFrame : queueMicrotask)(J), X++) : (L.current = M.current == null || Ml(M.current, S, h) || v ? Pl(s, y.current) : Xh(s, y.current), M.current = null, D(L.current));
          };
          J();
        }
      } else Ki(s, l) || (L.current = l, Y(s, L, P.current), P.current = !1);
  }, [c, n, a, l, f, v, s, S, h, D, Y, y]), ct(() => {
    var X, J;
    if (!c || a || !O || g || !q.current)
      return;
    const V = O.nodesRef.current, ne = (X = V.find((oe) => oe.id === A)) == null || (J = X.context) == null ? void 0 : J.elements.floating, se = Hn(on(a)), fe = V.some((oe) => oe.context && jt(oe.context.elements.floating, se));
    ne && !fe && _.current && ne.focus({
      preventScroll: !0
    });
  }, [c, a, O, A, g]), ct(() => {
    if (!c || !O || !g || A) return;
    function X(J) {
      K(J.id), N && (N.current = J);
    }
    return O.events.on("virtualfocus", X), () => {
      O.events.off("virtualfocus", X);
    };
  }, [c, O, g, A, N]), ct(() => {
    z.current = D, q.current = !!a;
  }), ct(() => {
    n || (M.current = null);
  }, [n]);
  const Q = l != null, Z = k.useMemo(() => {
    function X(V) {
      if (!n) return;
      const ne = s.current.indexOf(V);
      ne !== -1 && D(ne);
    }
    return {
      onFocus(V) {
        let {
          currentTarget: ne
        } = V;
        X(ne);
      },
      onClick: (V) => {
        let {
          currentTarget: ne
        } = V;
        return ne.focus({
          preventScroll: !0
        });
      },
      // Safari
      ...b && {
        onMouseMove(V) {
          let {
            currentTarget: ne
          } = V;
          X(ne);
        },
        onPointerLeave(V) {
          let {
            pointerType: ne
          } = V;
          !_.current || ne === "touch" || (L.current = -1, Y(s, L), D(null), g || An(i.floating.current, {
            preventScroll: !0
          }));
        }
      }
    };
  }, [n, i, Y, b, s, D, g]);
  return k.useMemo(() => {
    if (!c)
      return {};
    const X = y.current;
    function J(oe) {
      if (_.current = !1, H.current = !0, !T.current && oe.currentTarget === i.floating.current)
        return;
      if (v && ov(oe.key, S, h)) {
        bt(oe), r(!1, oe.nativeEvent), ei(o) && !g && o.focus();
        return;
      }
      const pe = L.current, Se = Pl(s, X), Ie = Xh(s, X);
      if (oe.key === "Home" && (bt(oe), L.current = Se, D(L.current)), oe.key === "End" && (bt(oe), L.current = Ie, D(L.current)), !(E > 1 && (L.current = qD(s, {
        event: oe,
        orientation: S,
        loop: d,
        cols: E,
        disabledIndices: X,
        minIndex: Se,
        maxIndex: Ie,
        prevIndex: L.current,
        stopEvent: !0
      }), D(L.current), S === "both")) && iv(oe.key, S)) {
        if (bt(oe), n && !g && Hn(oe.currentTarget.ownerDocument) === oe.currentTarget) {
          L.current = Ml(oe.key, S, h) ? Se : Ie, D(L.current);
          return;
        }
        Ml(oe.key, S, h) ? d ? L.current = pe >= Ie ? p && pe !== s.current.length ? -1 : Se : $t(s, {
          startingIndex: pe,
          disabledIndices: X
        }) : L.current = Math.min(Ie, $t(s, {
          startingIndex: pe,
          disabledIndices: X
        })) : d ? L.current = pe <= Se ? p && pe !== -1 ? s.current.length : Ie : $t(s, {
          startingIndex: pe,
          decrement: !0,
          disabledIndices: X
        }) : L.current = Math.max(Se, $t(s, {
          startingIndex: pe,
          decrement: !0,
          disabledIndices: X
        })), Ki(s, L.current) ? D(null) : D(L.current);
      }
    }
    function V(oe) {
      m === "auto" && Mx(oe.nativeEvent) && (U.current = !0);
    }
    function ne(oe) {
      U.current = m, m === "auto" && jx(oe.nativeEvent) && (U.current = !0);
    }
    const se = g && n && Q && {
      "aria-activedescendant": G || x
    }, fe = s.current.find((oe) => (oe == null ? void 0 : oe.id) === x);
    return {
      reference: {
        ...se,
        onKeyDown(oe) {
          _.current = !1;
          const pe = oe.key.indexOf("Arrow") === 0, Se = w_(oe.key, S, h), Ie = ov(oe.key, S, h), nt = iv(oe.key, S), St = (v ? Se : nt) || oe.key === "Enter" || oe.key.trim() === "";
          if (g && n) {
            const ue = O == null ? void 0 : O.nodesRef.current.find((B) => B.parentId == null), W = O && ue ? t_(O.nodesRef.current, ue.id) : null;
            if (pe && W && N) {
              const B = new KeyboardEvent("keydown", {
                key: oe.key,
                bubbles: !0
              });
              if (Se || Ie) {
                var Et, kt;
                const te = ((Et = W.context) == null ? void 0 : Et.elements.domReference) === oe.currentTarget, ae = Ie && !te ? (kt = W.context) == null ? void 0 : kt.elements.domReference : Se ? fe : null;
                ae && (bt(oe), ae.dispatchEvent(B), K(void 0));
              }
              if (nt && W.context && W.context.open && W.parentId && oe.currentTarget !== W.context.elements.domReference) {
                var ie;
                bt(oe), (ie = W.context.elements.domReference) == null || ie.dispatchEvent(B);
                return;
              }
            }
            return J(oe);
          }
          if (!(!n && !w && pe)) {
            if (St && (M.current = v && nt ? null : oe.key), v) {
              Se && (bt(oe), n ? (L.current = Pl(s, X), D(L.current)) : r(!0, oe.nativeEvent));
              return;
            }
            nt && (f != null && (L.current = f), bt(oe), !n && w ? r(!0, oe.nativeEvent) : J(oe), n && D(L.current));
          }
        },
        onFocus() {
          n && D(null);
        },
        onPointerDown: ne,
        onMouseDown: V,
        onClick: V
      },
      floating: {
        "aria-orientation": S === "both" ? void 0 : S,
        ...se,
        onKeyDown: J,
        onPointerMove() {
          _.current = !0;
        }
      },
      item: Z
    };
  }, [o, i, x, G, y, T, s, c, S, h, g, n, Q, v, f, w, p, E, d, m, D, r, Z, O, N]);
}
function E_(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    floatingId: r
  } = e, {
    enabled: i = !0,
    role: o = "dialog"
  } = t, a = Yf();
  return k.useMemo(() => {
    const s = {
      id: r,
      role: o
    };
    return i ? o === "tooltip" ? {
      reference: {
        "aria-describedby": n ? r : void 0
      },
      floating: s
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": o === "alertdialog" ? "dialog" : o,
        "aria-controls": n ? r : void 0,
        ...o === "listbox" && {
          role: "combobox"
        },
        ...o === "menu" && {
          id: a
        }
      },
      floating: {
        ...s,
        ...o === "menu" && {
          "aria-labelledby": a
        }
      }
    } : {};
  }, [i, o, n, r, a]);
}
function k_(e, t) {
  var n;
  const {
    open: r,
    dataRef: i
  } = e, {
    listRef: o,
    activeIndex: a,
    onMatch: s,
    onTypingChange: l,
    enabled: u = !0,
    findMatch: c = null,
    resetMs: f = 750,
    ignoreKeys: p = [],
    selectedIndex: d = null
  } = t, v = k.useRef(), h = k.useRef(""), g = k.useRef((n = d ?? a) != null ? n : -1), m = k.useRef(null), b = Yn(s), w = Yn(l), C = Gn(c), S = Gn(p);
  return ct(() => {
    r && (clearTimeout(v.current), m.current = null, h.current = "");
  }, [r]), ct(() => {
    if (r && h.current === "") {
      var E;
      g.current = (E = d ?? a) != null ? E : -1;
    }
  }, [r, d, a]), k.useMemo(() => {
    if (!u)
      return {};
    function E(A) {
      A ? i.current.typing || (i.current.typing = A, w(A)) : i.current.typing && (i.current.typing = A, w(A));
    }
    function I(A, O, D) {
      const U = C.current ? C.current(O, D) : O.find((L) => (L == null ? void 0 : L.toLocaleLowerCase().indexOf(D.toLocaleLowerCase())) === 0);
      return U ? A.indexOf(U) : -1;
    }
    function N(A) {
      const O = o.current;
      if (h.current.length > 0 && h.current[0] !== " " && (I(O, O, h.current) === -1 ? E(!1) : A.key === " " && bt(A)), O == null || S.current.includes(A.key) || // Character key.
      A.key.length !== 1 || // Modifier key.
      A.ctrlKey || A.metaKey || A.altKey)
        return;
      r && A.key !== " " && (bt(A), E(!0)), O.every((M) => {
        var _, z;
        return M ? ((_ = M[0]) == null ? void 0 : _.toLocaleLowerCase()) !== ((z = M[1]) == null ? void 0 : z.toLocaleLowerCase()) : !0;
      }) && h.current === A.key && (h.current = "", g.current = m.current), h.current += A.key, clearTimeout(v.current), v.current = setTimeout(() => {
        h.current = "", g.current = m.current, E(!1);
      }, f);
      const U = g.current, L = I(O, [...O.slice((U || 0) + 1), ...O.slice(0, (U || 0) + 1)], h.current);
      L !== -1 ? (b(L), m.current = L) : A.key !== " " && (h.current = "", E(!1));
    }
    return {
      reference: {
        onKeyDown: N
      },
      floating: {
        onKeyDown: N,
        onKeyUp(A) {
          A.key === " " && E(!1);
        }
      }
    };
  }, [u, r, i, o, f, S, C, b, w]);
}
const C_ = ({ options: e, reusable: t, sendMessage: n, isReadOnly: r }) => {
  var M, _, z, q, H;
  const i = Mf((P) => P.messageContainerRef), [o, a] = k.useState(!1), [s, l] = k.useState(null), [u, c] = k.useState(null), {
    message: {
      blocks: { dropdown: f }
    }
  } = we, p = e.reduce(
    (P, y) => (P[y.label] = y.value, P),
    {}
  ), d = p ? Object.keys(p) : [], v = (P) => {
    a(u !== null && !t ? !1 : P);
  }, { refs: h, floatingStyles: g, context: m } = b_({
    placement: "bottom-start",
    open: o,
    onOpenChange: v,
    whileElementsMounted: xD,
    middleware: [
      $D(5),
      TD({
        padding: 10,
        boundary: (i == null ? void 0 : i.current) ?? void 0,
        crossAxis: !0
      }),
      OD({
        apply({ rects: P, elements: y, availableHeight: T }) {
          Object.assign(y.floating.style, {
            maxHeight: `${T}px`,
            minWidth: `${P.reference.width}px`
          });
        },
        padding: 10
      })
    ]
  }), b = k.useRef([]), w = k.useRef(d), C = k.useRef(!1), S = d_(m, { event: "mousedown" }), E = y_(m), I = E_(m, { role: "listbox" }), N = S_(m, {
    listRef: b,
    activeIndex: s,
    selectedIndex: u,
    onNavigate: l,
    // This is a large list, allow looping.
    loop: !0
  }), A = k_(m, {
    listRef: w,
    activeIndex: s,
    selectedIndex: u,
    onMatch: o ? l : c,
    onTypingChange(P) {
      C.current = P;
    }
  }), { getReferenceProps: O, getFloatingProps: D, getItemProps: U } = x_([
    E,
    I,
    N,
    A,
    S
  ]), L = (P) => {
    c(P), d[P] !== void 0 && (n == null || n({
      type: "text",
      text: d[P] ?? "",
      value: p[d[P]] ?? ""
    })), a(!1);
  };
  return /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    /* @__PURE__ */ $.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: h.setReference,
        "aria-labelledby": "select-label",
        "aria-autocomplete": "none",
        "data-disabled": u !== null && !t ? "" : void 0,
        style: r ? { pointerEvents: "none" } : void 0,
        ...(M = f.button) == null ? void 0 : M.container,
        ...O(),
        children: [
          /* @__PURE__ */ $.jsx("span", { ...(_ = f.button) == null ? void 0 : _.text, children: u ? d[u] : "Select..." }),
          /* @__PURE__ */ $.jsx(rP, { ...(z = f.button) == null ? void 0 : z.icon })
        ]
      }
    ),
    o && /* @__PURE__ */ $.jsx(u_, { children: /* @__PURE__ */ $.jsx(f_, { context: m, modal: !1, children: /* @__PURE__ */ $.jsx(
      "div",
      {
        ref: h.setFloating,
        className: (H = (q = f.content) == null ? void 0 : q.container) == null ? void 0 : H.className,
        style: { ...g },
        ...D(),
        children: d.map((P, y) => {
          var T;
          return /* @__PURE__ */ $.jsx(
            "div",
            {
              ref: (j) => {
                b.current[y] = j;
              },
              role: "option",
              tabIndex: y === s ? 0 : -1,
              "aria-selected": y === u && y === s,
              "data-active": y === s ? "" : void 0,
              ...(T = f.content) == null ? void 0 : T.item,
              ...U({
                onClick() {
                  L(y);
                },
                onKeyDown(j) {
                  j.key === "Enter" && (j.preventDefault(), L(y)), j.key === " " && !C.current && (j.preventDefault(), L(y));
                }
              }),
              children: P
            },
            P
          );
        })
      }
    ) }) })
  ] });
}, lw = Ot(({ title: e, url: t, isReadOnly: n, ...r }, i) => {
  const {
    message: {
      blocks: { file: o }
    }
  } = we;
  return /* @__PURE__ */ $.jsxs(
    "a",
    {
      ...r,
      ...o.container,
      href: t,
      style: n ? { pointerEvents: "none" } : void 0,
      download: !0,
      ref: i,
      target: "_blank",
      rel: "noreferrer",
      children: [
        /* @__PURE__ */ $.jsx("p", { ...o.title, children: e || t }),
        /* @__PURE__ */ $.jsx(uP, { ...o.icon })
      ]
    }
  );
});
lw.displayName = "File";
const $_ = wr()((e, t) => ({
  components: {},
  getCustomComponent: async (n) => {
    const r = t().components[n];
    if (r)
      return r;
    const i = await fetch(n).then((u) => u.text()), o = new Blob([i], { type: "application/javascript" }), s = await import(URL.createObjectURL(o)), l = () => s.default;
    return e((u) => ({ components: { ...u.components, [n]: l } })), l;
  }
}));
globalThis.React = Le;
const T_ = ({ url: e, name: t, data: n, ...r }) => {
  const i = $_((u) => u.getCustomComponent), [o, a] = ge(null), [s, l] = ge(null);
  return vt(() => {
    i(e).then(a).catch((u) => {
      l(u.message);
    });
  }, [e]), s ? /* @__PURE__ */ $.jsx("div", { style: { color: "red" }, children: s }) : o ? /* @__PURE__ */ $.jsx(o, { ...n, ...r }) : null;
}, O_ = {
  audio: Ex,
  bubble: yx,
  button: nA,
  carousel: Px,
  column: Cx,
  dropdown: C_,
  file: lw,
  image: wx,
  location: kx,
  row: $x,
  text: TP,
  video: Sx,
  custom: T_
}, ii = ({ block: e, renderers: t, ...n }) => {
  const r = (t == null ? void 0 : t[e.type]) ?? O_[e.type], i = { ...n, ...e };
  return /* @__PURE__ */ $.jsx(r, { ...i });
};
function uw(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = uw(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function oi() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = uw(e)) && (r && (r += " "), r += t);
  return r;
}
const I_ = ({ disabled: e, onFileSelected: t }) => {
  const n = Ke(null), { uploadButton: r } = we.composer, i = () => {
    n.current && n.current.click();
  }, o = (a) => {
    const s = a.target.files;
    s && s.length > 0 && Array.from(s).forEach((l) => {
      t(l);
    });
  };
  return /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    /* @__PURE__ */ $.jsx(
      bP,
      {
        ...r,
        role: "button",
        tabIndex: 0,
        "aria-label": "Upload File Button",
        "data-disabled": e,
        onClick: i
      }
    ),
    /* @__PURE__ */ $.jsx(
      "input",
      {
        value: "",
        multiple: !0,
        type: "file",
        ref: n,
        style: { display: "none" },
        onChange: o
      }
    )
  ] });
}, R_ = ({ name: e, type: t, instance: n, status: r, removeFile: i }) => {
  const { loader: o, fileIcon: a, removeIcon: s, errorIcon: l, previewImage: u } = we.composer.fileWidget, c = ["PNG", "JPEG", "JPG"].includes(ea(e)), f = st(() => c ? URL.createObjectURL(n) : "", [n]);
  return r === "loading" ? /* @__PURE__ */ $.jsx(Zo, { name: e, status: r, removeButton: /* @__PURE__ */ $.jsx("div", { ...o }), extension: ea(e), children: /* @__PURE__ */ $.jsx("div", { ...a.container, children: /* @__PURE__ */ $.jsx(jl, { type: t, ...a.icon }) }) }) : r === "error" ? /* @__PURE__ */ $.jsx(
    Zo,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ $.jsx(av, { removeFile: () => i(e) }),
      extension: "Upload Error",
      children: /* @__PURE__ */ $.jsxs("div", { ...a.container, children: [
        /* @__PURE__ */ $.jsx(aP, { ...l }),
        /* @__PURE__ */ $.jsx(jl, { type: t, ...a.icon })
      ] })
    }
  ) : r == "uploaded" && c ? /* @__PURE__ */ $.jsx(
    Zo,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ $.jsx(av, { removeFile: () => i(e) }),
      extension: ea(e),
      children: /* @__PURE__ */ $.jsx("div", { ...a.container, children: /* @__PURE__ */ $.jsx("img", { src: f, alt: e, ...u }) })
    }
  ) : /* @__PURE__ */ $.jsx(
    Zo,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ $.jsx(ex, { onClick: () => i(e), ...s }),
      extension: ea(e),
      children: /* @__PURE__ */ $.jsx("div", { ...a.container, children: /* @__PURE__ */ $.jsx(jl, { type: t, ...a.icon }) })
    }
  );
}, Zo = ({ name: e, status: t, removeButton: n, children: r, extension: i }) => {
  const { container: o, metadata: a } = we.composer.fileWidget;
  return /* @__PURE__ */ $.jsxs("div", { "data-status": t, title: e, ...o, children: [
    n,
    r,
    /* @__PURE__ */ $.jsxs("div", { ...a.container, children: [
      /* @__PURE__ */ $.jsx("div", { ...a.name, children: e }),
      /* @__PURE__ */ $.jsx("div", { ...a.type, children: i })
    ] })
  ] });
}, jl = ({ type: e, ...t }) => e === "image" ? /* @__PURE__ */ $.jsx(dP, { ...t }) : e === "video" ? /* @__PURE__ */ $.jsx(EP, { ...t }) : e === "audio" ? /* @__PURE__ */ $.jsx(kP, { ...t }) : /* @__PURE__ */ $.jsx(tx, { ...t }), ea = (e) => {
  const t = e.split(".").pop();
  return t ? t.toUpperCase() : "File";
}, av = ({ removeFile: e }) => {
  const {
    composer: {
      fileWidget: { removeIcon: t }
    }
  } = we;
  return /* @__PURE__ */ $.jsx(ex, { role: "button", tabIndex: 0, "aria-label": "Remove File Button", onClick: () => e(), ...t });
};
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bc.apply(null, arguments);
}
function P_(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
var A_ = fi, D_ = function(t) {
  var n = k.useRef(t);
  return A_(function() {
    n.current = t;
  }), n;
}, sv = function(t, n) {
  if (typeof t == "function") {
    t(n);
    return;
  }
  t.current = n;
}, __ = function(t, n) {
  var r = Ke();
  return Oe(function(i) {
    t.current = i, r.current && sv(r.current, null), r.current = n, n && sv(n, i);
  }, [n]);
}, lv = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0",
  display: "block"
}, M_ = function(t) {
  Object.keys(lv).forEach(function(n) {
    t.style.setProperty(n, lv[n], "important");
  });
}, uv = M_, At = null, cv = function(t, n) {
  var r = t.scrollHeight;
  return n.sizingStyle.boxSizing === "border-box" ? r + n.borderSize : r - n.paddingSize;
};
function j_(e, t, n, r) {
  n === void 0 && (n = 1), r === void 0 && (r = 1 / 0), At || (At = document.createElement("textarea"), At.setAttribute("tabindex", "-1"), At.setAttribute("aria-hidden", "true"), uv(At)), At.parentNode === null && document.body.appendChild(At);
  var i = e.paddingSize, o = e.borderSize, a = e.sizingStyle, s = a.boxSizing;
  Object.keys(a).forEach(function(p) {
    var d = p;
    At.style[d] = a[d];
  }), uv(At), At.value = t;
  var l = cv(At, e);
  At.value = t, l = cv(At, e), At.value = "x";
  var u = At.scrollHeight - i, c = u * n;
  s === "border-box" && (c = c + i + o), l = Math.max(c, l);
  var f = u * r;
  return s === "border-box" && (f = f + i + o), l = Math.min(f, l), [l, u];
}
var fv = function() {
}, N_ = function(t, n) {
  return t.reduce(function(r, i) {
    return r[i] = n[i], r;
  }, {});
}, L_ = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
], F_ = !!document.documentElement.currentStyle, B_ = function(t) {
  var n = window.getComputedStyle(t);
  if (n === null)
    return null;
  var r = N_(L_, n), i = r.boxSizing;
  if (i === "")
    return null;
  F_ && i === "border-box" && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px");
  var o = parseFloat(r.paddingBottom) + parseFloat(r.paddingTop), a = parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth);
  return {
    sizingStyle: r,
    paddingSize: o,
    borderSize: a
  };
}, z_ = B_;
function cw(e, t, n) {
  var r = D_(n);
  k.useLayoutEffect(function() {
    var i = function(a) {
      return r.current(a);
    };
    if (e)
      return e.addEventListener(t, i), function() {
        return e.removeEventListener(t, i);
      };
  }, []);
}
var W_ = function(t) {
  cw(window, "resize", t);
}, U_ = function(t) {
  cw(document.fonts, "loadingdone", t);
}, H_ = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], V_ = function(t, n) {
  var r = t.cacheMeasurements, i = t.maxRows, o = t.minRows, a = t.onChange, s = a === void 0 ? fv : a, l = t.onHeightChange, u = l === void 0 ? fv : l, c = P_(t, H_), f = c.value !== void 0, p = k.useRef(null), d = __(p, n), v = k.useRef(0), h = k.useRef(), g = function() {
    var w = p.current, C = r && h.current ? h.current : z_(w);
    if (C) {
      h.current = C;
      var S = j_(C, w.value || w.placeholder || "x", o, i), E = S[0], I = S[1];
      v.current !== E && (v.current = E, w.style.setProperty("height", E + "px", "important"), u(E, {
        rowHeight: I
      }));
    }
  }, m = function(w) {
    f || g(), s(w);
  };
  return k.useLayoutEffect(g), W_(g), U_(g), /* @__PURE__ */ k.createElement("textarea", bc({}, c, {
    onChange: m,
    ref: d
  }));
}, K_ = /* @__PURE__ */ k.forwardRef(V_);
const q_ = ({
  inputRef: e,
  composerPlaceholder: t,
  composerDisabled: n,
  textInput: r,
  historyIndex: i,
  setTextInput: o,
  setHistoryIndex: a,
  sendComposerMessage: s
}) => {
  const l = ax((c) => c.messageHistory), { input: u } = we.composer;
  return /* @__PURE__ */ $.jsx(
    K_,
    {
      ...u,
      "aria-label": "Message Input",
      ref: e,
      placeholder: t ?? "Type your message...",
      disabled: n,
      value: r,
      "data-has-value": !!r,
      onChange: (c) => o(c.target.value),
      maxRows: 5,
      onKeyDown: (c) => {
        n || (c.key === "Enter" && c.shiftKey ? (c.preventDefault(), o(`${r}
`)) : c.key === "Enter" && (c.preventDefault(), s()), c.key === "ArrowUp" && (c.preventDefault(), i < l.length - 1 && o(l[i + 1] ?? ""), a(Math.min(i + 1, l.length - 1))), c.key === "ArrowDown" && (c.preventDefault(), o(i === 0 ? "" : l[i - 1] ?? ""), a(Math.max(i - 1, -1))));
      }
    }
  );
}, G_ = ({ disabled: e, setTextInput: t }) => {
  const [n, r] = ge(!1), i = Ke(null), { voiceButton: o } = we.composer, a = window.SpeechRecognition || window.webkitSpeechRecognition, s = () => {
    i.current || (i.current = new a());
    const l = i.current;
    l && (l.continuous = !0, l.onresult = (u) => {
      var f, p, d;
      const c = ((d = (p = (f = u.results) == null ? void 0 : f[0]) == null ? void 0 : p[0]) == null ? void 0 : d.transcript) ?? "";
      t(c ?? ""), l.stop(), r(!1);
    }, n ? (l.stop(), r(!1)) : (l.start(), r(!0)));
  };
  if (a)
    return /* @__PURE__ */ $.jsx(
      mP,
      {
        ...o,
        tabIndex: 0,
        "aria-label": "Voice Input Button",
        role: "button",
        "data-show": !e,
        "data-listens": !!n,
        onClick: s
      }
    );
}, Y_ = ds(
  Ot(
    ({
      className: e,
      inputRef: t,
      disableComposer: n,
      isReadOnly: r,
      allowFileUpload: i,
      connected: o,
      composerPlaceholder: a,
      footer: s,
      sendMessage: l,
      uploadFile: u,
      ...c
    }, f) => {
      const { composer: p } = we, d = n || r || !o, [v, h] = ge(""), [g, m] = ge(-1), b = Bi((A) => A.files), w = Bi((A) => A.setFiles), C = Bi((A) => A.deleteFile), S = Bi((A) => A.uploadFile), E = ax((A) => A.addMessageToHistory), I = !!v || b.filter((A) => A.status === "uploaded").length > 0, N = () => {
        const A = b.filter((U) => U.status === "uploaded");
        if (!A.length && !v) return;
        const O = (A == null ? void 0 : A.map((U) => {
          const L = U.url, M = U.type;
          return {
            video: { type: "video", videoUrl: L },
            audio: { type: "audio", audioUrl: L },
            image: { type: "image", imageUrl: L }
          }[M] ?? { title: U.name, type: "file", fileUrl: L };
        })) ?? [];
        v && O.push({ type: "text", text: v });
        let D;
        O.length == 1 ? D = O[0] : D = {
          type: "bloc",
          items: O.map((L) => {
            const { type: M, ..._ } = L;
            return {
              type: M,
              payload: _
            };
          })
        }, l == null || l(D), w([]), h(""), E(v), m(-1);
      };
      return r ? null : /* @__PURE__ */ $.jsxs($.Fragment, { children: [
        /* @__PURE__ */ $.jsxs(
          "div",
          {
            "data-disabled": d,
            ...c,
            className: oi(p.container.className, e),
            ref: f,
            children: [
              b.length > 0 && /* @__PURE__ */ $.jsx("div", { ...p == null ? void 0 : p.fileContainer, children: b.map((A) => /* @__PURE__ */ $.jsx(R_, { ...A, removeFile: C }, A.name)) }),
              /* @__PURE__ */ $.jsxs("div", { ...p.inputContainer, children: [
                i && /* @__PURE__ */ $.jsx(
                  I_,
                  {
                    disabled: d || !u,
                    onFileSelected: (A) => {
                      u && S(A, u);
                    }
                  }
                ),
                /* @__PURE__ */ $.jsx(
                  q_,
                  {
                    inputRef: t,
                    composerPlaceholder: a,
                    composerDisabled: d,
                    textInput: v,
                    historyIndex: g,
                    setTextInput: h,
                    setHistoryIndex: m,
                    sendComposerMessage: N
                  }
                ),
                !d && /* @__PURE__ */ $.jsxs($.Fragment, { children: [
                  /* @__PURE__ */ $.jsx(
                    tP,
                    {
                      ...p.sendbutton,
                      role: "button",
                      tabIndex: 0,
                      "aria-label": "Send Message Button",
                      "data-show": I,
                      onClick: () => N()
                    }
                  ),
                  /* @__PURE__ */ $.jsx(G_, { disabled: I, setTextInput: h })
                ] })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ $.jsx(
          Ob,
          {
            components: {
              a: ({ node: A, ...O }) => /* @__PURE__ */ $.jsx("a", { ...O, target: "_blank", rel: "noreferrer noopener" })
            },
            allowedElements: ["a", "strong", "code", "em", "p", "span"],
            ...p.footer,
            children: s
          }
        )
      ] });
    }
  )
);
var xc = { exports: {} }, ta = { exports: {} }, _e = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dv;
function X_() {
  if (dv) return _e;
  dv = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, d = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
  function w(S) {
    if (typeof S == "object" && S !== null) {
      var E = S.$$typeof;
      switch (E) {
        case t:
          switch (S = S.type, S) {
            case l:
            case u:
            case r:
            case o:
            case i:
            case f:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case s:
                case c:
                case v:
                case d:
                case a:
                  return S;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function C(S) {
    return w(S) === u;
  }
  return _e.AsyncMode = l, _e.ConcurrentMode = u, _e.ContextConsumer = s, _e.ContextProvider = a, _e.Element = t, _e.ForwardRef = c, _e.Fragment = r, _e.Lazy = v, _e.Memo = d, _e.Portal = n, _e.Profiler = o, _e.StrictMode = i, _e.Suspense = f, _e.isAsyncMode = function(S) {
    return C(S) || w(S) === l;
  }, _e.isConcurrentMode = C, _e.isContextConsumer = function(S) {
    return w(S) === s;
  }, _e.isContextProvider = function(S) {
    return w(S) === a;
  }, _e.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === t;
  }, _e.isForwardRef = function(S) {
    return w(S) === c;
  }, _e.isFragment = function(S) {
    return w(S) === r;
  }, _e.isLazy = function(S) {
    return w(S) === v;
  }, _e.isMemo = function(S) {
    return w(S) === d;
  }, _e.isPortal = function(S) {
    return w(S) === n;
  }, _e.isProfiler = function(S) {
    return w(S) === o;
  }, _e.isStrictMode = function(S) {
    return w(S) === i;
  }, _e.isSuspense = function(S) {
    return w(S) === f;
  }, _e.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === r || S === u || S === o || S === i || S === f || S === p || typeof S == "object" && S !== null && (S.$$typeof === v || S.$$typeof === d || S.$$typeof === a || S.$$typeof === s || S.$$typeof === c || S.$$typeof === g || S.$$typeof === m || S.$$typeof === b || S.$$typeof === h);
  }, _e.typeOf = w, _e;
}
var Me = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pv;
function J_() {
  return pv || (pv = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, d = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
    function w(V) {
      return typeof V == "string" || typeof V == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      V === r || V === u || V === o || V === i || V === f || V === p || typeof V == "object" && V !== null && (V.$$typeof === v || V.$$typeof === d || V.$$typeof === a || V.$$typeof === s || V.$$typeof === c || V.$$typeof === g || V.$$typeof === m || V.$$typeof === b || V.$$typeof === h);
    }
    function C(V) {
      if (typeof V == "object" && V !== null) {
        var ne = V.$$typeof;
        switch (ne) {
          case t:
            var se = V.type;
            switch (se) {
              case l:
              case u:
              case r:
              case o:
              case i:
              case f:
                return se;
              default:
                var fe = se && se.$$typeof;
                switch (fe) {
                  case s:
                  case c:
                  case v:
                  case d:
                  case a:
                    return fe;
                  default:
                    return ne;
                }
            }
          case n:
            return ne;
        }
      }
    }
    var S = l, E = u, I = s, N = a, A = t, O = c, D = r, U = v, L = d, M = n, _ = o, z = i, q = f, H = !1;
    function P(V) {
      return H || (H = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), y(V) || C(V) === l;
    }
    function y(V) {
      return C(V) === u;
    }
    function T(V) {
      return C(V) === s;
    }
    function j(V) {
      return C(V) === a;
    }
    function x(V) {
      return typeof V == "object" && V !== null && V.$$typeof === t;
    }
    function F(V) {
      return C(V) === c;
    }
    function G(V) {
      return C(V) === r;
    }
    function K(V) {
      return C(V) === v;
    }
    function Y(V) {
      return C(V) === d;
    }
    function Q(V) {
      return C(V) === n;
    }
    function Z(V) {
      return C(V) === o;
    }
    function X(V) {
      return C(V) === i;
    }
    function J(V) {
      return C(V) === f;
    }
    Me.AsyncMode = S, Me.ConcurrentMode = E, Me.ContextConsumer = I, Me.ContextProvider = N, Me.Element = A, Me.ForwardRef = O, Me.Fragment = D, Me.Lazy = U, Me.Memo = L, Me.Portal = M, Me.Profiler = _, Me.StrictMode = z, Me.Suspense = q, Me.isAsyncMode = P, Me.isConcurrentMode = y, Me.isContextConsumer = T, Me.isContextProvider = j, Me.isElement = x, Me.isForwardRef = F, Me.isFragment = G, Me.isLazy = K, Me.isMemo = Y, Me.isPortal = Q, Me.isProfiler = Z, Me.isStrictMode = X, Me.isSuspense = J, Me.isValidElementType = w, Me.typeOf = C;
  }()), Me;
}
var hv;
function Os() {
  return hv || (hv = 1, process.env.NODE_ENV === "production" ? ta.exports = X_() : ta.exports = J_()), ta.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Nl, vv;
function fw() {
  if (vv) return Nl;
  vv = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Nl = i() ? Object.assign : function(o, a) {
    for (var s, l = r(o), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var f in s)
        t.call(s, f) && (l[f] = s[f]);
      if (e) {
        u = e(s);
        for (var p = 0; p < u.length; p++)
          n.call(s, u[p]) && (l[u[p]] = s[u[p]]);
      }
    }
    return l;
  }, Nl;
}
var Ll, mv;
function Qf() {
  if (mv) return Ll;
  mv = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Ll = e, Ll;
}
var Fl, gv;
function dw() {
  return gv || (gv = 1, Fl = Function.call.bind(Object.prototype.hasOwnProperty)), Fl;
}
var Bl, yv;
function Q_() {
  if (yv) return Bl;
  yv = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Qf(), n = {}, r = dw();
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (r(o, c)) {
          var f;
          try {
            if (typeof o[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = o[c](a, c, l, s, null, t);
          } catch (v) {
            f = v;
          }
          if (f && !(f instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var d = u ? u() : "";
            e(
              "Failed " + s + " type: " + f.message + (d ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Bl = i, Bl;
}
var zl, bv;
function Z_() {
  if (bv) return zl;
  bv = 1;
  var e = Os(), t = fw(), n = Qf(), r = dw(), i = Q_(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return zl = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function f(y) {
      var T = y && (u && y[u] || y[c]);
      if (typeof T == "function")
        return T;
    }
    var p = "<<anonymous>>", d = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: b(),
      arrayOf: w,
      element: C(),
      elementType: S(),
      instanceOf: E,
      node: O(),
      objectOf: N,
      oneOf: I,
      oneOfType: A,
      shape: U,
      exact: L
    };
    function v(y, T) {
      return y === T ? y !== 0 || 1 / y === 1 / T : y !== y && T !== T;
    }
    function h(y, T) {
      this.message = y, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function g(y) {
      if (process.env.NODE_ENV !== "production")
        var T = {}, j = 0;
      function x(G, K, Y, Q, Z, X, J) {
        if (Q = Q || p, X = X || Y, J !== n) {
          if (l) {
            var V = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw V.name = "Invariant Violation", V;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ne = Q + ":" + Y;
            !T[ne] && // Avoid spamming the console because they are often not actionable except for lib authors
            j < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + X + "` prop on `" + Q + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[ne] = !0, j++);
          }
        }
        return K[Y] == null ? G ? K[Y] === null ? new h("The " + Z + " `" + X + "` is marked as required " + ("in `" + Q + "`, but its value is `null`.")) : new h("The " + Z + " `" + X + "` is marked as required in " + ("`" + Q + "`, but its value is `undefined`.")) : null : y(K, Y, Q, Z, X);
      }
      var F = x.bind(null, !1);
      return F.isRequired = x.bind(null, !0), F;
    }
    function m(y) {
      function T(j, x, F, G, K, Y) {
        var Q = j[x], Z = z(Q);
        if (Z !== y) {
          var X = q(Q);
          return new h(
            "Invalid " + G + " `" + K + "` of type " + ("`" + X + "` supplied to `" + F + "`, expected ") + ("`" + y + "`."),
            { expectedType: y }
          );
        }
        return null;
      }
      return g(T);
    }
    function b() {
      return g(a);
    }
    function w(y) {
      function T(j, x, F, G, K) {
        if (typeof y != "function")
          return new h("Property `" + K + "` of component `" + F + "` has invalid PropType notation inside arrayOf.");
        var Y = j[x];
        if (!Array.isArray(Y)) {
          var Q = z(Y);
          return new h("Invalid " + G + " `" + K + "` of type " + ("`" + Q + "` supplied to `" + F + "`, expected an array."));
        }
        for (var Z = 0; Z < Y.length; Z++) {
          var X = y(Y, Z, F, G, K + "[" + Z + "]", n);
          if (X instanceof Error)
            return X;
        }
        return null;
      }
      return g(T);
    }
    function C() {
      function y(T, j, x, F, G) {
        var K = T[j];
        if (!s(K)) {
          var Y = z(K);
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + Y + "` supplied to `" + x + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(y);
    }
    function S() {
      function y(T, j, x, F, G) {
        var K = T[j];
        if (!e.isValidElementType(K)) {
          var Y = z(K);
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + Y + "` supplied to `" + x + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(y);
    }
    function E(y) {
      function T(j, x, F, G, K) {
        if (!(j[x] instanceof y)) {
          var Y = y.name || p, Q = P(j[x]);
          return new h("Invalid " + G + " `" + K + "` of type " + ("`" + Q + "` supplied to `" + F + "`, expected ") + ("instance of `" + Y + "`."));
        }
        return null;
      }
      return g(T);
    }
    function I(y) {
      if (!Array.isArray(y))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function T(j, x, F, G, K) {
        for (var Y = j[x], Q = 0; Q < y.length; Q++)
          if (v(Y, y[Q]))
            return null;
        var Z = JSON.stringify(y, function(J, V) {
          var ne = q(V);
          return ne === "symbol" ? String(V) : V;
        });
        return new h("Invalid " + G + " `" + K + "` of value `" + String(Y) + "` " + ("supplied to `" + F + "`, expected one of " + Z + "."));
      }
      return g(T);
    }
    function N(y) {
      function T(j, x, F, G, K) {
        if (typeof y != "function")
          return new h("Property `" + K + "` of component `" + F + "` has invalid PropType notation inside objectOf.");
        var Y = j[x], Q = z(Y);
        if (Q !== "object")
          return new h("Invalid " + G + " `" + K + "` of type " + ("`" + Q + "` supplied to `" + F + "`, expected an object."));
        for (var Z in Y)
          if (r(Y, Z)) {
            var X = y(Y, Z, F, G, K + "." + Z, n);
            if (X instanceof Error)
              return X;
          }
        return null;
      }
      return g(T);
    }
    function A(y) {
      if (!Array.isArray(y))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var T = 0; T < y.length; T++) {
        var j = y[T];
        if (typeof j != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + H(j) + " at index " + T + "."
          ), a;
      }
      function x(F, G, K, Y, Q) {
        for (var Z = [], X = 0; X < y.length; X++) {
          var J = y[X], V = J(F, G, K, Y, Q, n);
          if (V == null)
            return null;
          V.data && r(V.data, "expectedType") && Z.push(V.data.expectedType);
        }
        var ne = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new h("Invalid " + Y + " `" + Q + "` supplied to " + ("`" + K + "`" + ne + "."));
      }
      return g(x);
    }
    function O() {
      function y(T, j, x, F, G) {
        return M(T[j]) ? null : new h("Invalid " + F + " `" + G + "` supplied to " + ("`" + x + "`, expected a ReactNode."));
      }
      return g(y);
    }
    function D(y, T, j, x, F) {
      return new h(
        (y || "React class") + ": " + T + " type `" + j + "." + x + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + F + "`."
      );
    }
    function U(y) {
      function T(j, x, F, G, K) {
        var Y = j[x], Q = z(Y);
        if (Q !== "object")
          return new h("Invalid " + G + " `" + K + "` of type `" + Q + "` " + ("supplied to `" + F + "`, expected `object`."));
        for (var Z in y) {
          var X = y[Z];
          if (typeof X != "function")
            return D(F, G, K, Z, q(X));
          var J = X(Y, Z, F, G, K + "." + Z, n);
          if (J)
            return J;
        }
        return null;
      }
      return g(T);
    }
    function L(y) {
      function T(j, x, F, G, K) {
        var Y = j[x], Q = z(Y);
        if (Q !== "object")
          return new h("Invalid " + G + " `" + K + "` of type `" + Q + "` " + ("supplied to `" + F + "`, expected `object`."));
        var Z = t({}, j[x], y);
        for (var X in Z) {
          var J = y[X];
          if (r(y, X) && typeof J != "function")
            return D(F, G, K, X, q(J));
          if (!J)
            return new h(
              "Invalid " + G + " `" + K + "` key `" + X + "` supplied to `" + F + "`.\nBad object: " + JSON.stringify(j[x], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(y), null, "  ")
            );
          var V = J(Y, X, F, G, K + "." + X, n);
          if (V)
            return V;
        }
        return null;
      }
      return g(T);
    }
    function M(y) {
      switch (typeof y) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !y;
        case "object":
          if (Array.isArray(y))
            return y.every(M);
          if (y === null || s(y))
            return !0;
          var T = f(y);
          if (T) {
            var j = T.call(y), x;
            if (T !== y.entries) {
              for (; !(x = j.next()).done; )
                if (!M(x.value))
                  return !1;
            } else
              for (; !(x = j.next()).done; ) {
                var F = x.value;
                if (F && !M(F[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function _(y, T) {
      return y === "symbol" ? !0 : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : !1;
    }
    function z(y) {
      var T = typeof y;
      return Array.isArray(y) ? "array" : y instanceof RegExp ? "object" : _(T, y) ? "symbol" : T;
    }
    function q(y) {
      if (typeof y > "u" || y === null)
        return "" + y;
      var T = z(y);
      if (T === "object") {
        if (y instanceof Date)
          return "date";
        if (y instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function H(y) {
      var T = q(y);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function P(y) {
      return !y.constructor || !y.constructor.name ? p : y.constructor.name;
    }
    return d.checkPropTypes = i, d.resetWarningCache = i.resetWarningCache, d.PropTypes = d, d;
  }, zl;
}
var Wl, xv;
function eM() {
  if (xv) return Wl;
  xv = 1;
  var e = Qf();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Wl = function() {
    function r(a, s, l, u, c, f) {
      if (f !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, Wl;
}
if (process.env.NODE_ENV !== "production") {
  var tM = Os(), nM = !0;
  xc.exports = Z_()(tM.isElement, nM);
} else
  xc.exports = eM()();
var rM = xc.exports;
const We = /* @__PURE__ */ $e(rM);
var iM = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function wo(e, t) {
  var n = oM(e);
  if (typeof n.path != "string") {
    var r = e.webkitRelativePath;
    Object.defineProperty(n, "path", {
      value: typeof t == "string" ? t : typeof r == "string" && r.length > 0 ? r : e.name,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return n;
}
function oM(e) {
  var t = e.name, n = t && t.lastIndexOf(".") !== -1;
  if (n && !e.type) {
    var r = t.split(".").pop().toLowerCase(), i = iM.get(r);
    i && Object.defineProperty(e, "type", {
      value: i,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return e;
}
var aM = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function sM(e) {
  return hi(this, void 0, void 0, function() {
    return vi(this, function(t) {
      return Xa(e) && lM(e.dataTransfer) ? [2, dM(e.dataTransfer, e.type)] : uM(e) ? [2, cM(e)] : Array.isArray(e) && e.every(function(n) {
        return "getFile" in n && typeof n.getFile == "function";
      }) ? [2, fM(e)] : [2, []];
    });
  });
}
function lM(e) {
  return Xa(e);
}
function uM(e) {
  return Xa(e) && Xa(e.target);
}
function Xa(e) {
  return typeof e == "object" && e !== null;
}
function cM(e) {
  return wc(e.target.files).map(function(t) {
    return wo(t);
  });
}
function fM(e) {
  return hi(this, void 0, void 0, function() {
    var t;
    return vi(this, function(n) {
      switch (n.label) {
        case 0:
          return [4, Promise.all(e.map(function(r) {
            return r.getFile();
          }))];
        case 1:
          return t = n.sent(), [2, t.map(function(r) {
            return wo(r);
          })];
      }
    });
  });
}
function dM(e, t) {
  return hi(this, void 0, void 0, function() {
    var n, r;
    return vi(this, function(i) {
      switch (i.label) {
        case 0:
          return e.items ? (n = wc(e.items).filter(function(o) {
            return o.kind === "file";
          }), t !== "drop" ? [2, n] : [4, Promise.all(n.map(pM))]) : [3, 2];
        case 1:
          return r = i.sent(), [2, wv(pw(r))];
        case 2:
          return [2, wv(wc(e.files).map(function(o) {
            return wo(o);
          }))];
      }
    });
  });
}
function wv(e) {
  return e.filter(function(t) {
    return aM.indexOf(t.name) === -1;
  });
}
function wc(e) {
  if (e === null)
    return [];
  for (var t = [], n = 0; n < e.length; n++) {
    var r = e[n];
    t.push(r);
  }
  return t;
}
function pM(e) {
  if (typeof e.webkitGetAsEntry != "function")
    return Sv(e);
  var t = e.webkitGetAsEntry();
  return t && t.isDirectory ? hw(t) : Sv(e);
}
function pw(e) {
  return e.reduce(function(t, n) {
    return hc(hc([], Mh(t), !1), Mh(Array.isArray(n) ? pw(n) : [n]), !1);
  }, []);
}
function Sv(e) {
  var t = e.getAsFile();
  if (!t)
    return Promise.reject("".concat(e, " is not a File"));
  var n = wo(t);
  return Promise.resolve(n);
}
function hM(e) {
  return hi(this, void 0, void 0, function() {
    return vi(this, function(t) {
      return [2, e.isDirectory ? hw(e) : vM(e)];
    });
  });
}
function hw(e) {
  var t = e.createReader();
  return new Promise(function(n, r) {
    var i = [];
    function o() {
      var a = this;
      t.readEntries(function(s) {
        return hi(a, void 0, void 0, function() {
          var l, u, c;
          return vi(this, function(f) {
            switch (f.label) {
              case 0:
                if (s.length) return [3, 5];
                f.label = 1;
              case 1:
                return f.trys.push([1, 3, , 4]), [4, Promise.all(i)];
              case 2:
                return l = f.sent(), n(l), [3, 4];
              case 3:
                return u = f.sent(), r(u), [3, 4];
              case 4:
                return [3, 6];
              case 5:
                c = Promise.all(s.map(hM)), i.push(c), o(), f.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(s) {
        r(s);
      });
    }
    o();
  });
}
function vM(e) {
  return hi(this, void 0, void 0, function() {
    return vi(this, function(t) {
      return [2, new Promise(function(n, r) {
        e.file(function(i) {
          var o = wo(i, e.fullPath);
          n(o);
        }, function(i) {
          r(i);
        });
      })];
    });
  });
}
var mM = function(e, t) {
  if (e && t) {
    var n = Array.isArray(t) ? t : t.split(",");
    if (n.length === 0)
      return !0;
    var r = e.name || "", i = (e.type || "").toLowerCase(), o = i.replace(/\/.*$/, "");
    return n.some(function(a) {
      var s = a.trim().toLowerCase();
      return s.charAt(0) === "." ? r.toLowerCase().endsWith(s) : s.endsWith("/*") ? o === s.replace(/\/.*$/, "") : i === s;
    });
  }
  return !0;
};
function Ev(e) {
  return bM(e) || yM(e) || mw(e) || gM();
}
function gM() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function yM(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function bM(e) {
  if (Array.isArray(e)) return Sc(e);
}
function kv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kv(Object(n), !0).forEach(function(r) {
      vw(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function vw(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function ro(e, t) {
  return SM(e) || wM(e, t) || mw(e, t) || xM();
}
function xM() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function mw(e, t) {
  if (e) {
    if (typeof e == "string") return Sc(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Sc(e, t);
  }
}
function Sc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function wM(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], i = !0, o = !1, a, s;
    try {
      for (n = n.call(e); !(i = (a = n.next()).done) && (r.push(a.value), !(t && r.length === t)); i = !0)
        ;
    } catch (l) {
      o = !0, s = l;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (o) throw s;
      }
    }
    return r;
  }
}
function SM(e) {
  if (Array.isArray(e)) return e;
}
var EM = "file-invalid-type", kM = "file-too-large", CM = "file-too-small", $M = "too-many-files", TM = function(t) {
  t = Array.isArray(t) && t.length === 1 ? t[0] : t;
  var n = Array.isArray(t) ? "one of ".concat(t.join(", ")) : t;
  return {
    code: EM,
    message: "File type must be ".concat(n)
  };
}, $v = function(t) {
  return {
    code: kM,
    message: "File is larger than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, Tv = function(t) {
  return {
    code: CM,
    message: "File is smaller than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, OM = {
  code: $M,
  message: "Too many files"
};
function gw(e, t) {
  var n = e.type === "application/x-moz-file" || mM(e, t);
  return [n, n ? null : TM(t)];
}
function yw(e, t, n) {
  if (pr(e.size))
    if (pr(t) && pr(n)) {
      if (e.size > n) return [!1, $v(n)];
      if (e.size < t) return [!1, Tv(t)];
    } else {
      if (pr(t) && e.size < t) return [!1, Tv(t)];
      if (pr(n) && e.size > n) return [!1, $v(n)];
    }
  return [!0, null];
}
function pr(e) {
  return e != null;
}
function IM(e) {
  var t = e.files, n = e.accept, r = e.minSize, i = e.maxSize, o = e.multiple, a = e.maxFiles, s = e.validator;
  return !o && t.length > 1 || o && a >= 1 && t.length > a ? !1 : t.every(function(l) {
    var u = gw(l, n), c = ro(u, 1), f = c[0], p = yw(l, r, i), d = ro(p, 1), v = d[0], h = s ? s(l) : null;
    return f && v && !h;
  });
}
function Ja(e) {
  return typeof e.isPropagationStopped == "function" ? e.isPropagationStopped() : typeof e.cancelBubble < "u" ? e.cancelBubble : !1;
}
function na(e) {
  return e.dataTransfer ? Array.prototype.some.call(e.dataTransfer.types, function(t) {
    return t === "Files" || t === "application/x-moz-file";
  }) : !!e.target && !!e.target.files;
}
function Ov(e) {
  e.preventDefault();
}
function RM(e) {
  return e.indexOf("MSIE") !== -1 || e.indexOf("Trident/") !== -1;
}
function PM(e) {
  return e.indexOf("Edge/") !== -1;
}
function AM() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return RM(e) || PM(e);
}
function vn() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
      o[a - 1] = arguments[a];
    return t.some(function(s) {
      return !Ja(r) && s && s.apply(void 0, [r].concat(o)), Ja(r);
    });
  };
}
function DM() {
  return "showOpenFilePicker" in window;
}
function _M(e) {
  if (pr(e)) {
    var t = Object.entries(e).filter(function(n) {
      var r = ro(n, 2), i = r[0], o = r[1], a = !0;
      return bw(i) || (console.warn('Skipped "'.concat(i, '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')), a = !1), (!Array.isArray(o) || !o.every(xw)) && (console.warn('Skipped "'.concat(i, '" because an invalid file extension was provided.')), a = !1), a;
    }).reduce(function(n, r) {
      var i = ro(r, 2), o = i[0], a = i[1];
      return Cv(Cv({}, n), {}, vw({}, o, a));
    }, {});
    return [{
      // description is required due to https://crbug.com/1264708
      description: "Files",
      accept: t
    }];
  }
  return e;
}
function MM(e) {
  if (pr(e))
    return Object.entries(e).reduce(function(t, n) {
      var r = ro(n, 2), i = r[0], o = r[1];
      return [].concat(Ev(t), [i], Ev(o));
    }, []).filter(function(t) {
      return bw(t) || xw(t);
    }).join(",");
}
function jM(e) {
  return e instanceof DOMException && (e.name === "AbortError" || e.code === e.ABORT_ERR);
}
function NM(e) {
  return e instanceof DOMException && (e.name === "SecurityError" || e.code === e.SECURITY_ERR);
}
function bw(e) {
  return e === "audio/*" || e === "video/*" || e === "image/*" || e === "text/*" || /\w+\/[-+.\w]+/g.test(e);
}
function xw(e) {
  return /^.*\.[\w]+$/.test(e);
}
var LM = ["children"], FM = ["open"], BM = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"], zM = ["refKey", "onChange", "onClick"];
function WM(e) {
  return VM(e) || HM(e) || ww(e) || UM();
}
function UM() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function HM(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function VM(e) {
  if (Array.isArray(e)) return Ec(e);
}
function Ul(e, t) {
  return GM(e) || qM(e, t) || ww(e, t) || KM();
}
function KM() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ww(e, t) {
  if (e) {
    if (typeof e == "string") return Ec(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ec(e, t);
  }
}
function Ec(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function qM(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], i = !0, o = !1, a, s;
    try {
      for (n = n.call(e); !(i = (a = n.next()).done) && (r.push(a.value), !(t && r.length === t)); i = !0)
        ;
    } catch (l) {
      o = !0, s = l;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (o) throw s;
      }
    }
    return r;
  }
}
function GM(e) {
  if (Array.isArray(e)) return e;
}
function Iv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Je(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Iv(Object(n), !0).forEach(function(r) {
      kc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Iv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function kc(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Qa(e, t) {
  if (e == null) return {};
  var n = YM(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function YM(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Is = /* @__PURE__ */ Ot(function(e, t) {
  var n = e.children, r = Qa(e, LM), i = XM(r), o = i.open, a = Qa(i, FM);
  return uE(t, function() {
    return {
      open: o
    };
  }, [o]), /* @__PURE__ */ Le.createElement(cE, null, n(Je(Je({}, a), {}, {
    open: o
  })));
});
Is.displayName = "Dropzone";
var Sw = {
  disabled: !1,
  getFilesFromEvent: sM,
  maxSize: 1 / 0,
  minSize: 0,
  multiple: !0,
  maxFiles: 0,
  preventDropOnDocument: !0,
  noClick: !1,
  noKeyboard: !1,
  noDrag: !1,
  noDragEventsBubbling: !1,
  validator: null,
  useFsAccessApi: !0,
  autoFocus: !1
};
Is.defaultProps = Sw;
Is.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: We.func,
  /**
   * Set accepted file types.
   * Checkout https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker types option for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all (https://github.com/react-dropzone/react-dropzone/issues/276).
   */
  accept: We.objectOf(We.arrayOf(We.string)),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: We.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: We.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: We.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: We.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: We.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: We.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: We.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: We.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: We.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: We.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: We.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: We.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: We.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: We.bool,
  /**
   * Set to true to focus the root element on render
   */
  autoFocus: We.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: We.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: We.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: We.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: We.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: We.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: We.func,
  /**
   * Cb for when there's some error from any of the promises.
   *
   * @param {Error} error
   */
  onError: We.func,
  /**
   * Custom validation function. It must return null if there's no errors.
   * @param {File} file
   * @returns {FileError|FileError[]|null}
   */
  validator: We.func
};
var Cc = {
  isFocused: !1,
  isFileDialogActive: !1,
  isDragActive: !1,
  isDragAccept: !1,
  isDragReject: !1,
  acceptedFiles: [],
  fileRejections: []
};
function XM() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = Je(Je({}, Sw), e), n = t.accept, r = t.disabled, i = t.getFilesFromEvent, o = t.maxSize, a = t.minSize, s = t.multiple, l = t.maxFiles, u = t.onDragEnter, c = t.onDragLeave, f = t.onDragOver, p = t.onDrop, d = t.onDropAccepted, v = t.onDropRejected, h = t.onFileDialogCancel, g = t.onFileDialogOpen, m = t.useFsAccessApi, b = t.autoFocus, w = t.preventDropOnDocument, C = t.noClick, S = t.noKeyboard, E = t.noDrag, I = t.noDragEventsBubbling, N = t.onError, A = t.validator, O = st(function() {
    return MM(n);
  }, [n]), D = st(function() {
    return _M(n);
  }, [n]), U = st(function() {
    return typeof g == "function" ? g : Rv;
  }, [g]), L = st(function() {
    return typeof h == "function" ? h : Rv;
  }, [h]), M = Ke(null), _ = Ke(null), z = fE(JM, Cc), q = Ul(z, 2), H = q[0], P = q[1], y = H.isFocused, T = H.isFileDialogActive, j = Ke(typeof window < "u" && window.isSecureContext && m && DM()), x = function() {
    !j.current && T && setTimeout(function() {
      if (_.current) {
        var ue = _.current.files;
        ue.length || (P({
          type: "closeDialog"
        }), L());
      }
    }, 300);
  };
  vt(function() {
    return window.addEventListener("focus", x, !1), function() {
      window.removeEventListener("focus", x, !1);
    };
  }, [_, T, L, j]);
  var F = Ke([]), G = function(ue) {
    M.current && M.current.contains(ue.target) || (ue.preventDefault(), F.current = []);
  };
  vt(function() {
    return w && (document.addEventListener("dragover", Ov, !1), document.addEventListener("drop", G, !1)), function() {
      w && (document.removeEventListener("dragover", Ov), document.removeEventListener("drop", G));
    };
  }, [M, w]), vt(function() {
    return !r && b && M.current && M.current.focus(), function() {
    };
  }, [M, b, r]);
  var K = Oe(function(ie) {
    N ? N(ie) : console.error(ie);
  }, [N]), Y = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie), F.current = [].concat(WM(F.current), [ie.target]), na(ie) && Promise.resolve(i(ie)).then(function(ue) {
      if (!(Ja(ie) && !I)) {
        var W = ue.length, B = W > 0 && IM({
          files: ue,
          accept: O,
          minSize: a,
          maxSize: o,
          multiple: s,
          maxFiles: l,
          validator: A
        }), te = W > 0 && !B;
        P({
          isDragAccept: B,
          isDragReject: te,
          isDragActive: !0,
          type: "setDraggedFiles"
        }), u && u(ie);
      }
    }).catch(function(ue) {
      return K(ue);
    });
  }, [i, u, K, I, O, a, o, s, l, A]), Q = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie);
    var ue = na(ie);
    if (ue && ie.dataTransfer)
      try {
        ie.dataTransfer.dropEffect = "copy";
      } catch {
      }
    return ue && f && f(ie), !1;
  }, [f, I]), Z = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie);
    var ue = F.current.filter(function(B) {
      return M.current && M.current.contains(B);
    }), W = ue.indexOf(ie.target);
    W !== -1 && ue.splice(W, 1), F.current = ue, !(ue.length > 0) && (P({
      type: "setDraggedFiles",
      isDragActive: !1,
      isDragAccept: !1,
      isDragReject: !1
    }), na(ie) && c && c(ie));
  }, [M, c, I]), X = Oe(function(ie, ue) {
    var W = [], B = [];
    ie.forEach(function(te) {
      var ae = gw(te, O), ce = Ul(ae, 2), ve = ce[0], qe = ce[1], Ge = yw(te, a, o), gt = Ul(Ge, 2), rt = gt[0], Re = gt[1], it = A ? A(te) : null;
      if (ve && rt && !it)
        W.push(te);
      else {
        var Ze = [qe, Re];
        it && (Ze = Ze.concat(it)), B.push({
          file: te,
          errors: Ze.filter(function(qt) {
            return qt;
          })
        });
      }
    }), (!s && W.length > 1 || s && l >= 1 && W.length > l) && (W.forEach(function(te) {
      B.push({
        file: te,
        errors: [OM]
      });
    }), W.splice(0)), P({
      acceptedFiles: W,
      fileRejections: B,
      type: "setFiles"
    }), p && p(W, B, ue), B.length > 0 && v && v(B, ue), W.length > 0 && d && d(W, ue);
  }, [P, s, O, a, o, l, p, d, v, A]), J = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie), F.current = [], na(ie) && Promise.resolve(i(ie)).then(function(ue) {
      Ja(ie) && !I || X(ue, ie);
    }).catch(function(ue) {
      return K(ue);
    }), P({
      type: "reset"
    });
  }, [i, X, K, I]), V = Oe(function() {
    if (j.current) {
      P({
        type: "openDialog"
      }), U();
      var ie = {
        multiple: s,
        types: D
      };
      window.showOpenFilePicker(ie).then(function(ue) {
        return i(ue);
      }).then(function(ue) {
        X(ue, null), P({
          type: "closeDialog"
        });
      }).catch(function(ue) {
        jM(ue) ? (L(ue), P({
          type: "closeDialog"
        })) : NM(ue) ? (j.current = !1, _.current ? (_.current.value = null, _.current.click()) : K(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))) : K(ue);
      });
      return;
    }
    _.current && (P({
      type: "openDialog"
    }), U(), _.current.value = null, _.current.click());
  }, [P, U, L, m, X, K, D, s]), ne = Oe(function(ie) {
    !M.current || !M.current.isEqualNode(ie.target) || (ie.key === " " || ie.key === "Enter" || ie.keyCode === 32 || ie.keyCode === 13) && (ie.preventDefault(), V());
  }, [M, V]), se = Oe(function() {
    P({
      type: "focus"
    });
  }, []), fe = Oe(function() {
    P({
      type: "blur"
    });
  }, []), oe = Oe(function() {
    C || (AM() ? setTimeout(V, 0) : V());
  }, [C, V]), pe = function(ue) {
    return r ? null : ue;
  }, Se = function(ue) {
    return S ? null : pe(ue);
  }, Ie = function(ue) {
    return E ? null : pe(ue);
  }, nt = function(ue) {
    I && ue.stopPropagation();
  }, St = st(function() {
    return function() {
      var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ue = ie.refKey, W = ue === void 0 ? "ref" : ue, B = ie.role, te = ie.onKeyDown, ae = ie.onFocus, ce = ie.onBlur, ve = ie.onClick, qe = ie.onDragEnter, Ge = ie.onDragOver, gt = ie.onDragLeave, rt = ie.onDrop, Re = Qa(ie, BM);
      return Je(Je(kc({
        onKeyDown: Se(vn(te, ne)),
        onFocus: Se(vn(ae, se)),
        onBlur: Se(vn(ce, fe)),
        onClick: pe(vn(ve, oe)),
        onDragEnter: Ie(vn(qe, Y)),
        onDragOver: Ie(vn(Ge, Q)),
        onDragLeave: Ie(vn(gt, Z)),
        onDrop: Ie(vn(rt, J)),
        role: typeof B == "string" && B !== "" ? B : "presentation"
      }, W, M), !r && !S ? {
        tabIndex: 0
      } : {}), Re);
    };
  }, [M, ne, se, fe, oe, Y, Q, Z, J, S, E, r]), Et = Oe(function(ie) {
    ie.stopPropagation();
  }, []), kt = st(function() {
    return function() {
      var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ue = ie.refKey, W = ue === void 0 ? "ref" : ue, B = ie.onChange, te = ie.onClick, ae = Qa(ie, zM), ce = kc({
        accept: O,
        multiple: s,
        type: "file",
        style: {
          display: "none"
        },
        onChange: pe(vn(B, J)),
        onClick: pe(vn(te, Et)),
        tabIndex: -1
      }, W, _);
      return Je(Je({}, ce), ae);
    };
  }, [_, n, s, J, r]);
  return Je(Je({}, H), {}, {
    isFocused: y && !r,
    getRootProps: St,
    getInputProps: kt,
    rootRef: M,
    inputRef: _,
    open: pe(V)
  });
}
function JM(e, t) {
  switch (t.type) {
    case "focus":
      return Je(Je({}, e), {}, {
        isFocused: !0
      });
    case "blur":
      return Je(Je({}, e), {}, {
        isFocused: !1
      });
    case "openDialog":
      return Je(Je({}, Cc), {}, {
        isFileDialogActive: !0
      });
    case "closeDialog":
      return Je(Je({}, e), {}, {
        isFileDialogActive: !1
      });
    case "setDraggedFiles":
      return Je(Je({}, e), {}, {
        isDragActive: t.isDragActive,
        isDragAccept: t.isDragAccept,
        isDragReject: t.isDragReject
      });
    case "setFiles":
      return Je(Je({}, e), {}, {
        acceptedFiles: t.acceptedFiles,
        fileRejections: t.fileRejections
      });
    case "reset":
      return Je({}, Cc);
    default:
      return e;
  }
}
function Rv() {
}
const Pv = ({ children: e }) => {
  const [t, n] = ge(!1), [r, i] = ge(""), [o, a] = ge(""), [s, l] = ge(""), [u, c] = ge(() => {
  }), [f, p] = ge(""), [d, v] = ge(null), h = ({
    title: m,
    description: b,
    confirmButton: w,
    onConfirm: C,
    cancelButton: S,
    content: E
  }) => {
    i(m), a(b), l(w), c(() => C), p(S), v(E), n(!0);
  }, g = () => {
    n(!1);
  };
  return /* @__PURE__ */ $.jsxs(
    gx.Provider,
    {
      value: {
        open: t,
        showModal: h,
        hideModal: g
      },
      children: [
        /* @__PURE__ */ $.jsx(co, { open: t, onOpenChange: n, children: /* @__PURE__ */ $.jsx(
          co.Content,
          {
            title: r,
            description: o,
            confirmButton: s,
            onConfirm: u,
            cancelButton: f,
            hideModal: g,
            children: d
          }
        ) }),
        e
      ]
    }
  );
}, QM = ({ color: e, fontFamily: t, radius: n, themeMode: r, variant: i, headerVariant: o }) => {
  const a = st(
    () => sk({ color: e, fontFamily: t, radius: n, themeMode: r, variant: i, headerVariant: o }),
    [e, t, n, r, i, o]
  );
  return /* @__PURE__ */ $.jsx("style", { children: a });
}, Ew = ({ children: e, className: t, connected: n, uploadFile: r, allowFileUpload: i, ...o }) => {
  const { container: a } = we, s = Mf((c) => c.setMessageContainerRef), l = Bi((c) => c.uploadFile), u = Ke(null);
  return vt(() => {
    s(u);
  }, [u]), i && r ? /* @__PURE__ */ $.jsx(Is, { noClick: !0, onDrop: (c) => c.forEach((f) => l(f, r)), children: ({ getRootProps: c, isDragActive: f }) => /* @__PURE__ */ $.jsxs("div", { ...o, className: oi(a.className, t), ref: u, children: [
    /* @__PURE__ */ $.jsxs("div", { "data-hover": f, ...a.dropzone.overlay, children: [
      "Drop files to upload",
      /* @__PURE__ */ $.jsx(sP, { style: { width: "50px" } })
    ] }),
    /* @__PURE__ */ $.jsxs(Pv, { children: [
      /* @__PURE__ */ $.jsx(Av, { connected: n }),
      /* @__PURE__ */ $.jsx("div", { ...a.dropzone.container, ...c(), children: e })
    ] })
  ] }) }) : /* @__PURE__ */ $.jsx("div", { ...o, className: oi(a.className, t), ref: u, children: /* @__PURE__ */ $.jsxs(Pv, { children: [
    /* @__PURE__ */ $.jsx(Av, { connected: n }),
    e
  ] }) });
}, Av = ({ connected: e }) => {
  const { open: t, showModal: n } = jf();
  return e === !1 && !t && n && n({
    title: "Connection Error",
    description: "There was an error connecting to the server. Please check your internet connection and try again.",
    confirmButton: "Restart",
    onConfirm: () => window.parent.location.reload(),
    cancelButton: "Cancel"
  }), /* @__PURE__ */ $.jsx($.Fragment, {});
};
Ew.displayName = "Container";
const ZM = Ot(
  ({ children: e, onClick: t, imgUrl: n, ...r }, i) => {
    const { fab: o } = we, { container: a, icon: s, image: l } = o ?? {};
    return n ? /* @__PURE__ */ $.jsx(
      "img",
      {
        src: n,
        role: "button",
        tabIndex: 0,
        alt: "Chatbot Button Image",
        ...l,
        draggable: "false",
        onClick: t
      }
    ) : /* @__PURE__ */ $.jsx("div", { ...r, ...a, ref: i, onClick: t, children: /* @__PURE__ */ $.jsx("div", { ...s }) });
  }
);
ZM.displayName = "Fab";
function _n(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function ej(e, t) {
  const n = k.createContext(t), r = (o) => {
    const { children: a, ...s } = o, l = k.useMemo(() => s, Object.values(s));
    return /* @__PURE__ */ $.jsx(n.Provider, { value: l, children: a });
  };
  r.displayName = e + "Provider";
  function i(o) {
    const a = k.useContext(n);
    if (a) return a;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function kw(e, t = []) {
  let n = [];
  function r(o, a) {
    const s = k.createContext(a), l = n.length;
    n = [...n, a];
    const u = (f) => {
      var m;
      const { scope: p, children: d, ...v } = f, h = ((m = p == null ? void 0 : p[e]) == null ? void 0 : m[l]) || s, g = k.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ $.jsx(h.Provider, { value: g, children: d });
    };
    u.displayName = o + "Provider";
    function c(f, p) {
      var h;
      const d = ((h = p == null ? void 0 : p[e]) == null ? void 0 : h[l]) || s, v = k.useContext(d);
      if (v) return v;
      if (a !== void 0) return a;
      throw new Error(`\`${f}\` must be used within \`${o}\``);
    }
    return [u, c];
  }
  const i = () => {
    const o = n.map((a) => k.createContext(a));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || o;
      return k.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return i.scopeName = e, [r, tj(i, ...t)];
}
function tj(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const a = r.reduce((s, { useScope: l, scopeName: u }) => {
        const f = l(o)[`__scope${u}`];
        return { ...s, ...f };
      }, {});
      return k.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Cw({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = nj({ defaultProp: t, onChange: n }), o = e !== void 0, a = o ? e : r, s = Qn(n), l = k.useCallback(
    (u) => {
      if (o) {
        const f = typeof u == "function" ? u(e) : u;
        f !== e && s(f);
      } else
        i(u);
    },
    [o, e, i, s]
  );
  return [a, l];
}
function nj({
  defaultProp: e,
  onChange: t
}) {
  const n = k.useState(e), [r] = n, i = k.useRef(r), o = Qn(t);
  return k.useEffect(() => {
    i.current !== r && (o(r), i.current = r);
  }, [r, i, o]), n;
}
function Dv(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function $w(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = Dv(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : Dv(e[i], null);
        }
      };
  };
}
function nr(...e) {
  return k.useCallback($w(...e), e);
}
var Zf = k.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = k.Children.toArray(n), o = i.find(ij);
  if (o) {
    const a = o.props.children, s = i.map((l) => l === o ? k.Children.count(a) > 1 ? k.Children.only(null) : k.isValidElement(a) ? a.props.children : null : l);
    return /* @__PURE__ */ $.jsx($c, { ...r, ref: t, children: k.isValidElement(a) ? k.cloneElement(a, void 0, s) : null });
  }
  return /* @__PURE__ */ $.jsx($c, { ...r, ref: t, children: n });
});
Zf.displayName = "Slot";
var $c = k.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (k.isValidElement(n)) {
    const i = aj(n);
    return k.cloneElement(n, {
      ...oj(r, n.props),
      // @ts-ignore
      ref: t ? $w(t, i) : i
    });
  }
  return k.Children.count(n) > 1 ? k.Children.only(null) : null;
});
$c.displayName = "SlotClone";
var rj = ({ children: e }) => /* @__PURE__ */ $.jsx($.Fragment, { children: e });
function ij(e) {
  return k.isValidElement(e) && e.type === rj;
}
function oj(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...s) => {
      o(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function aj(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var sj = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], fn = sj.reduce((e, t) => {
  const n = k.forwardRef((r, i) => {
    const { asChild: o, ...a } = r, s = o ? Zf : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ $.jsx(s, { ...a, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function lj(e, t) {
  e && _y.flushSync(() => e.dispatchEvent(t));
}
function uj(e, t) {
  return k.useReducer((n, r) => t[n][r] ?? n, e);
}
var Rs = (e) => {
  const { present: t, children: n } = e, r = cj(t), i = typeof n == "function" ? n({ present: r.isPresent }) : k.Children.only(n), o = nr(r.ref, fj(i));
  return typeof n == "function" || r.isPresent ? k.cloneElement(i, { ref: o }) : null;
};
Rs.displayName = "Presence";
function cj(e) {
  const [t, n] = k.useState(), r = k.useRef({}), i = k.useRef(e), o = k.useRef("none"), a = e ? "mounted" : "unmounted", [s, l] = uj(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return k.useEffect(() => {
    const u = ra(r.current);
    o.current = s === "mounted" ? u : "none";
  }, [s]), Qr(() => {
    const u = r.current, c = i.current;
    if (c !== e) {
      const p = o.current, d = ra(u);
      e ? l("MOUNT") : d === "none" || (u == null ? void 0 : u.display) === "none" ? l("UNMOUNT") : l(c && p !== d ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), Qr(() => {
    if (t) {
      let u;
      const c = t.ownerDocument.defaultView ?? window, f = (d) => {
        const h = ra(r.current).includes(d.animationName);
        if (d.target === t && h && (l("ANIMATION_END"), !i.current)) {
          const g = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", u = c.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = g);
          });
        }
      }, p = (d) => {
        d.target === t && (o.current = ra(r.current));
      };
      return t.addEventListener("animationstart", p), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        c.clearTimeout(u), t.removeEventListener("animationstart", p), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(s),
    ref: k.useCallback((u) => {
      u && (r.current = getComputedStyle(u)), n(u);
    }, [])
  };
}
function ra(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function fj(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var dj = k.useId || (() => {
}), pj = 0;
function Ca(e) {
  const [t, n] = k.useState(dj());
  return Qr(() => {
    e || n((r) => r ?? String(pj++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
var ed = "Collapsible", [hj, DX] = kw(ed), [vj, td] = hj(ed), Tw = k.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: i,
      disabled: o,
      onOpenChange: a,
      ...s
    } = e, [l = !1, u] = Cw({
      prop: r,
      defaultProp: i,
      onChange: a
    });
    return /* @__PURE__ */ $.jsx(
      vj,
      {
        scope: n,
        disabled: o,
        contentId: Ca(),
        open: l,
        onOpenToggle: k.useCallback(() => u((c) => !c), [u]),
        children: /* @__PURE__ */ $.jsx(
          fn.div,
          {
            "data-state": rd(l),
            "data-disabled": o ? "" : void 0,
            ...s,
            ref: t
          }
        )
      }
    );
  }
);
Tw.displayName = ed;
var Ow = "CollapsibleTrigger", Iw = k.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: n, ...r } = e, i = td(Ow, n);
    return /* @__PURE__ */ $.jsx(
      fn.button,
      {
        type: "button",
        "aria-controls": i.contentId,
        "aria-expanded": i.open || !1,
        "data-state": rd(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        disabled: i.disabled,
        ...r,
        ref: t,
        onClick: _n(e.onClick, i.onOpenToggle)
      }
    );
  }
);
Iw.displayName = Ow;
var nd = "CollapsibleContent", Rw = k.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = td(nd, e.__scopeCollapsible);
    return /* @__PURE__ */ $.jsx(Rs, { present: n || i.open, children: ({ present: o }) => /* @__PURE__ */ $.jsx(mj, { ...r, ref: t, present: o }) });
  }
);
Rw.displayName = nd;
var mj = k.forwardRef((e, t) => {
  const { __scopeCollapsible: n, present: r, children: i, ...o } = e, a = td(nd, n), [s, l] = k.useState(r), u = k.useRef(null), c = nr(t, u), f = k.useRef(0), p = f.current, d = k.useRef(0), v = d.current, h = a.open || s, g = k.useRef(h), m = k.useRef(void 0);
  return k.useEffect(() => {
    const b = requestAnimationFrame(() => g.current = !1);
    return () => cancelAnimationFrame(b);
  }, []), Qr(() => {
    const b = u.current;
    if (b) {
      m.current = m.current || {
        transitionDuration: b.style.transitionDuration,
        animationName: b.style.animationName
      }, b.style.transitionDuration = "0s", b.style.animationName = "none";
      const w = b.getBoundingClientRect();
      f.current = w.height, d.current = w.width, g.current || (b.style.transitionDuration = m.current.transitionDuration, b.style.animationName = m.current.animationName), l(r);
    }
  }, [a.open, r]), /* @__PURE__ */ $.jsx(
    fn.div,
    {
      "data-state": rd(a.open),
      "data-disabled": a.disabled ? "" : void 0,
      id: a.contentId,
      hidden: !h,
      ...o,
      ref: c,
      style: {
        "--radix-collapsible-content-height": p ? `${p}px` : void 0,
        "--radix-collapsible-content-width": v ? `${v}px` : void 0,
        ...e.style
      },
      children: h && i
    }
  );
});
function rd(e) {
  return e ? "open" : "closed";
}
var gj = Tw, yj = Rw;
const bj = ({ restartConversation: e, ...t }) => {
  var a, s;
  const { header: n } = we, { showModal: r, hideModal: i } = jf(), o = (l) => {
    l.stopPropagation(), r && i ? r({
      title: "Create New Conversation",
      description: "This will clear the current conversation and start a new one.",
      confirmButton: "New conversation",
      onConfirm: () => {
        e(), i();
      },
      cancelButton: "Cancel"
    }) : e();
  };
  return /* @__PURE__ */ $.jsx(
    xP,
    {
      ...t,
      ...(s = (a = n == null ? void 0 : n.content) == null ? void 0 : a.actions) == null ? void 0 : s.icons,
      "aria-label": "Restart Conversation Button",
      tabIndex: 0,
      role: "button",
      onClick: o
    }
  );
}, xj = ({ onClick: e, ...t }) => {
  const { header: n } = we, r = (i) => {
    i.stopPropagation(), e == null || e();
  };
  return /* @__PURE__ */ $.jsx(
    $P,
    {
      ...t,
      ...n.content.actions.icons,
      role: "button",
      tabIndex: 0,
      "aria-label": "Close Chatbot Button",
      onClick: r,
      onKeyDown: (i) => {
        i.key === "Enter" && r(i);
      }
    }
  );
}, Ai = ({ icon: e, title: t, link: n, ...r }) => {
  var a, s, l, u, c, f, p, d, v, h, g, m;
  const { header: i } = we, o = e ?? lP;
  return t ? n ? /* @__PURE__ */ $.jsxs(
    "a",
    {
      ...r,
      ...(s = (a = i.expandedContent) == null ? void 0 : a.descriptionItems) == null ? void 0 : s.container,
      href: n,
      target: "_blank",
      rel: "noreferrer noopener",
      children: [
        /* @__PURE__ */ $.jsx(o, { ...(u = (l = i.expandedContent) == null ? void 0 : l.descriptionItems) == null ? void 0 : u.icon }),
        /* @__PURE__ */ $.jsx("p", { ...(f = (c = i.expandedContent) == null ? void 0 : c.descriptionItems) == null ? void 0 : f.link, children: t })
      ]
    }
  ) : /* @__PURE__ */ $.jsxs("div", { ...r, ...(d = (p = i.expandedContent) == null ? void 0 : p.descriptionItems) == null ? void 0 : d.container, children: [
    /* @__PURE__ */ $.jsx(o, { ...(h = (v = i.expandedContent) == null ? void 0 : v.descriptionItems) == null ? void 0 : h.icon }),
    /* @__PURE__ */ $.jsx("p", { ...(m = (g = i.expandedContent) == null ? void 0 : g.descriptionItems) == null ? void 0 : m.text, children: t })
  ] }) : null;
}, wj = ({ defaultOpen: e, closeWindow: t, configuration: n, restartConversation: r, ...i }) => {
  var c, f, p, d, v, h, g, m, b, w, C, S, E, I, N, A, O, D, U, L, M, _;
  const { header: o } = we, [a, s] = ge(!!e), l = !!((c = n.email) != null && c.title) || !!((f = n.phone) != null && f.title) || !!((p = n.website) != null && p.title) || !!((d = n.termsOfService) != null && d.link) || !!((v = n.privacyPolicy) != null && v.link), u = l || !!n.botDescription;
  return /* @__PURE__ */ $.jsxs(
    gj,
    {
      open: u ? a : !1,
      onOpenChange: s,
      "data-disabled": u ? void 0 : "",
      ...o.container,
      ...i,
      children: [
        /* @__PURE__ */ $.jsxs(Iw, { "aria-label": "Expand Header Button", ...o.content.container, children: [
          /* @__PURE__ */ $.jsx(mf, { ...i, src: n.botAvatar, ...o.content.avatar, children: n.botName || "Bot" }),
          /* @__PURE__ */ $.jsx("h2", { ...o.content.title, children: n.botName || "Bot" }),
          n.botDescription && /* @__PURE__ */ $.jsx("p", { ...o.content.description, children: n.botDescription }),
          /* @__PURE__ */ $.jsxs("div", { ...o.content.actions.container, children: [
            r && /* @__PURE__ */ $.jsx(bj, { restartConversation: r }),
            t && /* @__PURE__ */ $.jsx(xj, { onClick: t })
          ] })
        ] }),
        l && /* @__PURE__ */ $.jsxs(yj, { ...o.expandedContent.container, children: [
          /* @__PURE__ */ $.jsxs("div", { "data-links": "", ...o.expandedContent.group, children: [
            /* @__PURE__ */ $.jsx(
              Ai,
              {
                "data-email": "",
                icon: hP,
                title: (h = n.email) == null ? void 0 : h.title,
                link: (m = (g = n.email) == null ? void 0 : g.link) != null && m.startsWith("mailto:") ? (b = n.email) == null ? void 0 : b.link : `mailto:${(w = n.email) == null ? void 0 : w.link}`
              }
            ),
            /* @__PURE__ */ $.jsx(
              Ai,
              {
                "data-phone": "",
                icon: yP,
                title: (C = n.phone) == null ? void 0 : C.title,
                link: (E = (S = n.phone) == null ? void 0 : S.link) != null && E.startsWith("tel:") ? (I = n.phone) == null ? void 0 : I.link : `tel:${(N = n.phone) == null ? void 0 : N.link}`
              }
            ),
            /* @__PURE__ */ $.jsx(
              Ai,
              {
                "data-website": "",
                link: (A = n.website) == null ? void 0 : A.link,
                icon: fP,
                title: (O = n.website) == null ? void 0 : O.title
              }
            )
          ] }),
          /* @__PURE__ */ $.jsxs("div", { "data-legal": "", ...(D = o.expandedContent) == null ? void 0 : D.group, children: [
            /* @__PURE__ */ $.jsx(
              Ai,
              {
                "data-terms": "",
                link: (U = n.termsOfService) == null ? void 0 : U.link,
                icon: tx,
                title: (L = n.termsOfService) == null ? void 0 : L.title
              }
            ),
            /* @__PURE__ */ $.jsx(
              Ai,
              {
                "data-privacy": "",
                link: (M = n.privacyPolicy) == null ? void 0 : M.link,
                icon: pP,
                title: (_ = n.privacyPolicy) == null ? void 0 : _.title
              }
            )
          ] })
        ] })
      ]
    }
  );
}, Pw = ds(({ ...e }) => {
  const { typingIndicator: t } = we;
  return /* @__PURE__ */ $.jsx("div", { ...e, ...t == null ? void 0 : t.container, children: /* @__PURE__ */ $.jsx("div", { ...t == null ? void 0 : t.loader }) });
});
Pw.displayName = "TypingIndicator";
const _v = ds(
  Ot(
    ({
      direction: e,
      block: t,
      disableInput: n,
      children: r,
      sender: i,
      id: o,
      authorId: a,
      status: s,
      renderers: l,
      isReadOnly: u,
      isLastDeliveredMessage: c,
      feedback: f,
      timestamp: p,
      metadata: d,
      sendMessage: v,
      addMessageFeedback: h
    }, g) => {
      const [m, b] = ge([]), {
        message: { container: w, avatar: C, deliveryStatus: S }
      } = we, E = Fy(a ?? "", 15), [I, N] = ge("idle");
      return /* @__PURE__ */ $.jsx(mx.Provider, { value: { isLoading: m, setIsLoading: b }, children: /* @__PURE__ */ $.jsxs(
        "div",
        {
          ...w,
          className: oi(w == null ? void 0 : w.className, c && (S == null ? void 0 : S.className)),
          "data-loaded": m.length === 0,
          "data-disable-input": !!n,
          "data-direction": e,
          ref: g,
          children: [
            /* @__PURE__ */ $.jsxs(pf, { "data-color": E, "data-loading-status": I, ...C == null ? void 0 : C.container, children: [
              /* @__PURE__ */ $.jsx(hf, { ...C == null ? void 0 : C.image, onLoadingStatusChange: N, src: i == null ? void 0 : i.avatar }),
              /* @__PURE__ */ $.jsxs(vf, { ...C == null ? void 0 : C.fallback, children: [
                i == null ? void 0 : i.name[0],
                " "
              ] })
            ] }),
            t && /* @__PURE__ */ $.jsx(
              ii,
              {
                block: {
                  ...t,
                  isReadOnly: u,
                  direction: e,
                  timestamp: p,
                  sender: i,
                  feedback: f,
                  messageId: o,
                  status: s,
                  metadata: d,
                  sendMessage: v,
                  addMessageFeedback: h
                },
                renderers: l
              }
            ),
            r
          ]
        }
      ) });
    }
  )
);
function Sj({ botAvatar: e, botDescription: t, botName: n }) {
  const {
    messageList: { marquee: r }
  } = we;
  return /* @__PURE__ */ $.jsxs("li", { ...r.container, children: [
    /* @__PURE__ */ $.jsx(mf, { src: e, ...r.avatar, children: (n || "Bot").slice(0, 1) }),
    /* @__PURE__ */ $.jsxs("div", { ...r.content, children: [
      /* @__PURE__ */ $.jsx("h1", { ...r.title, children: n || "Bot" }),
      /* @__PURE__ */ $.jsx("p", { ...r.description, children: t })
    ] })
  ] });
}
function Ej(e, t) {
  try {
    var n = global, r = n.document;
    if (typeof r < "u" && r.createElement && r.head && r.head.appendChild) {
      var i = r.querySelector('html meta[name="'.concat(encodeURI(e), '"]')) || r.createElement("meta");
      i.setAttribute("name", e), i.setAttribute("content", t), r.head.appendChild(i);
    }
  } catch {
  }
}
function kj() {
  Ej("react-scroll-to-bottom:version", "4.2.0");
}
var Di = function(e) {
  return e && e.Math === Math && e;
}, ft = (
  // eslint-disable-next-line es/no-global-this -- safe
  Di(typeof globalThis == "object" && globalThis) || Di(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  Di(typeof self == "object" && self) || Di(typeof an == "object" && an) || Di(typeof an == "object" && an) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), dt = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, Cj = dt, Ps = !Cj(function() {
  var e = (function() {
  }).bind();
  return typeof e != "function" || e.hasOwnProperty("prototype");
}), $j = Ps, Aw = Function.prototype, Mv = Aw.apply, jv = Aw.call, id = typeof Reflect == "object" && Reflect.apply || ($j ? jv.bind(Mv) : function() {
  return jv.apply(Mv, arguments);
}), Dw = Ps, _w = Function.prototype, Tc = _w.call, Tj = Dw && _w.bind.bind(Tc, Tc), pt = Dw ? Tj : function(e) {
  return function() {
    return Tc.apply(e, arguments);
  };
}, Mw = pt, Oj = Mw({}.toString), Ij = Mw("".slice), Sr = function(e) {
  return Ij(Oj(e), 8, -1);
}, Rj = Sr, Pj = pt, od = function(e) {
  if (Rj(e) === "Function") return Pj(e);
}, Hl = typeof document == "object" && document.all, Rt = typeof Hl > "u" && Hl !== void 0 ? function(e) {
  return typeof e == "function" || e === Hl;
} : function(e) {
  return typeof e == "function";
}, So = {}, Aj = dt, Bt = !Aj(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), Dj = Ps, ia = Function.prototype.call, $n = Dj ? ia.bind(ia) : function() {
  return ia.apply(ia, arguments);
}, ad = {}, jw = {}.propertyIsEnumerable, Nw = Object.getOwnPropertyDescriptor, _j = Nw && !jw.call({ 1: 2 }, 1);
ad.f = _j ? function(t) {
  var n = Nw(this, t);
  return !!n && n.enumerable;
} : jw;
var Eo = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, Mj = pt, jj = dt, Nj = Sr, Vl = Object, Lj = Mj("".split), Lw = jj(function() {
  return !Vl("z").propertyIsEnumerable(0);
}) ? function(e) {
  return Nj(e) === "String" ? Lj(e, "") : Vl(e);
} : Vl, sd = function(e) {
  return e == null;
}, Fj = sd, Bj = TypeError, ld = function(e) {
  if (Fj(e)) throw new Bj("Can't call method on " + e);
  return e;
}, zj = Lw, Wj = ld, Tn = function(e) {
  return zj(Wj(e));
}, Uj = Rt, Ln = function(e) {
  return typeof e == "object" ? e !== null : Uj(e);
}, wt = {}, Kl = wt, ql = ft, Hj = Rt, Nv = function(e) {
  return Hj(e) ? e : void 0;
}, On = function(e, t) {
  return arguments.length < 2 ? Nv(Kl[e]) || Nv(ql[e]) : Kl[e] && Kl[e][t] || ql[e] && ql[e][t];
}, Vj = pt, Fn = Vj({}.isPrototypeOf), Kj = ft, Lv = Kj.navigator, Fv = Lv && Lv.userAgent, ud = Fv ? String(Fv) : "", Fw = ft, Gl = ud, Bv = Fw.process, zv = Fw.Deno, Wv = Bv && Bv.versions || zv && zv.version, Uv = Wv && Wv.v8, rn, Za;
Uv && (rn = Uv.split("."), Za = rn[0] > 0 && rn[0] < 4 ? 1 : +(rn[0] + rn[1]));
!Za && Gl && (rn = Gl.match(/Edge\/(\d+)/), (!rn || rn[1] >= 74) && (rn = Gl.match(/Chrome\/(\d+)/), rn && (Za = +rn[1])));
var cd = Za, Hv = cd, qj = dt, Gj = ft, Yj = Gj.String, gi = !!Object.getOwnPropertySymbols && !qj(function() {
  var e = Symbol("symbol detection");
  return !Yj(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && Hv && Hv < 41;
}), Xj = gi, Bw = Xj && !Symbol.sham && typeof Symbol.iterator == "symbol", Jj = On, Qj = Rt, Zj = Fn, e2 = Bw, t2 = Object, ko = e2 ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = Jj("Symbol");
  return Qj(t) && Zj(t.prototype, t2(e));
}, n2 = String, As = function(e) {
  try {
    return n2(e);
  } catch {
    return "Object";
  }
}, r2 = Rt, i2 = As, o2 = TypeError, fd = function(e) {
  if (r2(e)) return e;
  throw new o2(i2(e) + " is not a function");
}, a2 = fd, s2 = sd, dd = function(e, t) {
  var n = e[t];
  return s2(n) ? void 0 : a2(n);
}, Yl = $n, Xl = Rt, Jl = Ln, l2 = TypeError, u2 = function(e, t) {
  var n, r;
  if (t === "string" && Xl(n = e.toString) && !Jl(r = Yl(n, e)) || Xl(n = e.valueOf) && !Jl(r = Yl(n, e)) || t !== "string" && Xl(n = e.toString) && !Jl(r = Yl(n, e))) return r;
  throw new l2("Can't convert object to primitive value");
}, zw = { exports: {} }, Vv = ft, c2 = Object.defineProperty, f2 = function(e, t) {
  try {
    c2(Vv, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    Vv[e] = t;
  }
  return t;
}, d2 = ft, p2 = f2, Kv = "__core-js_shared__", qv = zw.exports = d2[Kv] || p2(Kv, {});
(qv.versions || (qv.versions = [])).push({
  version: "3.38.1",
  mode: "pure",
  copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var pd = zw.exports, Gv = pd, yi = function(e, t) {
  return Gv[e] || (Gv[e] = t || {});
}, h2 = ld, v2 = Object, Bn = function(e) {
  return v2(h2(e));
}, m2 = pt, g2 = Bn, y2 = m2({}.hasOwnProperty), Vt = Object.hasOwn || function(t, n) {
  return y2(g2(t), n);
}, b2 = pt, x2 = 0, w2 = Math.random(), S2 = b2(1 .toString), hd = function(e) {
  return "Symbol(" + (e === void 0 ? "" : e) + ")_" + S2(++x2 + w2, 36);
}, E2 = ft, k2 = yi, Yv = Vt, C2 = hd, $2 = gi, T2 = Bw, Wr = E2.Symbol, Ql = k2("wks"), O2 = T2 ? Wr.for || Wr : Wr && Wr.withoutSetter || C2, mt = function(e) {
  return Yv(Ql, e) || (Ql[e] = $2 && Yv(Wr, e) ? Wr[e] : O2("Symbol." + e)), Ql[e];
}, I2 = $n, Xv = Ln, Jv = ko, R2 = dd, P2 = u2, A2 = mt, D2 = TypeError, _2 = A2("toPrimitive"), M2 = function(e, t) {
  if (!Xv(e) || Jv(e)) return e;
  var n = R2(e, _2), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = I2(n, e, t), !Xv(r) || Jv(r)) return r;
    throw new D2("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), P2(e, t);
}, j2 = M2, N2 = ko, vd = function(e) {
  var t = j2(e, "string");
  return N2(t) ? t : t + "";
}, L2 = ft, Qv = Ln, Oc = L2.document, F2 = Qv(Oc) && Qv(Oc.createElement), Ww = function(e) {
  return F2 ? Oc.createElement(e) : {};
}, B2 = Bt, z2 = dt, W2 = Ww, Uw = !B2 && !z2(function() {
  return Object.defineProperty(W2("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
}), U2 = Bt, H2 = $n, V2 = ad, K2 = Eo, q2 = Tn, G2 = vd, Y2 = Vt, X2 = Uw, Zv = Object.getOwnPropertyDescriptor;
So.f = U2 ? Zv : function(t, n) {
  if (t = q2(t), n = G2(n), X2) try {
    return Zv(t, n);
  } catch {
  }
  if (Y2(t, n)) return K2(!H2(V2.f, t, n), t[n]);
};
var J2 = dt, Q2 = Rt, Z2 = /#|\.prototype\./, Co = function(e, t) {
  var n = tN[eN(e)];
  return n === rN ? !0 : n === nN ? !1 : Q2(t) ? J2(t) : !!t;
}, eN = Co.normalize = function(e) {
  return String(e).replace(Z2, ".").toLowerCase();
}, tN = Co.data = {}, nN = Co.NATIVE = "N", rN = Co.POLYFILL = "P", iN = Co, em = od, oN = fd, aN = Ps, sN = em(em.bind), md = function(e, t) {
  return oN(e), t === void 0 ? e : aN ? sN(e, t) : function() {
    return e.apply(t, arguments);
  };
}, dn = {}, lN = Bt, uN = dt, Hw = lN && uN(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype !== 42;
}), cN = Ln, fN = String, dN = TypeError, rr = function(e) {
  if (cN(e)) return e;
  throw new dN(fN(e) + " is not an object");
}, pN = Bt, hN = Uw, vN = Hw, oa = rr, tm = vd, mN = TypeError, Zl = Object.defineProperty, gN = Object.getOwnPropertyDescriptor, eu = "enumerable", tu = "configurable", nu = "writable";
dn.f = pN ? vN ? function(t, n, r) {
  if (oa(t), n = tm(n), oa(r), typeof t == "function" && n === "prototype" && "value" in r && nu in r && !r[nu]) {
    var i = gN(t, n);
    i && i[nu] && (t[n] = r.value, r = {
      configurable: tu in r ? r[tu] : i[tu],
      enumerable: eu in r ? r[eu] : i[eu],
      writable: !1
    });
  }
  return Zl(t, n, r);
} : Zl : function(t, n, r) {
  if (oa(t), n = tm(n), oa(r), hN) try {
    return Zl(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw new mN("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var yN = Bt, bN = dn, xN = Eo, Ds = yN ? function(e, t, n) {
  return bN.f(e, t, xN(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, _i = ft, wN = id, SN = od, EN = Rt, kN = So.f, CN = iN, Rr = wt, $N = md, Pr = Ds, nm = Vt, TN = function(e) {
  var t = function(n, r, i) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new e();
        case 1:
          return new e(n);
        case 2:
          return new e(n, r);
      }
      return new e(n, r, i);
    }
    return wN(e, this, arguments);
  };
  return t.prototype = e.prototype, t;
}, Be = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, o = e.proto, a = r ? _i : i ? _i[n] : _i[n] && _i[n].prototype, s = r ? Rr : Rr[n] || Pr(Rr, n, {})[n], l = s.prototype, u, c, f, p, d, v, h, g, m;
  for (p in t)
    u = CN(r ? p : n + (i ? "." : "#") + p, e.forced), c = !u && a && nm(a, p), v = s[p], c && (e.dontCallGetSet ? (m = kN(a, p), h = m && m.value) : h = a[p]), d = c && h ? h : t[p], !(!u && !o && typeof v == typeof d) && (e.bind && c ? g = $N(d, _i) : e.wrap && c ? g = TN(d) : o && EN(d) ? g = SN(d) : g = d, (e.sham || d && d.sham || v && v.sham) && Pr(g, "sham", !0), Pr(s, p, g), o && (f = n + "Prototype", nm(Rr, f) || Pr(Rr, f, {}), Pr(Rr[f], p, d), e.real && l && (u || !l[p]) && Pr(l, p, d)));
}, ON = Sr, bi = Array.isArray || function(t) {
  return ON(t) === "Array";
}, IN = Be, RN = bi;
IN({ target: "Array", stat: !0 }, {
  isArray: RN
});
var PN = wt, AN = PN.Array.isArray, DN = AN, Vw = DN, _N = Vw, MN = _N, jN = MN, NN = jN, LN = NN;
const Kw = /* @__PURE__ */ $e(LN);
function FN(e) {
  if (Kw(e)) return e;
}
var BN = Math.ceil, zN = Math.floor, WN = Math.trunc || function(t) {
  var n = +t;
  return (n > 0 ? zN : BN)(n);
}, UN = WN, _s = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : UN(t);
}, HN = _s, VN = Math.min, KN = function(e) {
  var t = HN(e);
  return t > 0 ? VN(t, 9007199254740991) : 0;
}, qN = KN, Er = function(e) {
  return qN(e.length);
}, GN = TypeError, YN = 9007199254740991, gd = function(e) {
  if (e > YN) throw GN("Maximum allowed index exceeded");
  return e;
}, XN = Bt, JN = dn, QN = Eo, $o = function(e, t, n) {
  XN ? JN.f(e, t, QN(0, n)) : e[t] = n;
}, ZN = mt, eL = ZN("toStringTag"), qw = {};
qw[eL] = "z";
var yd = String(qw) === "[object z]", tL = yd, nL = Rt, $a = Sr, rL = mt, iL = rL("toStringTag"), oL = Object, aL = $a(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments", sL = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, To = tL ? $a : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = sL(t = oL(e), iL)) == "string" ? n : aL ? $a(t) : (r = $a(t)) === "Object" && nL(t.callee) ? "Arguments" : r;
}, lL = pt, uL = Rt, Ic = pd, cL = lL(Function.toString);
uL(Ic.inspectSource) || (Ic.inspectSource = function(e) {
  return cL(e);
});
var fL = Ic.inspectSource, dL = pt, pL = dt, Gw = Rt, hL = To, vL = On, mL = fL, Yw = function() {
}, Xw = vL("Reflect", "construct"), bd = /^\s*(?:class|function)\b/, gL = dL(bd.exec), yL = !bd.test(Yw), Mi = function(t) {
  if (!Gw(t)) return !1;
  try {
    return Xw(Yw, [], t), !0;
  } catch {
    return !1;
  }
}, Jw = function(t) {
  if (!Gw(t)) return !1;
  switch (hL(t)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return yL || !!gL(bd, mL(t));
  } catch {
    return !0;
  }
};
Jw.sham = !0;
var xd = !Xw || pL(function() {
  var e;
  return Mi(Mi.call) || !Mi(Object) || !Mi(function() {
    e = !0;
  }) || e;
}) ? Jw : Mi, rm = bi, bL = xd, xL = Ln, wL = mt, SL = wL("species"), im = Array, EL = function(e) {
  var t;
  return rm(e) && (t = e.constructor, bL(t) && (t === im || rm(t.prototype)) ? t = void 0 : xL(t) && (t = t[SL], t === null && (t = void 0))), t === void 0 ? im : t;
}, kL = EL, wd = function(e, t) {
  return new (kL(e))(t === 0 ? 0 : t);
}, CL = dt, $L = mt, TL = cd, OL = $L("species"), Ms = function(e) {
  return TL >= 51 || !CL(function() {
    var t = [], n = t.constructor = {};
    return n[OL] = function() {
      return { foo: 1 };
    }, t[e](Boolean).foo !== 1;
  });
}, IL = Be, RL = dt, PL = bi, AL = Ln, DL = Bn, _L = Er, om = gd, am = $o, ML = wd, jL = Ms, NL = mt, LL = cd, Qw = NL("isConcatSpreadable"), FL = LL >= 51 || !RL(function() {
  var e = [];
  return e[Qw] = !1, e.concat()[0] !== e;
}), BL = function(e) {
  if (!AL(e)) return !1;
  var t = e[Qw];
  return t !== void 0 ? !!t : PL(e);
}, zL = !FL || !jL("concat");
IL({ target: "Array", proto: !0, arity: 1, forced: zL }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function(t) {
    var n = DL(this), r = ML(n, 0), i = 0, o, a, s, l, u;
    for (o = -1, s = arguments.length; o < s; o++)
      if (u = o === -1 ? n : arguments[o], BL(u))
        for (l = _L(u), om(i + l), a = 0; a < l; a++, i++) a in u && am(r, i, u[a]);
      else
        om(i + 1), am(r, i++, u);
    return r.length = i, r;
  }
});
var WL = To, UL = String, Oo = function(e) {
  if (WL(e) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return UL(e);
}, js = {}, HL = _s, VL = Math.max, KL = Math.min, Sd = function(e, t) {
  var n = HL(e);
  return n < 0 ? VL(n + t, 0) : KL(n, t);
}, qL = Tn, GL = Sd, YL = Er, sm = function(e) {
  return function(t, n, r) {
    var i = qL(t), o = YL(i);
    if (o === 0) return !e && -1;
    var a = GL(r, o), s;
    if (e && n !== n) {
      for (; o > a; )
        if (s = i[a++], s !== s) return !0;
    } else for (; o > a; a++)
      if ((e || a in i) && i[a] === n) return e || a || 0;
    return !e && -1;
  };
}, Zw = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: sm(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: sm(!1)
}, Ns = {}, XL = pt, ru = Vt, JL = Tn, QL = Zw.indexOf, ZL = Ns, lm = XL([].push), e1 = function(e, t) {
  var n = JL(e), r = 0, i = [], o;
  for (o in n) !ru(ZL, o) && ru(n, o) && lm(i, o);
  for (; t.length > r; ) ru(n, o = t[r++]) && (~QL(i, o) || lm(i, o));
  return i;
}, Ed = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], eF = e1, tF = Ed, kd = Object.keys || function(t) {
  return eF(t, tF);
}, nF = Bt, rF = Hw, iF = dn, oF = rr, aF = Tn, sF = kd;
js.f = nF && !rF ? Object.defineProperties : function(t, n) {
  oF(t);
  for (var r = aF(n), i = sF(n), o = i.length, a = 0, s; o > a; ) iF.f(t, s = i[a++], r[s]);
  return t;
};
var lF = On, uF = lF("document", "documentElement"), cF = yi, fF = hd, um = cF("keys"), Ls = function(e) {
  return um[e] || (um[e] = fF(e));
}, dF = rr, pF = js, cm = Ed, hF = Ns, vF = uF, mF = Ww, gF = Ls, fm = ">", dm = "<", Rc = "prototype", Pc = "script", t1 = gF("IE_PROTO"), iu = function() {
}, n1 = function(e) {
  return dm + Pc + fm + e + dm + "/" + Pc + fm;
}, pm = function(e) {
  e.write(n1("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, yF = function() {
  var e = mF("iframe"), t = "java" + Pc + ":", n;
  return e.style.display = "none", vF.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(n1("document.F=Object")), n.close(), n.F;
}, aa, Ta = function() {
  try {
    aa = new ActiveXObject("htmlfile");
  } catch {
  }
  Ta = typeof document < "u" ? document.domain && aa ? pm(aa) : yF() : pm(aa);
  for (var e = cm.length; e--; ) delete Ta[Rc][cm[e]];
  return Ta();
};
hF[t1] = !0;
var Cd = Object.create || function(t, n) {
  var r;
  return t !== null ? (iu[Rc] = dF(t), r = new iu(), iu[Rc] = null, r[t1] = t) : r = Ta(), n === void 0 ? r : pF.f(r, n);
}, Fs = {}, bF = e1, xF = Ed, wF = xF.concat("length", "prototype");
Fs.f = Object.getOwnPropertyNames || function(t) {
  return bF(t, wF);
};
var r1 = {}, SF = pt, Bs = SF([].slice), EF = Sr, kF = Tn, i1 = Fs.f, CF = Bs, o1 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], $F = function(e) {
  try {
    return i1(e);
  } catch {
    return CF(o1);
  }
};
r1.f = function(t) {
  return o1 && EF(t) === "Window" ? $F(t) : i1(kF(t));
};
var zs = {};
zs.f = Object.getOwnPropertySymbols;
var TF = Ds, Ws = function(e, t, n, r) {
  return r && r.enumerable ? e[t] = n : TF(e, t, n), e;
}, OF = dn, IF = function(e, t, n) {
  return OF.f(e, t, n);
}, Io = {}, RF = mt;
Io.f = RF;
var hm = wt, PF = Vt, AF = Io, DF = dn.f, Qe = function(e) {
  var t = hm.Symbol || (hm.Symbol = {});
  PF(t, e) || DF(t, e, {
    value: AF.f(e)
  });
}, _F = $n, MF = On, jF = mt, NF = Ws, a1 = function() {
  var e = MF("Symbol"), t = e && e.prototype, n = t && t.valueOf, r = jF("toPrimitive");
  t && !t[r] && NF(t, r, function(i) {
    return _F(n, this);
  }, { arity: 1 });
}, LF = yd, FF = To, BF = LF ? {}.toString : function() {
  return "[object " + FF(this) + "]";
}, zF = yd, WF = dn.f, UF = Ds, HF = Vt, VF = BF, KF = mt, vm = KF("toStringTag"), xi = function(e, t, n, r) {
  var i = n ? e : e && e.prototype;
  i && (HF(i, vm) || WF(i, vm, { configurable: !0, value: t }), r && !zF && UF(i, "toString", VF));
}, qF = ft, GF = Rt, mm = qF.WeakMap, YF = GF(mm) && /native code/.test(String(mm)), XF = YF, s1 = ft, JF = Ln, QF = Ds, ou = Vt, au = pd, ZF = Ls, eB = Ns, gm = "Object already initialized", Ac = s1.TypeError, tB = s1.WeakMap, es, io, ts, nB = function(e) {
  return ts(e) ? io(e) : es(e, {});
}, rB = function(e) {
  return function(t) {
    var n;
    if (!JF(t) || (n = io(t)).type !== e)
      throw new Ac("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (XF || au.state) {
  var mn = au.state || (au.state = new tB());
  mn.get = mn.get, mn.has = mn.has, mn.set = mn.set, es = function(e, t) {
    if (mn.has(e)) throw new Ac(gm);
    return t.facade = e, mn.set(e, t), t;
  }, io = function(e) {
    return mn.get(e) || {};
  }, ts = function(e) {
    return mn.has(e);
  };
} else {
  var Ar = ZF("state");
  eB[Ar] = !0, es = function(e, t) {
    if (ou(e, Ar)) throw new Ac(gm);
    return t.facade = e, QF(e, Ar, t), t;
  }, io = function(e) {
    return ou(e, Ar) ? e[Ar] : {};
  }, ts = function(e) {
    return ou(e, Ar);
  };
}
var $d = {
  set: es,
  get: io,
  has: ts,
  enforce: nB,
  getterFor: rB
}, iB = md, oB = pt, aB = Lw, sB = Bn, lB = Er, uB = wd, ym = oB([].push), Wn = function(e) {
  var t = e === 1, n = e === 2, r = e === 3, i = e === 4, o = e === 6, a = e === 7, s = e === 5 || o;
  return function(l, u, c, f) {
    for (var p = sB(l), d = aB(p), v = lB(d), h = iB(u, c), g = 0, m = f || uB, b = t ? m(l, v) : n || a ? m(l, 0) : void 0, w, C; v > g; g++) if ((s || g in d) && (w = d[g], C = h(w, g, p), e))
      if (t) b[g] = C;
      else if (C) switch (e) {
        case 3:
          return !0;
        case 5:
          return w;
        case 6:
          return g;
        case 2:
          ym(b, w);
      }
      else switch (e) {
        case 4:
          return !1;
        case 7:
          ym(b, w);
      }
    return o ? -1 : r || i ? i : b;
  };
}, Td = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: Wn(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: Wn(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: Wn(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: Wn(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: Wn(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: Wn(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: Wn(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: Wn(7)
}, Us = Be, Ro = ft, Od = $n, cB = pt, ai = Bt, si = gi, fB = dt, ht = Vt, dB = Fn, Dc = rr, Hs = Tn, Id = vd, pB = Oo, _c = Eo, li = Cd, l1 = kd, hB = Fs, u1 = r1, vB = zs, c1 = So, f1 = dn, mB = js, d1 = ad, bm = Ws, gB = IF, Rd = yi, yB = Ls, p1 = Ns, xm = hd, bB = mt, xB = Io, wB = Qe, SB = a1, EB = xi, h1 = $d, Vs = Td.forEach, Lt = yB("hidden"), Ks = "Symbol", oo = "prototype", kB = h1.set, wm = h1.getterFor(Ks), sn = Object[oo], vr = Ro.Symbol, zi = vr && vr[oo], CB = Ro.RangeError, $B = Ro.TypeError, su = Ro.QObject, v1 = c1.f, mr = f1.f, m1 = u1.f, TB = d1.f, g1 = cB([].push), jn = Rd("symbols"), Po = Rd("op-symbols"), OB = Rd("wks"), Mc = !su || !su[oo] || !su[oo].findChild, y1 = function(e, t, n) {
  var r = v1(sn, t);
  r && delete sn[t], mr(e, t, n), r && e !== sn && mr(sn, t, r);
}, jc = ai && fB(function() {
  return li(mr({}, "a", {
    get: function() {
      return mr(this, "a", { value: 7 }).a;
    }
  })).a !== 7;
}) ? y1 : mr, lu = function(e, t) {
  var n = jn[e] = li(zi);
  return kB(n, {
    type: Ks,
    tag: e,
    description: t
  }), ai || (n.description = t), n;
}, qs = function(t, n, r) {
  t === sn && qs(Po, n, r), Dc(t);
  var i = Id(n);
  return Dc(r), ht(jn, i) ? (r.enumerable ? (ht(t, Lt) && t[Lt][i] && (t[Lt][i] = !1), r = li(r, { enumerable: _c(0, !1) })) : (ht(t, Lt) || mr(t, Lt, _c(1, li(null))), t[Lt][i] = !0), jc(t, i, r)) : mr(t, i, r);
}, Pd = function(t, n) {
  Dc(t);
  var r = Hs(n), i = l1(r).concat(S1(r));
  return Vs(i, function(o) {
    (!ai || Od(b1, r, o)) && qs(t, o, r[o]);
  }), t;
}, IB = function(t, n) {
  return n === void 0 ? li(t) : Pd(li(t), n);
}, b1 = function(t) {
  var n = Id(t), r = Od(TB, this, n);
  return this === sn && ht(jn, n) && !ht(Po, n) ? !1 : r || !ht(this, n) || !ht(jn, n) || ht(this, Lt) && this[Lt][n] ? r : !0;
}, x1 = function(t, n) {
  var r = Hs(t), i = Id(n);
  if (!(r === sn && ht(jn, i) && !ht(Po, i))) {
    var o = v1(r, i);
    return o && ht(jn, i) && !(ht(r, Lt) && r[Lt][i]) && (o.enumerable = !0), o;
  }
}, w1 = function(t) {
  var n = m1(Hs(t)), r = [];
  return Vs(n, function(i) {
    !ht(jn, i) && !ht(p1, i) && g1(r, i);
  }), r;
}, S1 = function(e) {
  var t = e === sn, n = m1(t ? Po : Hs(e)), r = [];
  return Vs(n, function(i) {
    ht(jn, i) && (!t || ht(sn, i)) && g1(r, jn[i]);
  }), r;
};
si || (vr = function() {
  if (dB(zi, this)) throw new $B("Symbol is not a constructor");
  var t = !arguments.length || arguments[0] === void 0 ? void 0 : pB(arguments[0]), n = xm(t), r = function(i) {
    var o = this === void 0 ? Ro : this;
    o === sn && Od(r, Po, i), ht(o, Lt) && ht(o[Lt], n) && (o[Lt][n] = !1);
    var a = _c(1, i);
    try {
      jc(o, n, a);
    } catch (s) {
      if (!(s instanceof CB)) throw s;
      y1(o, n, a);
    }
  };
  return ai && Mc && jc(sn, n, { configurable: !0, set: r }), lu(n, t);
}, zi = vr[oo], bm(zi, "toString", function() {
  return wm(this).tag;
}), bm(vr, "withoutSetter", function(e) {
  return lu(xm(e), e);
}), d1.f = b1, f1.f = qs, mB.f = Pd, c1.f = x1, hB.f = u1.f = w1, vB.f = S1, xB.f = function(e) {
  return lu(bB(e), e);
}, ai && gB(zi, "description", {
  configurable: !0,
  get: function() {
    return wm(this).description;
  }
}));
Us({ global: !0, constructor: !0, wrap: !0, forced: !si, sham: !si }, {
  Symbol: vr
});
Vs(l1(OB), function(e) {
  wB(e);
});
Us({ target: Ks, stat: !0, forced: !si }, {
  useSetter: function() {
    Mc = !0;
  },
  useSimple: function() {
    Mc = !1;
  }
});
Us({ target: "Object", stat: !0, forced: !si, sham: !ai }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: IB,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: qs,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: Pd,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: x1
});
Us({ target: "Object", stat: !0, forced: !si }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: w1
});
SB();
EB(vr, Ks);
p1[Lt] = !0;
var RB = gi, E1 = RB && !!Symbol.for && !!Symbol.keyFor, PB = Be, AB = On, DB = Vt, _B = Oo, k1 = yi, MB = E1, uu = k1("string-to-symbol-registry"), jB = k1("symbol-to-string-registry");
PB({ target: "Symbol", stat: !0, forced: !MB }, {
  for: function(e) {
    var t = _B(e);
    if (DB(uu, t)) return uu[t];
    var n = AB("Symbol")(t);
    return uu[t] = n, jB[n] = t, n;
  }
});
var NB = Be, LB = Vt, FB = ko, BB = As, zB = yi, WB = E1, Sm = zB("symbol-to-string-registry");
NB({ target: "Symbol", stat: !0, forced: !WB }, {
  keyFor: function(t) {
    if (!FB(t)) throw new TypeError(BB(t) + " is not a symbol");
    if (LB(Sm, t)) return Sm[t];
  }
});
var UB = pt, Em = bi, HB = Rt, km = Sr, VB = Oo, Cm = UB([].push), KB = function(e) {
  if (HB(e)) return e;
  if (Em(e)) {
    for (var t = e.length, n = [], r = 0; r < t; r++) {
      var i = e[r];
      typeof i == "string" ? Cm(n, i) : (typeof i == "number" || km(i) === "Number" || km(i) === "String") && Cm(n, VB(i));
    }
    var o = n.length, a = !0;
    return function(s, l) {
      if (a)
        return a = !1, l;
      if (Em(this)) return l;
      for (var u = 0; u < o; u++) if (n[u] === s) return l;
    };
  }
}, qB = Be, C1 = On, $1 = id, GB = $n, Ao = pt, T1 = dt, $m = Rt, Tm = ko, O1 = Bs, YB = KB, XB = gi, JB = String, Xn = C1("JSON", "stringify"), sa = Ao(/./.exec), Om = Ao("".charAt), QB = Ao("".charCodeAt), ZB = Ao("".replace), e4 = Ao(1 .toString), t4 = /[\uD800-\uDFFF]/g, Im = /^[\uD800-\uDBFF]$/, Rm = /^[\uDC00-\uDFFF]$/, Pm = !XB || T1(function() {
  var e = C1("Symbol")("stringify detection");
  return Xn([e]) !== "[null]" || Xn({ a: e }) !== "{}" || Xn(Object(e)) !== "{}";
}), Am = T1(function() {
  return Xn("\uDF06\uD834") !== '"\\udf06\\ud834"' || Xn("\uDEAD") !== '"\\udead"';
}), n4 = function(e, t) {
  var n = O1(arguments), r = YB(t);
  if (!(!$m(r) && (e === void 0 || Tm(e))))
    return n[1] = function(i, o) {
      if ($m(r) && (o = GB(r, this, JB(i), o)), !Tm(o)) return o;
    }, $1(Xn, null, n);
}, r4 = function(e, t, n) {
  var r = Om(n, t - 1), i = Om(n, t + 1);
  return sa(Im, e) && !sa(Rm, i) || sa(Rm, e) && !sa(Im, r) ? "\\u" + e4(QB(e, 0), 16) : e;
};
Xn && qB({ target: "JSON", stat: !0, arity: 3, forced: Pm || Am }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  stringify: function(t, n, r) {
    var i = O1(arguments), o = $1(Pm ? n4 : Xn, null, i);
    return Am && typeof o == "string" ? ZB(o, t4, r4) : o;
  }
});
var i4 = Be, o4 = gi, a4 = dt, I1 = zs, s4 = Bn, l4 = !o4 || a4(function() {
  I1.f(1);
});
i4({ target: "Object", stat: !0, forced: l4 }, {
  getOwnPropertySymbols: function(t) {
    var n = I1.f;
    return n ? n(s4(t)) : [];
  }
});
var u4 = Qe;
u4("asyncIterator");
var c4 = Qe;
c4("hasInstance");
var f4 = Qe;
f4("isConcatSpreadable");
var d4 = Qe;
d4("iterator");
var p4 = Qe;
p4("match");
var h4 = Qe;
h4("matchAll");
var v4 = Qe;
v4("replace");
var m4 = Qe;
m4("search");
var g4 = Qe;
g4("species");
var y4 = Qe;
y4("split");
var b4 = Qe, x4 = a1;
b4("toPrimitive");
x4();
var w4 = On, S4 = Qe, E4 = xi;
S4("toStringTag");
E4(w4("Symbol"), "Symbol");
var k4 = Qe;
k4("unscopables");
var C4 = ft, $4 = xi;
$4(C4.JSON, "JSON", !0);
var T4 = wt, O4 = T4.Symbol, wi = {}, Nc = Bt, I4 = Vt, R1 = Function.prototype, R4 = Nc && Object.getOwnPropertyDescriptor, Ad = I4(R1, "name"), P4 = Ad && (function() {
}).name === "something", A4 = Ad && (!Nc || Nc && R4(R1, "name").configurable), D4 = {
  EXISTS: Ad,
  PROPER: P4,
  CONFIGURABLE: A4
}, _4 = dt, M4 = !_4(function() {
  function e() {
  }
  return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;
}), j4 = Vt, N4 = Rt, L4 = Bn, F4 = Ls, B4 = M4, Dm = F4("IE_PROTO"), Lc = Object, z4 = Lc.prototype, P1 = B4 ? Lc.getPrototypeOf : function(e) {
  var t = L4(e);
  if (j4(t, Dm)) return t[Dm];
  var n = t.constructor;
  return N4(n) && t instanceof n ? n.prototype : t instanceof Lc ? z4 : null;
}, W4 = dt, U4 = Rt, H4 = Ln, V4 = Cd, _m = P1, K4 = Ws, q4 = mt, Fc = q4("iterator"), A1 = !1, Mn, cu, fu;
[].keys && (fu = [].keys(), "next" in fu ? (cu = _m(_m(fu)), cu !== Object.prototype && (Mn = cu)) : A1 = !0);
var G4 = !H4(Mn) || W4(function() {
  var e = {};
  return Mn[Fc].call(e) !== e;
});
G4 ? Mn = {} : Mn = V4(Mn);
U4(Mn[Fc]) || K4(Mn, Fc, function() {
  return this;
});
var D1 = {
  IteratorPrototype: Mn,
  BUGGY_SAFARI_ITERATORS: A1
}, Y4 = D1.IteratorPrototype, X4 = Cd, J4 = Eo, Q4 = xi, Z4 = wi, e3 = function() {
  return this;
}, t3 = function(e, t, n, r) {
  var i = t + " Iterator";
  return e.prototype = X4(Y4, { next: J4(+!r, n) }), Q4(e, i, !1, !0), Z4[i] = e3, e;
}, n3 = Be, r3 = $n, _1 = D4, i3 = t3, o3 = P1, a3 = xi, Mm = Ws, s3 = mt, jm = wi, M1 = D1, l3 = _1.PROPER;
_1.CONFIGURABLE;
M1.IteratorPrototype;
var la = M1.BUGGY_SAFARI_ITERATORS, du = s3("iterator"), Nm = "keys", ua = "values", Lm = "entries", u3 = function() {
  return this;
}, j1 = function(e, t, n, r, i, o, a) {
  i3(n, t, r);
  var s = function(m) {
    if (m === i && p) return p;
    if (!la && m && m in c) return c[m];
    switch (m) {
      case Nm:
        return function() {
          return new n(this, m);
        };
      case ua:
        return function() {
          return new n(this, m);
        };
      case Lm:
        return function() {
          return new n(this, m);
        };
    }
    return function() {
      return new n(this);
    };
  }, l = t + " Iterator", u = !1, c = e.prototype, f = c[du] || c["@@iterator"] || i && c[i], p = !la && f || s(i), d = t === "Array" && c.entries || f, v, h, g;
  if (d && (v = o3(d.call(new e())), v !== Object.prototype && v.next && (a3(v, l, !0, !0), jm[l] = u3)), l3 && i === ua && f && f.name !== ua && (u = !0, p = function() {
    return r3(f, this);
  }), i)
    if (h = {
      values: s(ua),
      keys: o ? p : s(Nm),
      entries: s(Lm)
    }, a) for (g in h)
      (la || u || !(g in c)) && Mm(c, g, h[g]);
    else n3({ target: t, proto: !0, forced: la || u }, h);
  return a && c[du] !== p && Mm(c, du, p, { name: i }), jm[t] = p, h;
}, N1 = function(e, t) {
  return { value: e, done: t };
}, c3 = Tn, Fm = wi, L1 = $d;
dn.f;
var f3 = j1, ca = N1, F1 = "Array Iterator", d3 = L1.set, p3 = L1.getterFor(F1);
f3(Array, "Array", function(e, t) {
  d3(this, {
    type: F1,
    target: c3(e),
    // target
    index: 0,
    // next index
    kind: t
    // kind
  });
}, function() {
  var e = p3(this), t = e.target, n = e.index++;
  if (!t || n >= t.length)
    return e.target = null, ca(void 0, !0);
  switch (e.kind) {
    case "keys":
      return ca(n, !1);
    case "values":
      return ca(t[n], !1);
  }
  return ca([n, t[n]], !1);
}, "values");
Fm.Arguments = Fm.Array;
var h3 = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, v3 = h3, m3 = ft, g3 = xi, Bm = wi;
for (var pu in v3)
  g3(m3[pu], pu), Bm[pu] = Bm.Array;
var y3 = O4, b3 = y3, x3 = mt, w3 = dn.f, zm = x3("metadata"), Wm = Function.prototype;
Wm[zm] === void 0 && w3(Wm, zm, {
  value: null
});
var S3 = Qe;
S3("asyncDispose");
var E3 = Qe;
E3("dispose");
var k3 = Qe;
k3("metadata");
var C3 = b3, $3 = C3, T3 = On, O3 = pt, Dd = T3("Symbol"), I3 = Dd.keyFor, R3 = O3(Dd.prototype.valueOf), B1 = Dd.isRegisteredSymbol || function(t) {
  try {
    return I3(R3(t)) !== void 0;
  } catch {
    return !1;
  }
}, P3 = Be, A3 = B1;
P3({ target: "Symbol", stat: !0 }, {
  isRegisteredSymbol: A3
});
var D3 = yi, z1 = On, _3 = pt, M3 = ko, j3 = mt, ns = z1("Symbol"), Um = ns.isWellKnownSymbol, W1 = z1("Object", "getOwnPropertyNames"), N3 = _3(ns.prototype.valueOf), Hm = D3("wks");
for (var hu = 0, Vm = W1(ns), L3 = Vm.length; hu < L3; hu++)
  try {
    var Km = Vm[hu];
    M3(ns[Km]) && j3(Km);
  } catch {
  }
var U1 = function(t) {
  if (Um && Um(t)) return !0;
  try {
    for (var n = N3(t), r = 0, i = W1(Hm), o = i.length; r < o; r++)
      if (Hm[i[r]] == n) return !0;
  } catch {
  }
  return !1;
}, F3 = Be, B3 = U1;
F3({ target: "Symbol", stat: !0, forced: !0 }, {
  isWellKnownSymbol: B3
});
var z3 = Qe;
z3("customMatcher");
var W3 = Qe;
W3("observable");
var U3 = Be, H3 = B1;
U3({ target: "Symbol", stat: !0, name: "isRegisteredSymbol" }, {
  isRegistered: H3
});
var V3 = Be, K3 = U1;
V3({ target: "Symbol", stat: !0, name: "isWellKnownSymbol", forced: !0 }, {
  isWellKnown: K3
});
var q3 = Qe;
q3("matcher");
var G3 = Qe;
G3("metadataKey");
var Y3 = Qe;
Y3("patternMatch");
var X3 = Qe;
X3("replaceAll");
var J3 = $3, Q3 = J3, Z3 = Q3;
const Ur = /* @__PURE__ */ $e(Z3);
var _d = pt, ez = _s, tz = Oo, nz = ld, rz = _d("".charAt), qm = _d("".charCodeAt), iz = _d("".slice), Gm = function(e) {
  return function(t, n) {
    var r = tz(nz(t)), i = ez(n), o = r.length, a, s;
    return i < 0 || i >= o ? e ? "" : void 0 : (a = qm(r, i), a < 55296 || a > 56319 || i + 1 === o || (s = qm(r, i + 1)) < 56320 || s > 57343 ? e ? rz(r, i) : a : e ? iz(r, i, i + 2) : (a - 55296 << 10) + (s - 56320) + 65536);
  };
}, oz = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: Gm(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: Gm(!0)
}, az = oz.charAt, sz = Oo, H1 = $d, lz = j1, Ym = N1, V1 = "String Iterator", uz = H1.set, cz = H1.getterFor(V1);
lz(String, "String", function(e) {
  uz(this, {
    type: V1,
    string: sz(e),
    index: 0
  });
}, function() {
  var t = cz(this), n = t.string, r = t.index, i;
  return r >= n.length ? Ym(void 0, !0) : (i = az(n, r), t.index += i.length, Ym(i, !1));
});
var fz = To, Xm = dd, dz = sd, pz = wi, hz = mt, vz = hz("iterator"), Md = function(e) {
  if (!dz(e)) return Xm(e, vz) || Xm(e, "@@iterator") || pz[fz(e)];
}, mz = Md, gz = mz, yz = gz, bz = yz, xz = bz, wz = xz, Sz = wz, Ez = Sz, kz = Ez;
const K1 = /* @__PURE__ */ $e(kz);
var Cz = Bt, $z = bi, Tz = TypeError, Oz = Object.getOwnPropertyDescriptor, Iz = Cz && !function() {
  if (this !== void 0) return !0;
  try {
    Object.defineProperty([], "length", { writable: !1 }).length = 1;
  } catch (e) {
    return e instanceof TypeError;
  }
}(), q1 = Iz ? function(e, t) {
  if ($z(e) && !Oz(e, "length").writable)
    throw new Tz("Cannot set read only .length");
  return e.length = t;
} : function(e, t) {
  return e.length = t;
}, Rz = Be, Pz = Bn, Az = Er, Dz = q1, _z = gd, Mz = dt, jz = Mz(function() {
  return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
}), Nz = function() {
  try {
    Object.defineProperty([], "length", { writable: !1 }).push();
  } catch (e) {
    return e instanceof TypeError;
  }
}, Lz = jz || !Nz();
Rz({ target: "Array", proto: !0, arity: 1, forced: Lz }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function(t) {
    var n = Pz(this), r = Az(n), i = arguments.length;
    _z(r + i);
    for (var o = 0; o < i; o++)
      n[r] = arguments[o], r++;
    return Dz(n, r), r;
  }
});
var Fz = ft, Bz = wt, kr = function(e, t) {
  var n = Bz[e + "Prototype"], r = n && n[t];
  if (r) return r;
  var i = Fz[e], o = i && i.prototype;
  return o && o[t];
}, zz = kr, Wz = zz("Array", "push"), Uz = Fn, Hz = Wz, vu = Array.prototype, Vz = function(e) {
  var t = e.push;
  return e === vu || Uz(vu, e) && t === vu.push ? Hz : t;
}, Kz = Vz, qz = Kz, Gz = qz, Yz = Gz, Xz = Yz, Jz = Xz, Qz = Jz;
const Zz = /* @__PURE__ */ $e(Qz);
function e5(e, t) {
  var n = e == null ? null : typeof Ur < "u" && K1(e) || e["@@iterator"];
  if (n != null) {
    var r, i, o, a, s = [], l = !0, u = !1;
    try {
      if (o = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        l = !1;
      } else for (; !(l = (r = o.call(n)).done) && (Zz(s).call(s, r.value), s.length !== t); l = !0) ;
    } catch (c) {
      u = !0, i = c;
    } finally {
      try {
        if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return;
      } finally {
        if (u) throw i;
      }
    }
    return s;
  }
}
var t5 = Be, Jm = bi, n5 = xd, r5 = Ln, Qm = Sd, i5 = Er, o5 = Tn, a5 = $o, s5 = mt, l5 = Ms, u5 = Bs, c5 = l5("slice"), f5 = s5("species"), mu = Array, d5 = Math.max;
t5({ target: "Array", proto: !0, forced: !c5 }, {
  slice: function(t, n) {
    var r = o5(this), i = i5(r), o = Qm(t, i), a = Qm(n === void 0 ? i : n, i), s, l, u;
    if (Jm(r) && (s = r.constructor, n5(s) && (s === mu || Jm(s.prototype)) ? s = void 0 : r5(s) && (s = s[f5], s === null && (s = void 0)), s === mu || s === void 0))
      return u5(r, o, a);
    for (l = new (s === void 0 ? mu : s)(d5(a - o, 0)), u = 0; o < a; o++, u++) o in r && a5(l, u, r[o]);
    return l.length = u, l;
  }
});
var p5 = kr, h5 = p5("Array", "slice"), v5 = Fn, m5 = h5, gu = Array.prototype, g5 = function(e) {
  var t = e.slice;
  return e === gu || v5(gu, e) && t === gu.slice ? m5 : t;
}, y5 = g5, b5 = y5, x5 = b5, w5 = x5, S5 = w5, E5 = S5, k5 = E5;
const C5 = /* @__PURE__ */ $e(k5);
var $5 = $n, Zm = rr, T5 = dd, O5 = function(e, t, n) {
  var r, i;
  Zm(e);
  try {
    if (r = T5(e, "return"), !r) {
      if (t === "throw") throw n;
      return n;
    }
    r = $5(r, e);
  } catch (o) {
    i = !0, r = o;
  }
  if (t === "throw") throw n;
  if (i) throw r;
  return Zm(r), n;
}, I5 = rr, R5 = O5, P5 = function(e, t, n, r) {
  try {
    return r ? t(I5(n)[0], n[1]) : t(n);
  } catch (i) {
    R5(e, "throw", i);
  }
}, A5 = mt, D5 = wi, _5 = A5("iterator"), M5 = Array.prototype, j5 = function(e) {
  return e !== void 0 && (D5.Array === e || M5[_5] === e);
}, N5 = $n, L5 = fd, F5 = rr, B5 = As, z5 = Md, W5 = TypeError, U5 = function(e, t) {
  var n = arguments.length < 2 ? z5(e) : t;
  if (L5(n)) return F5(N5(n, e));
  throw new W5(B5(e) + " is not iterable");
}, H5 = md, V5 = $n, K5 = Bn, q5 = P5, G5 = j5, Y5 = xd, X5 = Er, eg = $o, J5 = U5, Q5 = Md, tg = Array, Z5 = function(t) {
  var n = K5(t), r = Y5(this), i = arguments.length, o = i > 1 ? arguments[1] : void 0, a = o !== void 0;
  a && (o = H5(o, i > 2 ? arguments[2] : void 0));
  var s = Q5(n), l = 0, u, c, f, p, d, v;
  if (s && !(this === tg && G5(s)))
    for (c = r ? new this() : [], p = J5(n, s), d = p.next; !(f = V5(d, p)).done; l++)
      v = a ? q5(p, o, [f.value, l], !0) : f.value, eg(c, l, v);
  else
    for (u = X5(n), c = r ? new this(u) : tg(u); u > l; l++)
      v = a ? o(n[l], l) : n[l], eg(c, l, v);
  return c.length = l, c;
}, eW = mt, G1 = eW("iterator"), Y1 = !1;
try {
  var tW = 0, ng = {
    next: function() {
      return { done: !!tW++ };
    },
    return: function() {
      Y1 = !0;
    }
  };
  ng[G1] = function() {
    return this;
  }, Array.from(ng, function() {
    throw 2;
  });
} catch {
}
var nW = function(e, t) {
  try {
    if (!t && !Y1) return !1;
  } catch {
    return !1;
  }
  var n = !1;
  try {
    var r = {};
    r[G1] = function() {
      return {
        next: function() {
          return { done: n = !0 };
        }
      };
    }, e(r);
  } catch {
  }
  return n;
}, rW = Be, iW = Z5, oW = nW, aW = !oW(function(e) {
  Array.from(e);
});
rW({ target: "Array", stat: !0, forced: aW }, {
  from: iW
});
var sW = wt, lW = sW.Array.from, uW = lW, cW = uW, fW = cW, dW = fW, pW = dW, hW = pW, vW = hW;
const X1 = /* @__PURE__ */ $e(vW);
function Bc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function J1(e, t) {
  if (e) {
    var n;
    if (typeof e == "string") return Bc(e, t);
    var r = C5(n = {}.toString.call(e)).call(n, 8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? X1(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Bc(e, t) : void 0;
  }
}
function mW() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function bn(e, t) {
  return FN(e) || e5(e, t) || J1(e, t) || mW();
}
var Q1 = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r = [], i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        if (o) {
          var a = typeof o;
          if (a === "string" || a === "number")
            r.push(o);
          else if (Array.isArray(o)) {
            if (o.length) {
              var s = n.apply(null, o);
              s && r.push(s);
            }
          } else if (a === "object")
            if (o.toString === Object.prototype.toString)
              for (var l in o)
                t.call(o, l) && o[l] && r.push(l);
            else
              r.push(o.toString());
        }
      }
      return r.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(Q1);
var gW = Q1.exports;
const jd = /* @__PURE__ */ $e(gW);
var zc = { exports: {} }, yu, rg;
function Nd() {
  if (rg) return yu;
  rg = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return yu = e, yu;
}
var bu, ig;
function yW() {
  if (ig) return bu;
  ig = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Nd(), n = {}, r = Function.call.bind(Object.prototype.hasOwnProperty);
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (r(o, c)) {
          var f;
          try {
            if (typeof o[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = o[c](a, c, l, s, null, t);
          } catch (v) {
            f = v;
          }
          if (f && !(f instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var d = u ? u() : "";
            e(
              "Failed " + s + " type: " + f.message + (d ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, bu = i, bu;
}
var xu, og;
function bW() {
  if (og) return xu;
  og = 1;
  var e = Os(), t = fw(), n = Nd(), r = yW(), i = Function.call.bind(Object.prototype.hasOwnProperty), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return xu = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function f(P) {
      var y = P && (u && P[u] || P[c]);
      if (typeof y == "function")
        return y;
    }
    var p = "<<anonymous>>", d = {
      array: m("array"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: b(),
      arrayOf: w,
      element: C(),
      elementType: S(),
      instanceOf: E,
      node: O(),
      objectOf: N,
      oneOf: I,
      oneOfType: A,
      shape: D,
      exact: U
    };
    function v(P, y) {
      return P === y ? P !== 0 || 1 / P === 1 / y : P !== P && y !== y;
    }
    function h(P) {
      this.message = P, this.stack = "";
    }
    h.prototype = Error.prototype;
    function g(P) {
      if (process.env.NODE_ENV !== "production")
        var y = {}, T = 0;
      function j(F, G, K, Y, Q, Z, X) {
        if (Y = Y || p, Z = Z || K, X !== n) {
          if (l) {
            var J = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw J.name = "Invariant Violation", J;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var V = Y + ":" + K;
            !y[V] && // Avoid spamming the console because they are often not actionable except for lib authors
            T < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + Z + "` prop on `" + Y + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), y[V] = !0, T++);
          }
        }
        return G[K] == null ? F ? G[K] === null ? new h("The " + Q + " `" + Z + "` is marked as required " + ("in `" + Y + "`, but its value is `null`.")) : new h("The " + Q + " `" + Z + "` is marked as required in " + ("`" + Y + "`, but its value is `undefined`.")) : null : P(G, K, Y, Q, Z);
      }
      var x = j.bind(null, !1);
      return x.isRequired = j.bind(null, !0), x;
    }
    function m(P) {
      function y(T, j, x, F, G, K) {
        var Y = T[j], Q = _(Y);
        if (Q !== P) {
          var Z = z(Y);
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + Z + "` supplied to `" + x + "`, expected ") + ("`" + P + "`."));
        }
        return null;
      }
      return g(y);
    }
    function b() {
      return g(a);
    }
    function w(P) {
      function y(T, j, x, F, G) {
        if (typeof P != "function")
          return new h("Property `" + G + "` of component `" + x + "` has invalid PropType notation inside arrayOf.");
        var K = T[j];
        if (!Array.isArray(K)) {
          var Y = _(K);
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + Y + "` supplied to `" + x + "`, expected an array."));
        }
        for (var Q = 0; Q < K.length; Q++) {
          var Z = P(K, Q, x, F, G + "[" + Q + "]", n);
          if (Z instanceof Error)
            return Z;
        }
        return null;
      }
      return g(y);
    }
    function C() {
      function P(y, T, j, x, F) {
        var G = y[T];
        if (!s(G)) {
          var K = _(G);
          return new h("Invalid " + x + " `" + F + "` of type " + ("`" + K + "` supplied to `" + j + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(P);
    }
    function S() {
      function P(y, T, j, x, F) {
        var G = y[T];
        if (!e.isValidElementType(G)) {
          var K = _(G);
          return new h("Invalid " + x + " `" + F + "` of type " + ("`" + K + "` supplied to `" + j + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(P);
    }
    function E(P) {
      function y(T, j, x, F, G) {
        if (!(T[j] instanceof P)) {
          var K = P.name || p, Y = H(T[j]);
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + Y + "` supplied to `" + x + "`, expected ") + ("instance of `" + K + "`."));
        }
        return null;
      }
      return g(y);
    }
    function I(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function y(T, j, x, F, G) {
        for (var K = T[j], Y = 0; Y < P.length; Y++)
          if (v(K, P[Y]))
            return null;
        var Q = JSON.stringify(P, function(X, J) {
          var V = z(J);
          return V === "symbol" ? String(J) : J;
        });
        return new h("Invalid " + F + " `" + G + "` of value `" + String(K) + "` " + ("supplied to `" + x + "`, expected one of " + Q + "."));
      }
      return g(y);
    }
    function N(P) {
      function y(T, j, x, F, G) {
        if (typeof P != "function")
          return new h("Property `" + G + "` of component `" + x + "` has invalid PropType notation inside objectOf.");
        var K = T[j], Y = _(K);
        if (Y !== "object")
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + Y + "` supplied to `" + x + "`, expected an object."));
        for (var Q in K)
          if (i(K, Q)) {
            var Z = P(K, Q, x, F, G + "." + Q, n);
            if (Z instanceof Error)
              return Z;
          }
        return null;
      }
      return g(y);
    }
    function A(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var y = 0; y < P.length; y++) {
        var T = P[y];
        if (typeof T != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + q(T) + " at index " + y + "."
          ), a;
      }
      function j(x, F, G, K, Y) {
        for (var Q = 0; Q < P.length; Q++) {
          var Z = P[Q];
          if (Z(x, F, G, K, Y, n) == null)
            return null;
        }
        return new h("Invalid " + K + " `" + Y + "` supplied to " + ("`" + G + "`."));
      }
      return g(j);
    }
    function O() {
      function P(y, T, j, x, F) {
        return L(y[T]) ? null : new h("Invalid " + x + " `" + F + "` supplied to " + ("`" + j + "`, expected a ReactNode."));
      }
      return g(P);
    }
    function D(P) {
      function y(T, j, x, F, G) {
        var K = T[j], Y = _(K);
        if (Y !== "object")
          return new h("Invalid " + F + " `" + G + "` of type `" + Y + "` " + ("supplied to `" + x + "`, expected `object`."));
        for (var Q in P) {
          var Z = P[Q];
          if (Z) {
            var X = Z(K, Q, x, F, G + "." + Q, n);
            if (X)
              return X;
          }
        }
        return null;
      }
      return g(y);
    }
    function U(P) {
      function y(T, j, x, F, G) {
        var K = T[j], Y = _(K);
        if (Y !== "object")
          return new h("Invalid " + F + " `" + G + "` of type `" + Y + "` " + ("supplied to `" + x + "`, expected `object`."));
        var Q = t({}, T[j], P);
        for (var Z in Q) {
          var X = P[Z];
          if (!X)
            return new h(
              "Invalid " + F + " `" + G + "` key `" + Z + "` supplied to `" + x + "`.\nBad object: " + JSON.stringify(T[j], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var J = X(K, Z, x, F, G + "." + Z, n);
          if (J)
            return J;
        }
        return null;
      }
      return g(y);
    }
    function L(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(L);
          if (P === null || s(P))
            return !0;
          var y = f(P);
          if (y) {
            var T = y.call(P), j;
            if (y !== P.entries) {
              for (; !(j = T.next()).done; )
                if (!L(j.value))
                  return !1;
            } else
              for (; !(j = T.next()).done; ) {
                var x = j.value;
                if (x && !L(x[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function M(P, y) {
      return P === "symbol" ? !0 : y ? y["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && y instanceof Symbol : !1;
    }
    function _(P) {
      var y = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : M(y, P) ? "symbol" : y;
    }
    function z(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var y = _(P);
      if (y === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return y;
    }
    function q(P) {
      var y = z(P);
      switch (y) {
        case "array":
        case "object":
          return "an " + y;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + y;
        default:
          return y;
      }
    }
    function H(P) {
      return !P.constructor || !P.constructor.name ? p : P.constructor.name;
    }
    return d.checkPropTypes = r, d.resetWarningCache = r.resetWarningCache, d.PropTypes = d, d;
  }, xu;
}
var wu, ag;
function xW() {
  if (ag) return wu;
  ag = 1;
  var e = Nd();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, wu = function() {
    function r(a, s, l, u, c, f) {
      if (f !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, wu;
}
if (process.env.NODE_ENV !== "production") {
  var wW = Os(), SW = !0;
  zc.exports = bW()(wW.isElement, SW);
} else
  zc.exports = xW()();
var EW = zc.exports;
const Te = /* @__PURE__ */ $e(EW);
var Ld = /* @__PURE__ */ Le.createContext({
  scrollTo: function() {
    return 0;
  },
  scrollToBottom: function() {
    return 0;
  },
  scrollToEnd: function() {
    return 0;
  },
  scrollToStart: function() {
    return 0;
  },
  scrollToTop: function() {
    return 0;
  }
});
Ld.displayName = "ScrollToBottomFunctionContext";
function kW() {
  return ci(Ld);
}
function CW() {
  var e = kW(), t = e.scrollToEnd;
  return t;
}
var Fd = /* @__PURE__ */ Le.createContext({
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom"
});
Fd.displayName = "ScrollToBottomState1Context";
var Bd = /* @__PURE__ */ Le.createContext({
  animating: !1,
  animatingToEnd: !1,
  sticky: !0
});
Bd.displayName = "ScrollToBottomState2Context";
var zd = /* @__PURE__ */ Le.createContext({
  animating: !1,
  animatingToEnd: !1,
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom",
  sticky: !0
});
zd.displayName = "ScrollToBottomStateContext";
var sg = [zd, Fd, Bd];
function $W(e) {
  return ci(sg[e] || sg[0]);
}
function TW() {
  var e = $W(2), t = e.sticky;
  return [t];
}
var Gs = /* @__PURE__ */ Le.createContext({
  offsetHeight: 0,
  scrollHeight: 0,
  setTarget: function() {
    return 0;
  },
  styleToClassName: function() {
    return "";
  }
});
Gs.displayName = "ScrollToBottomInternalContext";
function OW() {
  return ci(Gs);
}
function Wd() {
  var e = OW(), t = e.styleToClassName;
  return t;
}
var IW = {
  backgroundColor: "rgba(0, 0, 0, .2)",
  borderRadius: 10,
  borderWidth: 0,
  bottom: 5,
  cursor: "pointer",
  height: 20,
  outline: 0,
  position: "absolute",
  right: 20,
  width: 20,
  "&:hover": {
    backgroundColor: "rgba(0, 0, 0, .4)"
  },
  "&:active": {
    backgroundColor: "rgba(0, 0, 0, .6)"
  }
}, Ud = function(t) {
  var n = t.children, r = t.className, i = TW(), o = bn(i, 1), a = o[0], s = Wd()(IW), l = CW();
  return !a && /* @__PURE__ */ Le.createElement("button", {
    className: jd(s, (r || "") + ""),
    onClick: l,
    type: "button"
  }, n);
};
Ud.defaultProps = {
  children: void 0,
  className: ""
};
Ud.propTypes = {
  children: Te.any,
  className: Te.string
};
var Z1 = { exports: {} }, RW = Be, PW = Bt, lg = dn.f;
RW({ target: "Object", stat: !0, forced: Object.defineProperty !== lg, sham: !PW }, {
  defineProperty: lg
});
var AW = wt, eS = AW.Object, DW = Z1.exports = function(t, n, r) {
  return eS.defineProperty(t, n, r);
};
eS.defineProperty.sham && (DW.sham = !0);
var _W = Z1.exports, MW = _W, tS = MW, jW = tS, NW = jW, LW = NW, FW = LW, BW = FW;
const zW = /* @__PURE__ */ $e(BW);
var WW = Io, UW = WW.f("iterator"), HW = UW, VW = HW, KW = VW, qW = KW, GW = qW, YW = GW, XW = YW;
const JW = /* @__PURE__ */ $e(XW);
function ao(e) {
  "@babel/helpers - typeof";
  return ao = typeof Ur == "function" && typeof JW == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Ur == "function" && t.constructor === Ur && t !== Ur.prototype ? "symbol" : typeof t;
  }, ao(e);
}
var QW = Io, ZW = QW.f("toPrimitive"), e6 = ZW, t6 = e6, n6 = t6, r6 = n6, i6 = r6, o6 = i6, a6 = o6;
const s6 = /* @__PURE__ */ $e(a6);
function l6(e, t) {
  if (ao(e) != "object" || !e) return e;
  var n = e[s6];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ao(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function u6(e) {
  var t = l6(e, "string");
  return ao(t) == "symbol" ? t : t + "";
}
function c6(e, t, n) {
  return (t = u6(t)) in e ? zW(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function f6(e) {
  if (Kw(e)) return Bc(e);
}
function d6(e) {
  if (typeof Ur < "u" && K1(e) != null || e["@@iterator"] != null) return X1(e);
}
function p6() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ke(e) {
  return f6(e) || d6(e) || J1(e) || p6();
}
var fa = function(e) {
  return e && e.Math == Math && e;
}, Kt = (
  // eslint-disable-next-line es/no-global-this -- safe
  fa(typeof globalThis == "object" && globalThis) || fa(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  fa(typeof self == "object" && self) || fa(typeof an == "object" && an) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), Hd = {}, pn = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, h6 = pn, Cr = !h6(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), nS = {}, rS = {}.propertyIsEnumerable, iS = Object.getOwnPropertyDescriptor, v6 = iS && !rS.call({ 1: 2 }, 1);
nS.f = v6 ? function(t) {
  var n = iS(this, t);
  return !!n && n.enumerable;
} : rS;
var oS = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, m6 = {}.toString, Vd = function(e) {
  return m6.call(e).slice(8, -1);
}, g6 = pn, y6 = Vd, b6 = "".split, x6 = g6(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e) {
  return y6(e) == "String" ? b6.call(e, "") : Object(e);
} : Object, Ys = function(e) {
  if (e == null) throw TypeError("Can't call method on " + e);
  return e;
}, w6 = x6, S6 = Ys, Kd = function(e) {
  return w6(S6(e));
}, en = function(e) {
  return typeof e == "function";
}, E6 = en, Do = function(e) {
  return typeof e == "object" ? e !== null : E6(e);
}, Su = Kt, k6 = en, C6 = function(e) {
  return k6(e) ? e : void 0;
}, Xs = function(e, t) {
  return arguments.length < 2 ? C6(Su[e]) : Su[e] && Su[e][t];
}, $6 = Xs, T6 = $6("navigator", "userAgent") || "", aS = Kt, Eu = T6, ug = aS.process, cg = aS.Deno, fg = ug && ug.versions || cg && cg.version, dg = fg && fg.v8, gn, rs;
dg ? (gn = dg.split("."), rs = gn[0] < 4 ? 1 : gn[0] + gn[1]) : Eu && (gn = Eu.match(/Edge\/(\d+)/), (!gn || gn[1] >= 74) && (gn = Eu.match(/Chrome\/(\d+)/), gn && (rs = gn[1])));
var O6 = rs && +rs, pg = O6, I6 = pn, sS = !!Object.getOwnPropertySymbols && !I6(function() {
  var e = Symbol();
  return !String(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && pg && pg < 41;
}), R6 = sS, lS = R6 && !Symbol.sham && typeof Symbol.iterator == "symbol", P6 = en, A6 = Xs, D6 = lS, uS = D6 ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = A6("Symbol");
  return P6(t) && Object(e) instanceof t;
}, _6 = function(e) {
  try {
    return String(e);
  } catch {
    return "Object";
  }
}, M6 = en, j6 = _6, N6 = function(e) {
  if (M6(e)) return e;
  throw TypeError(j6(e) + " is not a function");
}, L6 = N6, cS = function(e, t) {
  var n = e[t];
  return n == null ? void 0 : L6(n);
}, ku = en, Cu = Do, F6 = function(e, t) {
  var n, r;
  if (t === "string" && ku(n = e.toString) && !Cu(r = n.call(e)) || ku(n = e.valueOf) && !Cu(r = n.call(e)) || t !== "string" && ku(n = e.toString) && !Cu(r = n.call(e))) return r;
  throw TypeError("Can't convert object to primitive value");
}, fS = { exports: {} }, hg = Kt, qd = function(e, t) {
  try {
    Object.defineProperty(hg, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    hg[e] = t;
  }
  return t;
}, B6 = Kt, z6 = qd, vg = "__core-js_shared__", W6 = B6[vg] || z6(vg, {}), Gd = W6, mg = Gd;
(fS.exports = function(e, t) {
  return mg[e] || (mg[e] = t !== void 0 ? t : {});
})("versions", []).push({
  version: "3.18.3",
  mode: "global",
  copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
});
var Yd = fS.exports, U6 = Ys, dS = function(e) {
  return Object(U6(e));
}, H6 = dS, V6 = {}.hasOwnProperty, $r = Object.hasOwn || function(t, n) {
  return V6.call(H6(t), n);
}, K6 = 0, q6 = Math.random(), pS = function(e) {
  return "Symbol(" + String(e === void 0 ? "" : e) + ")_" + (++K6 + q6).toString(36);
}, G6 = Kt, Y6 = Yd, gg = $r, X6 = pS, yg = sS, J6 = lS, ji = Y6("wks"), Gi = G6.Symbol, Q6 = J6 ? Gi : Gi && Gi.withoutSetter || X6, _o = function(e) {
  return (!gg(ji, e) || !(yg || typeof ji[e] == "string")) && (yg && gg(Gi, e) ? ji[e] = Gi[e] : ji[e] = Q6("Symbol." + e)), ji[e];
}, bg = Do, xg = uS, Z6 = cS, eU = F6, tU = _o, nU = tU("toPrimitive"), rU = function(e, t) {
  if (!bg(e) || xg(e)) return e;
  var n = Z6(e, nU), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = n.call(e, t), !bg(r) || xg(r)) return r;
    throw TypeError("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), eU(e, t);
}, iU = rU, oU = uS, hS = function(e) {
  var t = iU(e, "string");
  return oU(t) ? t : String(t);
}, aU = Kt, wg = Do, Wc = aU.document, sU = wg(Wc) && wg(Wc.createElement), vS = function(e) {
  return sU ? Wc.createElement(e) : {};
}, lU = Cr, uU = pn, cU = vS, mS = !lU && !uU(function() {
  return Object.defineProperty(cU("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
}), fU = Cr, dU = nS, pU = oS, hU = Kd, vU = hS, mU = $r, gU = mS, Sg = Object.getOwnPropertyDescriptor;
Hd.f = fU ? Sg : function(t, n) {
  if (t = hU(t), n = vU(n), gU) try {
    return Sg(t, n);
  } catch {
  }
  if (mU(t, n)) return pU(!dU.f.call(t, n), t[n]);
};
var Mo = {}, yU = Do, ir = function(e) {
  if (yU(e)) return e;
  throw TypeError(String(e) + " is not an object");
}, bU = Cr, xU = mS, Eg = ir, wU = hS, kg = Object.defineProperty;
Mo.f = bU ? kg : function(t, n, r) {
  if (Eg(t), n = wU(n), Eg(r), xU) try {
    return kg(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw TypeError("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var SU = Cr, EU = Mo, kU = oS, Js = SU ? function(e, t, n) {
  return EU.f(e, t, kU(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, gS = { exports: {} }, CU = en, Uc = Gd, $U = Function.toString;
CU(Uc.inspectSource) || (Uc.inspectSource = function(e) {
  return $U.call(e);
});
var yS = Uc.inspectSource, TU = Kt, OU = en, IU = yS, Cg = TU.WeakMap, RU = OU(Cg) && /native code/.test(IU(Cg)), PU = Yd, AU = pS, $g = PU("keys"), bS = function(e) {
  return $g[e] || ($g[e] = AU(e));
}, Xd = {}, DU = RU, _U = Kt, MU = Do, jU = Js, $u = $r, Tu = Gd, NU = bS, LU = Xd, Tg = "Object already initialized", FU = _U.WeakMap, is, so, os, BU = function(e) {
  return os(e) ? so(e) : is(e, {});
}, zU = function(e) {
  return function(t) {
    var n;
    if (!MU(t) || (n = so(t)).type !== e)
      throw TypeError("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (DU || Tu.state) {
  var fr = Tu.state || (Tu.state = new FU()), WU = fr.get, Og = fr.has, UU = fr.set;
  is = function(e, t) {
    if (Og.call(fr, e)) throw new TypeError(Tg);
    return t.facade = e, UU.call(fr, e, t), t;
  }, so = function(e) {
    return WU.call(fr, e) || {};
  }, os = function(e) {
    return Og.call(fr, e);
  };
} else {
  var Dr = NU("state");
  LU[Dr] = !0, is = function(e, t) {
    if ($u(e, Dr)) throw new TypeError(Tg);
    return t.facade = e, jU(e, Dr, t), t;
  }, so = function(e) {
    return $u(e, Dr) ? e[Dr] : {};
  }, os = function(e) {
    return $u(e, Dr);
  };
}
var xS = {
  set: is,
  get: so,
  has: os,
  enforce: BU,
  getterFor: zU
}, Hc = Cr, HU = $r, wS = Function.prototype, VU = Hc && Object.getOwnPropertyDescriptor, Jd = HU(wS, "name"), KU = Jd && (function() {
}).name === "something", qU = Jd && (!Hc || Hc && VU(wS, "name").configurable), Qd = {
  EXISTS: Jd,
  PROPER: KU,
  CONFIGURABLE: qU
}, GU = Kt, Ig = en, YU = $r, Rg = Js, XU = qd, JU = yS, SS = xS, QU = Qd.CONFIGURABLE, ZU = SS.get, eH = SS.enforce, tH = String(String).split("String");
(gS.exports = function(e, t, n, r) {
  var i = r ? !!r.unsafe : !1, o = r ? !!r.enumerable : !1, a = r ? !!r.noTargetGet : !1, s = r && r.name !== void 0 ? r.name : t, l;
  if (Ig(n) && (String(s).slice(0, 7) === "Symbol(" && (s = "[" + String(s).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!YU(n, "name") || QU && n.name !== s) && Rg(n, "name", s), l = eH(n), l.source || (l.source = tH.join(typeof s == "string" ? s : ""))), e === GU) {
    o ? e[t] = n : XU(t, n);
    return;
  } else i ? !a && e[t] && (o = !0) : delete e[t];
  o ? e[t] = n : Rg(e, t, n);
})(Function.prototype, "toString", function() {
  return Ig(this) && ZU(this).source || JU(this);
});
var jo = gS.exports, ES = {}, nH = Math.ceil, rH = Math.floor, Qs = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : (t > 0 ? rH : nH)(t);
}, iH = Qs, oH = Math.max, aH = Math.min, sH = function(e, t) {
  var n = iH(e);
  return n < 0 ? oH(n + t, 0) : aH(n, t);
}, lH = Qs, uH = Math.min, kS = function(e) {
  return e > 0 ? uH(lH(e), 9007199254740991) : 0;
}, cH = kS, fH = function(e) {
  return cH(e.length);
}, dH = Kd, pH = sH, hH = fH, Pg = function(e) {
  return function(t, n, r) {
    var i = dH(t), o = hH(i), a = pH(r, o), s;
    if (e && n != n) {
      for (; o > a; )
        if (s = i[a++], s != s) return !0;
    } else for (; o > a; a++)
      if ((e || a in i) && i[a] === n) return e || a || 0;
    return !e && -1;
  };
}, vH = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: Pg(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: Pg(!1)
}, Ou = $r, mH = Kd, gH = vH.indexOf, yH = Xd, CS = function(e, t) {
  var n = mH(e), r = 0, i = [], o;
  for (o in n) !Ou(yH, o) && Ou(n, o) && i.push(o);
  for (; t.length > r; ) Ou(n, o = t[r++]) && (~gH(i, o) || i.push(o));
  return i;
}, Zd = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], bH = CS, xH = Zd, wH = xH.concat("length", "prototype");
ES.f = Object.getOwnPropertyNames || function(t) {
  return bH(t, wH);
};
var $S = {};
$S.f = Object.getOwnPropertySymbols;
var SH = Xs, EH = ES, kH = $S, CH = ir, $H = SH("Reflect", "ownKeys") || function(t) {
  var n = EH.f(CH(t)), r = kH.f;
  return r ? n.concat(r(t)) : n;
}, TH = $r, OH = $H, IH = Hd, RH = Mo, PH = function(e, t) {
  for (var n = OH(t), r = RH.f, i = IH.f, o = 0; o < n.length; o++) {
    var a = n[o];
    TH(e, a) || r(e, a, i(t, a));
  }
}, AH = pn, DH = en, _H = /#|\.prototype\./, No = function(e, t) {
  var n = jH[MH(e)];
  return n == LH ? !0 : n == NH ? !1 : DH(t) ? AH(t) : !!t;
}, MH = No.normalize = function(e) {
  return String(e).replace(_H, ".").toLowerCase();
}, jH = No.data = {}, NH = No.NATIVE = "N", LH = No.POLYFILL = "P", FH = No, Iu = Kt, BH = Hd.f, zH = Js, WH = jo, UH = qd, HH = PH, VH = FH, KH = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, o, a, s, l, u, c;
  if (r ? a = Iu : i ? a = Iu[n] || UH(n, {}) : a = (Iu[n] || {}).prototype, a) for (s in t) {
    if (u = t[s], e.noTargetGet ? (c = BH(a, s), l = c && c.value) : l = a[s], o = VH(r ? s : n + (i ? "." : "#") + s, e.forced), !o && l !== void 0) {
      if (typeof u == typeof l) continue;
      HH(u, l);
    }
    (e.sham || l && l.sham) && zH(u, "sham", !0), WH(a, s, u, e);
  }
}, qH = _o, GH = qH("toStringTag"), TS = {};
TS[GH] = "z";
var ep = String(TS) === "[object z]", YH = ep, XH = en, Oa = Vd, JH = _o, QH = JH("toStringTag"), ZH = Oa(/* @__PURE__ */ function() {
  return arguments;
}()) == "Arguments", e9 = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, OS = YH ? Oa : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = e9(t = Object(e), QH)) == "string" ? n : ZH ? Oa(t) : (r = Oa(t)) == "Object" && XH(t.callee) ? "Arguments" : r;
}, t9 = OS, Zs = function(e) {
  if (t9(e) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
  return String(e);
}, n9 = ir, IS = function() {
  var e = n9(this), t = "";
  return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.sticky && (t += "y"), t;
}, tp = {}, RS = pn, r9 = Kt, PS = r9.RegExp;
tp.UNSUPPORTED_Y = RS(function() {
  var e = PS("a", "y");
  return e.lastIndex = 2, e.exec("abcd") != null;
});
tp.BROKEN_CARET = RS(function() {
  var e = PS("^r", "gy");
  return e.lastIndex = 2, e.exec("str") != null;
});
var i9 = CS, o9 = Zd, a9 = Object.keys || function(t) {
  return i9(t, o9);
}, s9 = Cr, l9 = Mo, u9 = ir, c9 = a9, f9 = s9 ? Object.defineProperties : function(t, n) {
  u9(t);
  for (var r = c9(n), i = r.length, o = 0, a; i > o; ) l9.f(t, a = r[o++], n[a]);
  return t;
}, d9 = Xs, p9 = d9("document", "documentElement"), h9 = ir, v9 = f9, Ag = Zd, m9 = Xd, g9 = p9, y9 = vS, b9 = bS, Dg = ">", _g = "<", Vc = "prototype", Kc = "script", AS = b9("IE_PROTO"), Ru = function() {
}, DS = function(e) {
  return _g + Kc + Dg + e + _g + "/" + Kc + Dg;
}, Mg = function(e) {
  e.write(DS("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, x9 = function() {
  var e = y9("iframe"), t = "java" + Kc + ":", n;
  return e.style.display = "none", g9.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(DS("document.F=Object")), n.close(), n.F;
}, da, Ia = function() {
  try {
    da = new ActiveXObject("htmlfile");
  } catch {
  }
  Ia = typeof document < "u" ? document.domain && da ? Mg(da) : x9() : Mg(da);
  for (var e = Ag.length; e--; ) delete Ia[Vc][Ag[e]];
  return Ia();
};
m9[AS] = !0;
var w9 = Object.create || function(t, n) {
  var r;
  return t !== null ? (Ru[Vc] = h9(t), r = new Ru(), Ru[Vc] = null, r[AS] = t) : r = Ia(), n === void 0 ? r : v9(r, n);
}, S9 = pn, E9 = Kt, k9 = E9.RegExp, C9 = S9(function() {
  var e = k9(".", "s");
  return !(e.dotAll && e.exec(`
`) && e.flags === "s");
}), $9 = pn, T9 = Kt, O9 = T9.RegExp, I9 = $9(function() {
  var e = O9("(?<a>b)", "g");
  return e.exec("b").groups.a !== "b" || "b".replace(e, "$<a>c") !== "bc";
}), R9 = Zs, P9 = IS, jg = tp, A9 = Yd, D9 = w9, _9 = xS.get, M9 = C9, j9 = I9, as = RegExp.prototype.exec, N9 = A9("native-string-replace", String.prototype.replace), qc = as, Gc = function() {
  var e = /a/, t = /b*/g;
  return as.call(e, "a"), as.call(t, "a"), e.lastIndex !== 0 || t.lastIndex !== 0;
}(), _S = jg.UNSUPPORTED_Y || jg.BROKEN_CARET, Yc = /()??/.exec("")[1] !== void 0, L9 = Gc || Yc || _S || M9 || j9;
L9 && (qc = function(t) {
  var n = this, r = _9(n), i = R9(t), o = r.raw, a, s, l, u, c, f, p;
  if (o)
    return o.lastIndex = n.lastIndex, a = qc.call(o, i), n.lastIndex = o.lastIndex, a;
  var d = r.groups, v = _S && n.sticky, h = P9.call(n), g = n.source, m = 0, b = i;
  if (v && (h = h.replace("y", ""), h.indexOf("g") === -1 && (h += "g"), b = i.slice(n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && i.charAt(n.lastIndex - 1) !== `
`) && (g = "(?: " + g + ")", b = " " + b, m++), s = new RegExp("^(?:" + g + ")", h)), Yc && (s = new RegExp("^" + g + "$(?!\\s)", h)), Gc && (l = n.lastIndex), u = as.call(v ? s : n, b), v ? u ? (u.input = u.input.slice(m), u[0] = u[0].slice(m), u.index = n.lastIndex, n.lastIndex += u[0].length) : n.lastIndex = 0 : Gc && u && (n.lastIndex = n.global ? u.index + u[0].length : l), Yc && u && u.length > 1 && N9.call(u[0], s, function() {
    for (c = 1; c < arguments.length - 2; c++)
      arguments[c] === void 0 && (u[c] = void 0);
  }), u && d)
    for (u.groups = f = D9(null), c = 0; c < d.length; c++)
      p = d[c], f[p[0]] = u[p[1]];
  return u;
});
var np = qc, F9 = KH, Ng = np;
F9({ target: "RegExp", proto: !0, forced: /./.exec !== Ng }, {
  exec: Ng
});
var Lg = jo, B9 = np, Fg = pn, MS = _o, z9 = Js, W9 = MS("species"), Pu = RegExp.prototype, U9 = function(e, t, n, r) {
  var i = MS(e), o = !Fg(function() {
    var u = {};
    return u[i] = function() {
      return 7;
    }, ""[e](u) != 7;
  }), a = o && !Fg(function() {
    var u = !1, c = /a/;
    return e === "split" && (c = {}, c.constructor = {}, c.constructor[W9] = function() {
      return c;
    }, c.flags = "", c[i] = /./[i]), c.exec = function() {
      return u = !0, null;
    }, c[i](""), !u;
  });
  if (!o || !a || n) {
    var s = /./[i], l = t(i, ""[e], function(u, c, f, p, d) {
      var v = c.exec;
      return v === B9 || v === Pu.exec ? o && !d ? { done: !0, value: s.call(c, f, p) } : { done: !0, value: u.call(f, c, p) } : { done: !1 };
    });
    Lg(String.prototype, e, l[0]), Lg(Pu, i, l[1]);
  }
  r && z9(Pu[i], "sham", !0);
}, H9 = Qs, V9 = Zs, K9 = Ys, Bg = function(e) {
  return function(t, n) {
    var r = V9(K9(t)), i = H9(n), o = r.length, a, s;
    return i < 0 || i >= o ? e ? "" : void 0 : (a = r.charCodeAt(i), a < 55296 || a > 56319 || i + 1 === o || (s = r.charCodeAt(i + 1)) < 56320 || s > 57343 ? e ? r.charAt(i) : a : e ? r.slice(i, i + 2) : (a - 55296 << 10) + (s - 56320) + 65536);
  };
}, q9 = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: Bg(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: Bg(!0)
}, G9 = q9.charAt, Y9 = function(e, t, n) {
  return t + (n ? G9(e, t).length : 1);
}, X9 = dS, J9 = Math.floor, Q9 = "".replace, Z9 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, eV = /\$([$&'`]|\d{1,2})/g, tV = function(e, t, n, r, i, o) {
  var a = n + e.length, s = r.length, l = eV;
  return i !== void 0 && (i = X9(i), l = Z9), Q9.call(o, l, function(u, c) {
    var f;
    switch (c.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return e;
      case "`":
        return t.slice(0, n);
      case "'":
        return t.slice(a);
      case "<":
        f = i[c.slice(1, -1)];
        break;
      default:
        var p = +c;
        if (p === 0) return u;
        if (p > s) {
          var d = J9(p / 10);
          return d === 0 ? u : d <= s ? r[d - 1] === void 0 ? c.charAt(1) : r[d - 1] + c.charAt(1) : u;
        }
        f = r[p - 1];
    }
    return f === void 0 ? "" : f;
  });
}, nV = ir, rV = en, iV = Vd, oV = np, aV = function(e, t) {
  var n = e.exec;
  if (rV(n)) {
    var r = n.call(e, t);
    return r !== null && nV(r), r;
  }
  if (iV(e) === "RegExp") return oV.call(e, t);
  throw TypeError("RegExp#exec called on incompatible receiver");
}, sV = U9, lV = pn, uV = ir, cV = en, fV = Qs, dV = kS, _r = Zs, pV = Ys, hV = Y9, vV = cS, mV = tV, gV = aV, yV = _o, Xc = yV("replace"), bV = Math.max, xV = Math.min, wV = function(e) {
  return e === void 0 ? e : String(e);
}, SV = function() {
  return "a".replace(/./, "$0") === "$0";
}(), zg = function() {
  return /./[Xc] ? /./[Xc]("a", "$0") === "" : !1;
}(), EV = !lV(function() {
  var e = /./;
  return e.exec = function() {
    var t = [];
    return t.groups = { a: "7" }, t;
  }, "".replace(e, "$<a>") !== "7";
});
sV("replace", function(e, t, n) {
  var r = zg ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(o, a) {
      var s = pV(this), l = o == null ? void 0 : vV(o, Xc);
      return l ? l.call(o, s, a) : t.call(_r(s), o, a);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(i, o) {
      var a = uV(this), s = _r(i);
      if (typeof o == "string" && o.indexOf(r) === -1 && o.indexOf("$<") === -1) {
        var l = n(t, a, s, o);
        if (l.done) return l.value;
      }
      var u = cV(o);
      u || (o = _r(o));
      var c = a.global;
      if (c) {
        var f = a.unicode;
        a.lastIndex = 0;
      }
      for (var p = []; ; ) {
        var d = gV(a, s);
        if (d === null || (p.push(d), !c)) break;
        var v = _r(d[0]);
        v === "" && (a.lastIndex = hV(s, dV(a.lastIndex), f));
      }
      for (var h = "", g = 0, m = 0; m < p.length; m++) {
        d = p[m];
        for (var b = _r(d[0]), w = bV(xV(fV(d.index), s.length), 0), C = [], S = 1; S < d.length; S++) C.push(wV(d[S]));
        var E = d.groups;
        if (u) {
          var I = [b].concat(C, w, s);
          E !== void 0 && I.push(E);
          var N = _r(o.apply(void 0, I));
        } else
          N = mV(b, s, w, C, E, o);
        w >= g && (h += s.slice(g, w) + N, g = w + b.length);
      }
      return h + s.slice(g);
    }
  ];
}, !EV || !SV || zg);
var Ni = ft, kV = ud, CV = Sr, pa = function(e) {
  return kV.slice(0, e.length) === e;
}, $V = function() {
  return pa("Bun/") ? "BUN" : pa("Cloudflare-Workers") ? "CLOUDFLARE" : pa("Deno/") ? "DENO" : pa("Node.js/") ? "NODE" : Ni.Bun && typeof Bun.version == "string" ? "BUN" : Ni.Deno && typeof Deno.version == "object" ? "DENO" : CV(Ni.process) === "process" ? "NODE" : Ni.window && Ni.document ? "BROWSER" : "REST";
}(), TV = TypeError, OV = function(e, t) {
  if (e < t) throw new TV("Not enough arguments");
  return e;
}, jS = ft, IV = id, RV = Rt, PV = $V, AV = ud, DV = Bs, _V = OV, MV = jS.Function, jV = /MSIE .\./.test(AV) || PV === "BUN" && function() {
  var e = jS.Bun.version.split(".");
  return e.length < 3 || e[0] === "0" && (e[1] < 3 || e[1] === "3" && e[2] === "0");
}(), NS = function(e, t) {
  var n = t ? 2 : 1;
  return jV ? function(r, i) {
    var o = _V(arguments.length, 1) > n, a = RV(r) ? r : MV(r), s = o ? DV(arguments, n) : [], l = o ? function() {
      IV(a, this, s);
    } : a;
    return t ? e(l, i) : e(l);
  } : e;
}, NV = Be, LS = ft, LV = NS, Wg = LV(LS.setInterval, !0);
NV({ global: !0, bind: !0, forced: LS.setInterval !== Wg }, {
  setInterval: Wg
});
var FV = Be, FS = ft, BV = NS, Ug = BV(FS.setTimeout, !0);
FV({ global: !0, bind: !0, forced: FS.setTimeout !== Ug }, {
  setTimeout: Ug
});
var zV = wt, WV = zV.setInterval, UV = WV;
const HV = /* @__PURE__ */ $e(UV);
var VV = dt, BS = function(e, t) {
  var n = [][e];
  return !!n && VV(function() {
    n.call(null, t || function() {
      return 1;
    }, 1);
  });
}, KV = Be, qV = od, GV = Zw.indexOf, YV = BS, Jc = qV([].indexOf), zS = !!Jc && 1 / Jc([1], 1, -0) < 0, XV = zS || !YV("indexOf");
KV({ target: "Array", proto: !0, forced: XV }, {
  indexOf: function(t) {
    var n = arguments.length > 1 ? arguments[1] : void 0;
    return zS ? Jc(this, t, n) || 0 : GV(this, t, n);
  }
});
var JV = kr, QV = JV("Array", "indexOf"), ZV = Fn, e7 = QV, Au = Array.prototype, t7 = function(e) {
  var t = e.indexOf;
  return e === Au || ZV(Au, e) && t === Au.indexOf ? e7 : t;
}, n7 = t7, r7 = n7, i7 = r7;
const o7 = /* @__PURE__ */ $e(i7);
var Hg = As, a7 = TypeError, s7 = function(e, t) {
  if (!delete e[t]) throw new a7("Cannot delete property " + Hg(t) + " of " + Hg(e));
}, l7 = Be, u7 = Bn, c7 = Sd, f7 = _s, d7 = Er, p7 = q1, h7 = gd, v7 = wd, m7 = $o, Du = s7, g7 = Ms, y7 = g7("splice"), b7 = Math.max, x7 = Math.min;
l7({ target: "Array", proto: !0, forced: !y7 }, {
  splice: function(t, n) {
    var r = u7(this), i = d7(r), o = c7(t, i), a = arguments.length, s, l, u, c, f, p;
    for (a === 0 ? s = l = 0 : a === 1 ? (s = 0, l = i - o) : (s = a - 2, l = x7(b7(f7(n), 0), i - o)), h7(i + s - l), u = v7(r, l), c = 0; c < l; c++)
      f = o + c, f in r && m7(u, c, r[f]);
    if (u.length = l, s < l) {
      for (c = o; c < i - l; c++)
        f = c + l, p = c + s, f in r ? r[p] = r[f] : Du(r, p);
      for (c = i; c > i - l + s; c--) Du(r, c - 1);
    } else if (s > l)
      for (c = i - l; c > o; c--)
        f = c + l - 1, p = c + s - 1, f in r ? r[p] = r[f] : Du(r, p);
    for (c = 0; c < s; c++)
      r[c + o] = arguments[c + 2];
    return p7(r, i - l + s), u;
  }
});
var w7 = kr, S7 = w7("Array", "splice"), E7 = Fn, k7 = S7, _u = Array.prototype, C7 = function(e) {
  var t = e.splice;
  return e === _u || E7(_u, e) && t === _u.splice ? k7 : t;
}, $7 = C7, T7 = $7, O7 = T7;
const I7 = /* @__PURE__ */ $e(O7);
var R7 = kr, P7 = R7("Array", "concat"), A7 = Fn, D7 = P7, Mu = Array.prototype, _7 = function(e) {
  var t = e.concat;
  return e === Mu || A7(Mu, e) && t === Mu.concat ? D7 : t;
}, M7 = _7, j7 = M7, N7 = j7;
const Xe = /* @__PURE__ */ $e(N7);
var L7 = Be, F7 = pt, WS = Date, B7 = F7(WS.prototype.getTime);
L7({ target: "Date", stat: !0 }, {
  now: function() {
    return B7(new WS());
  }
});
var z7 = wt, W7 = z7.Date.now, U7 = W7, H7 = U7, V7 = H7;
const Jn = /* @__PURE__ */ $e(V7);
var K7 = Td.forEach, q7 = BS, G7 = q7("forEach"), Y7 = G7 ? [].forEach : function(t) {
  return K7(this, t, arguments.length > 1 ? arguments[1] : void 0);
}, X7 = Be, Vg = Y7;
X7({ target: "Array", proto: !0, forced: [].forEach !== Vg }, {
  forEach: Vg
});
var J7 = kr, Q7 = J7("Array", "forEach"), Z7 = Q7, e8 = Z7, t8 = To, n8 = Vt, r8 = Fn, i8 = e8, ju = Array.prototype, o8 = {
  DOMTokenList: !0,
  NodeList: !0
}, a8 = function(e) {
  var t = e.forEach;
  return e === ju || r8(ju, e) && t === ju.forEach || n8(o8, t8(e)) ? i8 : t;
}, s8 = a8;
const ss = /* @__PURE__ */ $e(s8);
var l8 = Be, u8 = Bn, US = kd, c8 = dt, f8 = c8(function() {
  US(1);
});
l8({ target: "Object", stat: !0, forced: f8 }, {
  keys: function(t) {
    return US(u8(t));
  }
});
var d8 = wt, p8 = d8.Object.keys, h8 = p8, v8 = h8, m8 = v8;
const g8 = /* @__PURE__ */ $e(m8);
var y8 = wt, b8 = y8.Object.getOwnPropertySymbols, x8 = b8, w8 = x8, S8 = w8;
const Kg = /* @__PURE__ */ $e(S8);
var E8 = Be, k8 = Td.filter, C8 = Ms, $8 = C8("filter");
E8({ target: "Array", proto: !0, forced: !$8 }, {
  filter: function(t) {
    return k8(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var T8 = kr, O8 = T8("Array", "filter"), I8 = Fn, R8 = O8, Nu = Array.prototype, P8 = function(e) {
  var t = e.filter;
  return e === Nu || I8(Nu, e) && t === Nu.filter ? R8 : t;
}, A8 = P8, D8 = A8, _8 = D8;
const M8 = /* @__PURE__ */ $e(_8);
var HS = { exports: {} }, j8 = Be, N8 = dt, L8 = Tn, VS = So.f, KS = Bt, F8 = !KS || N8(function() {
  VS(1);
});
j8({ target: "Object", stat: !0, forced: F8, sham: !KS }, {
  getOwnPropertyDescriptor: function(t, n) {
    return VS(L8(t), n);
  }
});
var B8 = wt, qS = B8.Object, z8 = HS.exports = function(t, n) {
  return qS.getOwnPropertyDescriptor(t, n);
};
qS.getOwnPropertyDescriptor.sham && (z8.sham = !0);
var W8 = HS.exports, U8 = W8, H8 = U8, V8 = H8;
const GS = /* @__PURE__ */ $e(V8);
var K8 = On, q8 = pt, G8 = Fs, Y8 = zs, X8 = rr, J8 = q8([].concat), Q8 = K8("Reflect", "ownKeys") || function(t) {
  var n = G8.f(X8(t)), r = Y8.f;
  return r ? J8(n, r(t)) : n;
}, Z8 = Be, eK = Bt, tK = Q8, nK = Tn, rK = So, iK = $o;
Z8({ target: "Object", stat: !0, sham: !eK }, {
  getOwnPropertyDescriptors: function(t) {
    for (var n = nK(t), r = rK.f, i = tK(n), o = {}, a = 0, s, l; i.length > a; )
      l = r(n, s = i[a++]), l !== void 0 && iK(o, s, l);
    return o;
  }
});
var oK = wt, aK = oK.Object.getOwnPropertyDescriptors, sK = aK, lK = sK, uK = lK;
const qg = /* @__PURE__ */ $e(uK);
var YS = { exports: {} }, cK = Be, fK = Bt, Gg = js.f;
cK({ target: "Object", stat: !0, forced: Object.defineProperties !== Gg, sham: !fK }, {
  defineProperties: Gg
});
var dK = wt, XS = dK.Object, pK = YS.exports = function(t, n) {
  return XS.defineProperties(t, n);
};
XS.defineProperties.sham && (pK.sham = !0);
var hK = YS.exports, vK = hK, mK = vK, gK = mK;
const yK = /* @__PURE__ */ $e(gK);
var bK = tS;
const xK = /* @__PURE__ */ $e(bK);
var wK = !1;
function SK(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function EK(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var kK = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !wK : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(EK(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = SK(i);
      try {
        o.insertRule(r, o.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Ct = "-ms-", ls = "-moz-", Pe = "-webkit-", JS = "comm", rp = "rule", ip = "decl", CK = "@import", QS = "@keyframes", $K = "@layer", TK = Math.abs, el = String.fromCharCode, OK = Object.assign;
function IK(e, t) {
  return xt(e, 0) ^ 45 ? (((t << 2 ^ xt(e, 0)) << 2 ^ xt(e, 1)) << 2 ^ xt(e, 2)) << 2 ^ xt(e, 3) : 0;
}
function ZS(e) {
  return e.trim();
}
function RK(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function Ae(e, t, n) {
  return e.replace(t, n);
}
function Qc(e, t) {
  return e.indexOf(t);
}
function xt(e, t) {
  return e.charCodeAt(t) | 0;
}
function lo(e, t, n) {
  return e.slice(t, n);
}
function xn(e) {
  return e.length;
}
function op(e) {
  return e.length;
}
function ha(e, t) {
  return t.push(e), e;
}
function PK(e, t) {
  return e.map(t).join("");
}
var tl = 1, ui = 1, e0 = 0, Ft = 0, lt = 0, Si = "";
function nl(e, t, n, r, i, o, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: o, line: tl, column: ui, length: a, return: "" };
}
function Li(e, t) {
  return OK(nl("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function AK() {
  return lt;
}
function DK() {
  return lt = Ft > 0 ? xt(Si, --Ft) : 0, ui--, lt === 10 && (ui = 1, tl--), lt;
}
function Ht() {
  return lt = Ft < e0 ? xt(Si, Ft++) : 0, ui++, lt === 10 && (ui = 1, tl++), lt;
}
function Sn() {
  return xt(Si, Ft);
}
function Ra() {
  return Ft;
}
function Lo(e, t) {
  return lo(Si, e, t);
}
function uo(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function t0(e) {
  return tl = ui = 1, e0 = xn(Si = e), Ft = 0, [];
}
function n0(e) {
  return Si = "", e;
}
function Pa(e) {
  return ZS(Lo(Ft - 1, Zc(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function _K(e) {
  for (; (lt = Sn()) && lt < 33; )
    Ht();
  return uo(e) > 2 || uo(lt) > 3 ? "" : " ";
}
function MK(e, t) {
  for (; --t && Ht() && !(lt < 48 || lt > 102 || lt > 57 && lt < 65 || lt > 70 && lt < 97); )
    ;
  return Lo(e, Ra() + (t < 6 && Sn() == 32 && Ht() == 32));
}
function Zc(e) {
  for (; Ht(); )
    switch (lt) {
      case e:
        return Ft;
      case 34:
      case 39:
        e !== 34 && e !== 39 && Zc(lt);
        break;
      case 40:
        e === 41 && Zc(e);
        break;
      case 92:
        Ht();
        break;
    }
  return Ft;
}
function jK(e, t) {
  for (; Ht() && e + lt !== 57; )
    if (e + lt === 84 && Sn() === 47)
      break;
  return "/*" + Lo(t, Ft - 1) + "*" + el(e === 47 ? e : Ht());
}
function NK(e) {
  for (; !uo(Sn()); )
    Ht();
  return Lo(e, Ft);
}
function LK(e) {
  return n0(Aa("", null, null, null, [""], e = t0(e), 0, [0], e));
}
function Aa(e, t, n, r, i, o, a, s, l) {
  for (var u = 0, c = 0, f = a, p = 0, d = 0, v = 0, h = 1, g = 1, m = 1, b = 0, w = "", C = i, S = o, E = r, I = w; g; )
    switch (v = b, b = Ht()) {
      case 40:
        if (v != 108 && xt(I, f - 1) == 58) {
          Qc(I += Ae(Pa(b), "&", "&\f"), "&\f") != -1 && (m = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        I += Pa(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        I += _K(v);
        break;
      case 92:
        I += MK(Ra() - 1, 7);
        continue;
      case 47:
        switch (Sn()) {
          case 42:
          case 47:
            ha(FK(jK(Ht(), Ra()), t, n), l);
            break;
          default:
            I += "/";
        }
        break;
      case 123 * h:
        s[u++] = xn(I) * m;
      case 125 * h:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            g = 0;
          case 59 + c:
            m == -1 && (I = Ae(I, /\f/g, "")), d > 0 && xn(I) - f && ha(d > 32 ? Xg(I + ";", r, n, f - 1) : Xg(Ae(I, " ", "") + ";", r, n, f - 2), l);
            break;
          case 59:
            I += ";";
          default:
            if (ha(E = Yg(I, t, n, u, c, i, s, w, C = [], S = [], f), o), b === 123)
              if (c === 0)
                Aa(I, t, E, E, C, o, f, s, S);
              else
                switch (p === 99 && xt(I, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Aa(e, E, E, r && ha(Yg(e, E, E, 0, 0, i, s, w, i, C = [], f), S), i, S, f, s, r ? C : S);
                    break;
                  default:
                    Aa(I, E, E, E, [""], S, 0, s, S);
                }
        }
        u = c = d = 0, h = m = 1, w = I = "", f = a;
        break;
      case 58:
        f = 1 + xn(I), d = v;
      default:
        if (h < 1) {
          if (b == 123)
            --h;
          else if (b == 125 && h++ == 0 && DK() == 125)
            continue;
        }
        switch (I += el(b), b * h) {
          case 38:
            m = c > 0 ? 1 : (I += "\f", -1);
            break;
          case 44:
            s[u++] = (xn(I) - 1) * m, m = 1;
            break;
          case 64:
            Sn() === 45 && (I += Pa(Ht())), p = Sn(), c = f = xn(w = I += NK(Ra())), b++;
            break;
          case 45:
            v === 45 && xn(I) == 2 && (h = 0);
        }
    }
  return o;
}
function Yg(e, t, n, r, i, o, a, s, l, u, c) {
  for (var f = i - 1, p = i === 0 ? o : [""], d = op(p), v = 0, h = 0, g = 0; v < r; ++v)
    for (var m = 0, b = lo(e, f + 1, f = TK(h = a[v])), w = e; m < d; ++m)
      (w = ZS(h > 0 ? p[m] + " " + b : Ae(b, /&\f/g, p[m]))) && (l[g++] = w);
  return nl(e, t, n, i === 0 ? rp : s, l, u, c);
}
function FK(e, t, n) {
  return nl(e, t, n, JS, el(AK()), lo(e, 2, -2), 0);
}
function Xg(e, t, n, r) {
  return nl(e, t, n, ip, lo(e, 0, r), lo(e, r + 1, -1), r);
}
function Yr(e, t) {
  for (var n = "", r = op(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function BK(e, t, n, r) {
  switch (e.type) {
    case $K:
      if (e.children.length) break;
    case CK:
    case ip:
      return e.return = e.return || e.value;
    case JS:
      return "";
    case QS:
      return e.return = e.value + "{" + Yr(e.children, r) + "}";
    case rp:
      e.value = e.props.join(",");
  }
  return xn(n = Yr(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function zK(e) {
  var t = op(e);
  return function(n, r, i, o) {
    for (var a = "", s = 0; s < t; s++)
      a += e[s](n, r, i, o) || "";
    return a;
  };
}
function WK(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function UK(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var HK = function(t, n, r) {
  for (var i = 0, o = 0; i = o, o = Sn(), i === 38 && o === 12 && (n[r] = 1), !uo(o); )
    Ht();
  return Lo(t, Ft);
}, VK = function(t, n) {
  var r = -1, i = 44;
  do
    switch (uo(i)) {
      case 0:
        i === 38 && Sn() === 12 && (n[r] = 1), t[r] += HK(Ft - 1, n, r);
        break;
      case 2:
        t[r] += Pa(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = Sn() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      default:
        t[r] += el(i);
    }
  while (i = Ht());
  return t;
}, KK = function(t, n) {
  return n0(VK(t0(t), n));
}, Jg = /* @__PURE__ */ new WeakMap(), qK = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Jg.get(r)) && !i) {
      Jg.set(t, !0);
      for (var o = [], a = KK(n, o), s = r.props, l = 0, u = 0; l < a.length; l++)
        for (var c = 0; c < s.length; c++, u++)
          t.props[u] = o[l] ? a[l].replace(/&\f/g, s[c]) : s[c] + " " + a[l];
    }
  }
}, GK = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function r0(e, t) {
  switch (IK(e, t)) {
    case 5103:
      return Pe + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Pe + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Pe + e + ls + e + Ct + e + e;
    case 6828:
    case 4268:
      return Pe + e + Ct + e + e;
    case 6165:
      return Pe + e + Ct + "flex-" + e + e;
    case 5187:
      return Pe + e + Ae(e, /(\w+).+(:[^]+)/, Pe + "box-$1$2" + Ct + "flex-$1$2") + e;
    case 5443:
      return Pe + e + Ct + "flex-item-" + Ae(e, /flex-|-self/, "") + e;
    case 4675:
      return Pe + e + Ct + "flex-line-pack" + Ae(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return Pe + e + Ct + Ae(e, "shrink", "negative") + e;
    case 5292:
      return Pe + e + Ct + Ae(e, "basis", "preferred-size") + e;
    case 6060:
      return Pe + "box-" + Ae(e, "-grow", "") + Pe + e + Ct + Ae(e, "grow", "positive") + e;
    case 4554:
      return Pe + Ae(e, /([^-])(transform)/g, "$1" + Pe + "$2") + e;
    case 6187:
      return Ae(Ae(Ae(e, /(zoom-|grab)/, Pe + "$1"), /(image-set)/, Pe + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return Ae(e, /(image-set\([^]*)/, Pe + "$1$`$1");
    case 4968:
      return Ae(Ae(e, /(.+:)(flex-)?(.*)/, Pe + "box-pack:$3" + Ct + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Pe + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Ae(e, /(.+)-inline(.+)/, Pe + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (xn(e) - 1 - t > 6) switch (xt(e, t + 1)) {
        case 109:
          if (xt(e, t + 4) !== 45) break;
        case 102:
          return Ae(e, /(.+:)(.+)-([^]+)/, "$1" + Pe + "$2-$3$1" + ls + (xt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~Qc(e, "stretch") ? r0(Ae(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    case 4949:
      if (xt(e, t + 1) !== 115) break;
    case 6444:
      switch (xt(e, xn(e) - 3 - (~Qc(e, "!important") && 10))) {
        case 107:
          return Ae(e, ":", ":" + Pe) + e;
        case 101:
          return Ae(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Pe + (xt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Pe + "$2$3$1" + Ct + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (xt(e, t + 11)) {
        case 114:
          return Pe + e + Ct + Ae(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return Pe + e + Ct + Ae(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return Pe + e + Ct + Ae(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return Pe + e + Ct + e + e;
  }
  return e;
}
var YK = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case ip:
      t.return = r0(t.value, t.length);
      break;
    case QS:
      return Yr([Li(t, {
        value: Ae(t.value, "@", "@" + Pe)
      })], i);
    case rp:
      if (t.length) return PK(t.props, function(o) {
        switch (RK(o, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return Yr([Li(t, {
              props: [Ae(o, /:(read-\w+)/, ":" + ls + "$1")]
            })], i);
          case "::placeholder":
            return Yr([Li(t, {
              props: [Ae(o, /:(plac\w+)/, ":" + Pe + "input-$1")]
            }), Li(t, {
              props: [Ae(o, /:(plac\w+)/, ":" + ls + "$1")]
            }), Li(t, {
              props: [Ae(o, /:(plac\w+)/, Ct + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, XK = [YK], JK = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(h) {
      var g = h.getAttribute("data-emotion");
      g.indexOf(" ") !== -1 && (document.head.appendChild(h), h.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || XK, o = {}, a, s = [];
  a = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(h) {
      for (var g = h.getAttribute("data-emotion").split(" "), m = 1; m < g.length; m++)
        o[g[m]] = !0;
      s.push(h);
    }
  );
  var l, u = [qK, GK];
  {
    var c, f = [BK, WK(function(h) {
      c.insert(h);
    })], p = zK(u.concat(i, f)), d = function(g) {
      return Yr(LK(g), p);
    };
    l = function(g, m, b, w) {
      c = b, d(g ? g + "{" + m.styles + "}" : m.styles), w && (v.inserted[m.name] = !0);
    };
  }
  var v = {
    key: n,
    sheet: new kK({
      key: n,
      container: a,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: l
  };
  return v.sheet.hydrate(s), v;
};
function QK(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var ZK = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, eq = !1, tq = /[A-Z]|^ms/g, nq = /_EMO_([^_]+?)_([^]*?)_EMO_/g, i0 = function(t) {
  return t.charCodeAt(1) === 45;
}, Qg = function(t) {
  return t != null && typeof t != "boolean";
}, Lu = /* @__PURE__ */ UK(function(e) {
  return i0(e) ? e : e.replace(tq, "-$&").toLowerCase();
}), Zg = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(nq, function(r, i, o) {
          return Kn = {
            name: i,
            styles: o,
            next: Kn
          }, i;
        });
  }
  return ZK[t] !== 1 && !i0(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
}, rq = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function us(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return Kn = {
          name: i.name,
          styles: i.styles,
          next: Kn
        }, i.name;
      var o = n;
      if (o.styles !== void 0) {
        var a = o.next;
        if (a !== void 0)
          for (; a !== void 0; )
            Kn = {
              name: a.name,
              styles: a.styles,
              next: Kn
            }, a = a.next;
        var s = o.styles + ";";
        return s;
      }
      return iq(e, t, n);
    }
  }
  var l = n;
  if (t == null)
    return l;
  var u = t[l];
  return u !== void 0 ? u : l;
}
function iq(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += us(e, t, n[i]) + ";";
  else
    for (var o in n) {
      var a = n[o];
      if (typeof a != "object") {
        var s = a;
        t != null && t[s] !== void 0 ? r += o + "{" + t[s] + "}" : Qg(s) && (r += Lu(o) + ":" + Zg(o, s) + ";");
      } else {
        if (o === "NO_COMPONENT_SELECTOR" && eq)
          throw new Error(rq);
        if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
          for (var l = 0; l < a.length; l++)
            Qg(a[l]) && (r += Lu(o) + ":" + Zg(o, a[l]) + ";");
        else {
          var u = us(e, t, a);
          switch (o) {
            case "animation":
            case "animationName": {
              r += Lu(o) + ":" + u + ";";
              break;
            }
            default:
              r += o + "{" + u + "}";
          }
        }
      }
    }
  return r;
}
var ey = /label:\s*([^\s;{]+)\s*(;|$)/g, Kn;
function Fu(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  Kn = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    r = !1, i += us(n, t, o);
  else {
    var a = o;
    i += a[0];
  }
  for (var s = 1; s < e.length; s++)
    if (i += us(n, t, e[s]), r) {
      var l = o;
      i += l[s];
    }
  ey.lastIndex = 0;
  for (var u = "", c; (c = ey.exec(i)) !== null; )
    u += "-" + c[1];
  var f = QK(i) + u;
  return {
    name: f,
    styles: i,
    next: Kn
  };
}
function o0(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var oq = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, aq = function(t, n, r) {
  oq(t, n);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + i : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function ty(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function ny(e, t, n) {
  var r = [], i = o0(e, r, n);
  return r.length < 2 ? n : i + t(r);
}
var sq = function(t) {
  var n = JK(t);
  n.sheet.speedy = function(s) {
    if (process.env.NODE_ENV !== "production" && this.ctr !== 0)
      throw new Error("speedy must be changed before any rules are inserted");
    this.isSpeedy = s;
  }, n.compat = !0;
  var r = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = Fu(u, n.registered, void 0);
    return aq(n, f), n.key + "-" + f.name;
  }, i = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = Fu(u, n.registered), p = "animation-" + f.name;
    return ty(n, {
      name: f.name,
      styles: "@keyframes " + p + "{" + f.styles + "}"
    }), p;
  }, o = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = Fu(u, n.registered);
    ty(n, f);
  }, a = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    return ny(n.registered, r, lq(u));
  };
  return {
    css: r,
    cx: a,
    injectGlobal: o,
    keyframes: i,
    hydrate: function(l) {
      l.forEach(function(u) {
        n.inserted[u] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    // $FlowFixMe
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: o0.bind(null, n.registered),
    merge: ny.bind(null, n.registered, r)
  };
}, lq = function e(t) {
  for (var n = "", r = 0; r < t.length; r++) {
    var i = t[r];
    if (i != null) {
      var o = void 0;
      switch (typeof i) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(i))
            o = e(i);
          else {
            o = "";
            for (var a in i)
              i[a] && a && (o && (o += " "), o += a);
          }
          break;
        }
        default:
          o = i;
      }
      o && (n && (n += " "), n += o);
    }
  }
  return n;
}, uq = jo, ap = Date.prototype, ry = "Invalid Date", a0 = "toString", cq = ap[a0], fq = ap.getTime;
String(/* @__PURE__ */ new Date(NaN)) != ry && uq(ap, a0, function() {
  var t = fq.call(this);
  return t === t ? cq.call(this) : ry;
});
var dq = ep, pq = OS, hq = dq ? {}.toString : function() {
  return "[object " + pq(this) + "]";
}, vq = ep, mq = jo, gq = hq;
vq || mq(Object.prototype, "toString", gq, { unsafe: !0 });
var yq = Qd.PROPER, bq = jo, xq = ir, iy = Zs, wq = pn, Sq = IS, sp = "toString", s0 = RegExp.prototype, l0 = s0[sp], Eq = wq(function() {
  return l0.call({ source: "a", flags: "b" }) != "/a/b";
}), kq = yq && l0.name != sp;
(Eq || kq) && bq(RegExp.prototype, sp, function() {
  var t = xq(this), n = iy(t.source), r = t.flags, i = iy(r === void 0 && t instanceof RegExp && !("flags" in s0) ? Sq.call(t) : r);
  return "/" + n + "/" + i;
}, { unsafe: !0 });
var oy = typeof window < "u" ? window : self, Cq = oy.crypto || oy.msCrypto, $q = function(e) {
  if (!e) return Math.random;
  var t = Math.pow(2, 32), n = new Uint32Array(1);
  return function() {
    return e.getRandomValues(n)[0] / t;
  };
}(Cq);
const Tq = /* @__PURE__ */ $e($q);
function Oq() {
  return Tq().toString(26).substr(2, 5).replace(/[0-9]/g, function(e) {
    return String.fromCharCode(e.charCodeAt(0) + 65);
  });
}
var Iq = Vw;
const ay = /* @__PURE__ */ $e(Iq);
function je(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "white", n = "background-color: ".concat(e, "; border-radius: 4px; padding: 2px 4px;");
  return t && (n += " color: ".concat(t, ";")), [n, ""];
}
function sy(e, t) {
  for (var n, r, i = arguments.length, o = new Array(i > 2 ? i - 2 : 0), a = 2; a < i; a++)
    o[a - 2] = arguments[a];
  return Xe(n = [Xe(r = "%c".concat(e, "%c ")).call(r, t)]).call(n, ke(je("green", "white")), o);
}
function Rq(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.force, r = n === void 0 ? !1 : n;
  return r ? function() {
    for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    if (o.length) {
      var s = o, l = bn(s, 1), u = l[0];
      typeof u == "function" && (o = u());
      var c = ay(o[0]) ? o : [o], f = c.length === 1;
      ss(c).call(c, function(p, d) {
        if (f) {
          var v, h;
          (v = console).log.apply(v, ke(sy.apply(void 0, Xe(h = [e]).call(h, ke(p)))));
        } else if (d) {
          var g;
          (g = console).log.apply(g, ke(ay(p) ? p : [p]));
        } else {
          var m, b;
          (m = console).groupCollapsed.apply(m, ke(sy.apply(void 0, Xe(b = [e]).call(b, ke(p)))));
        }
      }), f || console.groupEnd();
    }
  } : function() {
    return 0;
  };
}
var Pq = Cr, Aq = Qd.EXISTS, Dq = Mo.f, u0 = Function.prototype, _q = u0.toString, Mq = /^\s*function ([^ (]*)/, jq = "name";
Pq && !Aq && Dq(u0, jq, {
  configurable: !0,
  get: function() {
    try {
      return _q.call(this).match(Mq)[1];
    } catch {
      return "";
    }
  }
});
var Nq = wt, Lq = Nq.setTimeout, Fq = Lq;
const Bq = /* @__PURE__ */ $e(Fq);
function zq(e, t) {
  if (!t)
    return e;
  var n = 0, r = null;
  return function() {
    for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    var s = Jn();
    s - n > t ? (e.apply(void 0, o), n = s) : (clearTimeout(r), r = Bq(function() {
      e.apply(void 0, o), n = Jn();
    }, Math.max(0, t - s + n)));
  };
}
var c0 = function(t) {
  var n = t.debounce, r = t.name, i = t.onEvent, o = t.target, a = Ke();
  a.current = i;
  var s = st(function() {
    return zq(function(u) {
      var c = a.current;
      c && c(u);
    }, n);
  }, [n, a]), l = Oe(function(u) {
    u.timeStampLow = Jn(), s(u);
  }, [s]);
  return fi(function() {
    return o.addEventListener(r, l, {
      passive: !0
    }), l({
      target: o,
      type: r
    }), function() {
      return o.removeEventListener(r, l);
    };
  }, [r, l, o]), !1;
};
c0.defaultProps = {
  debounce: 200
};
var Wq = Math.sign || function(t) {
  var n = +t;
  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
}, Uq = Be, Hq = Wq;
Uq({ target: "Math", stat: !0 }, {
  sign: Hq
});
var Vq = wt, Kq = Vq.Math.sign, qq = Kq, Gq = qq, Yq = Gq;
const Xq = /* @__PURE__ */ $e(Yq);
function Jq(e, t) {
  var n = Xq(t - e), r = Math.sqrt(Math.abs(t - e)), i = e + r * n;
  return n > 0 ? Math.min(t, i) : Math.max(t, i);
}
function Qq(e, t, n, r) {
  for (var i = e, o = 0; o < r; o++)
    i = n(i, t);
  return i;
}
var f0 = function(t) {
  var n = t.name, r = t.onEnd, i = t.target, o = t.value, a = Ke(), s = Oe(function(u, c, f, p) {
    var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Jn();
    (f === "100%" || typeof f == "number") && (cancelAnimationFrame(a.current), a.current = requestAnimationFrame(function() {
      if (i) {
        var v = f === "100%" ? i.scrollHeight - i.offsetHeight : f, h = Qq(c, v, Jq, (Jn() - d) / 5);
        Math.abs(v - h) < 1.5 && (h = v), i[u] = h, v === h ? r && r(!0) : s(u, c, f, p + 1, d);
      }
    }));
  }, [a, r, i]), l = Oe(function() {
    cancelAnimationFrame(a.current), r && r(!1);
  }, [r]);
  return fi(function() {
    return s(n, i[n], o, 1), i ? (i.addEventListener("pointerdown", l, {
      passive: !0
    }), i.addEventListener("wheel", l, {
      passive: !0
    }), function() {
      i.removeEventListener("pointerdown", l), i.removeEventListener("wheel", l), cancelAnimationFrame(a.current);
    }) : function() {
      return cancelAnimationFrame(a.current);
    };
  }, [s, a, l, n, i, o]), !1;
};
f0.propTypes = {
  name: Te.string.isRequired,
  onEnd: Te.func,
  target: Te.any.isRequired,
  value: Te.oneOfType([Te.number, Te.oneOf(["100%"])]).isRequired
};
function Bu(e) {
  var t = ge(e), n = bn(t, 2), r = n[0], i = n[1], o = Ke(), a = Oe(function(s) {
    typeof s == "function" ? a(function(l) {
      return s = s(l), o.current = s, s;
    }) : (o.current = s, a(s));
  }, [o]);
  return o.current = r, [r, i, o];
}
function ly(e, t) {
  var n = g8(e);
  if (Kg) {
    var r = Kg(e);
    t && (r = M8(r).call(r, function(i) {
      return GS(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    if (t % 2) {
      var r;
      ss(r = ly(Object(n), !0)).call(r, function(o) {
        c6(e, o, n[o]);
      });
    } else if (qg)
      yK(e, qg(n));
    else {
      var i;
      ss(i = ly(Object(n))).call(i, function(o) {
        xK(e, o, GS(n, o));
      });
    }
  }
  return e;
}
var Zq = function() {
  return 1 / 0;
}, cy = 17, eG = "bottom", nn = "top", fy = 1, tG = 34, dy = {};
function nG(e, t) {
  return e(), HV(e, t);
}
function py(e) {
  var t = e.mode, n = e.target, r = n.offsetHeight, i = n.scrollHeight, o = n.scrollTop, a = i - o - r < fy, s = o < fy, l = t === nn ? s : a, u = t !== nn ? s : a;
  return {
    atBottom: a,
    atEnd: l,
    atStart: u,
    atTop: s
  };
}
function Fi(e, t) {
  return e === (t === nn ? 0 : "100%");
}
var lp = function(t) {
  var n = t.checkInterval, r = t.children, i = t.debounce, o = t.debug, a = t.initialScrollBehavior, s = t.mode, l = t.nonce, u = t.scroller, c = st(function() {
    return Rq("<ScrollToBottom>", {
      force: o
    });
  }, [o]);
  s = s === nn ? nn : eG;
  var f = Ke(0), p = Ke(a), d = Bu(s === nn ? 0 : "100%"), v = bn(d, 3), h = v[0], g = v[1], m = v[2], b = Bu(null), w = bn(b, 3), C = w[0], S = w[1], E = w[2], I = Ke(0), N = Ke(0), A = Ke(0), O = ge(!0), D = bn(O, 2), U = D[0], L = D[1], M = ge(!0), _ = bn(M, 2), z = _[0], q = _[1], H = ge(!0), P = bn(H, 2), y = P[0], T = P[1], j = ge(!1), x = bn(j, 2), F = x[0], G = x[1], K = Bu(!0), Y = bn(K, 3), Q = Y[0], Z = Y[1], X = Y[2], J = Ke([]), V = Oe(function(B) {
    var te = E.current;
    return J.current.push(B), te && B({
      scrollTop: te.scrollTop
    }), function() {
      var ae = J.current, ce = o7(ae).call(ae, B);
      ~ce && I7(ae).call(ae, ce, 1);
    };
  }, [J, E]), ne = Oe(function() {
    var B = m.current;
    c(function() {
      var te;
      return Xe(te = ["%cSpineTo%c: %conEnd%c is fired."]).call(te, ke(je("magenta")), ke(je("orange")), [{
        animateTo: B
      }]);
    }), f.current = Jn(), Fi(B, s) || Z(!1), g(null);
  }, [m, c, f, s, g, Z]), se = Oe(function(B) {
    var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ae = te.behavior, ce = E.current;
    if (typeof B != "number" && B !== "100%")
      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or "100%".');
    c(function() {
      var ve;
      return [Xe(ve = ["%cscrollTo%c: Will scroll to %c".concat(typeof B == "number" ? B + "px" : B.replace(/%/g, "%%"), "%c")]).call(ve, ke(je("lime", "")), ke(je("purple"))), {
        behavior: ae,
        nextAnimateTo: B,
        target: ce
      }];
    }), ae === "auto" ? (ne(), ce && (ce.scrollTop = B === "100%" ? ce.scrollHeight - ce.offsetHeight : B)) : (ae !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), g(B)), Fi(B, s) && (c(function() {
      var ve;
      return [Xe(ve = ["%cscrollTo%c: Scrolling to end, will set sticky to %ctrue%c."]).call(ve, ke(je("lime", "")), ke(je("purple"))), [{
        mode: s,
        nextAnimateTo: B
      }]];
    }), Z(!0));
  }, [c, ne, s, g, Z, E]), fe = Oe(function() {
    var B = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = B.behavior;
    c(function() {
      var ae;
      return Xe(ae = ["%cscrollToBottom%c: Called"]).call(ae, ke(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), se("100%", {
      behavior: te || "smooth"
    });
  }, [c, se]), oe = Oe(function() {
    var B = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = B.behavior;
    c(function() {
      var ae;
      return Xe(ae = ["%cscrollToTop%c: Called"]).call(ae, ke(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), se(0, {
      behavior: te || "smooth"
    });
  }, [c, se]), pe = Oe(function() {
    var B = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = B.behavior;
    c(function() {
      var ce;
      return Xe(ce = ["%cscrollToEnd%c: Called"]).call(ce, ke(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var ae = {
      behavior: te || "smooth"
    };
    s === nn ? oe(ae) : fe(ae);
  }, [c, s, fe, oe]), Se = Oe(function() {
    var B = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = B.behavior;
    c(function() {
      var ce;
      return Xe(ce = ["%cscrollToStart%c: Called"]).call(ce, ke(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var ae = {
      behavior: te || "smooth"
    };
    s === nn ? fe(ae) : oe(ae);
  }, [c, s, fe, oe]), Ie = Oe(function() {
    var B = E.current;
    if (B) {
      if (p.current === "auto") {
        c(function() {
          var it;
          return Xe(it = ["%ctarget changed%c: Initial scroll"]).call(it, ke(je("blue")));
        }), B.scrollTop = s === nn ? 0 : B.scrollHeight - B.offsetHeight, p.current = !1;
        return;
      }
      var te = I.current, ae = B.offsetHeight, ce = B.scrollHeight, ve = B.scrollTop, qe = s === nn ? 0 : Math.max(0, ce - ae - ve), Ge = Math.max(0, te - ve), gt = u({
        maxValue: qe,
        minValue: Ge,
        offsetHeight: ae,
        scrollHeight: ce,
        scrollTop: ve
      }), rt = Math.max(0, Math.min(qe, gt)), Re;
      s === nn || rt !== qe ? Re = ve + rt : Re = "100%", c(function() {
        var it, Ze, qt;
        return [Xe(it = [Xe(Ze = Xe(qt = "%cscrollToSticky%c: Will animate from %c".concat(te, "px%c to %c")).call(qt, typeof Re == "number" ? Re + "px" : Re.replace(/%/g, "%%"), "%c (%c")).call(Ze, (Re === "100%" ? qe : Re) + te, "px%c)")]).call(it, ke(je("orange")), ke(je("purple")), ke(je("purple")), ke(je("purple"))), {
          animateFrom: te,
          maxValue: qe,
          minValue: Ge,
          nextAnimateTo: Re,
          nextValue: rt,
          offsetHeight: ae,
          rawNextValue: gt,
          scrollHeight: ce,
          scrollTop: ve
        }];
      }), se(Re, {
        behavior: "smooth"
      });
    }
  }, [I, c, s, u, se, E]), nt = Oe(function(B) {
    var te, ae = B.timeStampLow, ce = m.current, ve = E.current, qe = ce !== null;
    if (!(ae <= f.current || !ve)) {
      var Ge = py({
        mode: s,
        target: ve
      }), gt = Ge.atBottom, rt = Ge.atEnd, Re = Ge.atStart, it = Ge.atTop;
      L(gt), q(rt), G(Re), T(it);
      var Ze = ve.offsetHeight, qt = ve.scrollHeight, Ei = N.current, Rn = A.current, or = Ze !== Ei, ar = qt !== Rn;
      if (or && (N.current = Ze), ar && (A.current = qt), !or && !ar) {
        var sr = qe && Fi(ce, s) || rt;
        X.current !== sr && (c(function() {
          var hn, Fo, ki, Ci;
          return [Xe(hn = ["%conScroll%c: %csetSticky%c(%c".concat(sr, "%c)")]).call(hn, ke(je("red")), ke(je("red")), ke(je("purple"))), Xe(Fo = [Xe(ki = Xe(Ci = "(animating = %c".concat(qe, "%c && isEnd = %c")).call(Ci, Fi(ce, s), "%c) || atEnd = %c")).call(ki, rt, "%c")]).call(Fo, ke(je("purple")), ke(je("purple")), ke(je("purple")), [{
            animating: qe,
            animateTo: ce,
            atEnd: rt,
            mode: s,
            offsetHeight: ve.offsetHeight,
            scrollHeight: ve.scrollHeight,
            sticky: X.current,
            nextSticky: sr
          }])];
        }), Z(sr));
      } else X.current && (c(function() {
        var hn;
        return [Xe(hn = ["%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c"]).call(hn, ke(je("red")), ke(je("orange")), [{
          offsetHeightChanged: or,
          scrollHeightChanged: ar
        }]), {
          nextOffsetHeight: Ze,
          prevOffsetHeight: Ei,
          nextScrollHeight: qt,
          prevScrollHeight: Rn
        }];
      }), Ie());
      var ol = ve.scrollTop;
      ss(te = J.current).call(te, function(hn) {
        return hn({
          scrollTop: ol
        });
      });
    }
  }, [m, c, f, s, N, A, J, Ie, L, q, G, T, Z, X, E]);
  vt(function() {
    if (C) {
      var B = !1, te = nG(function() {
        var ae = E.current, ce = m.current !== null;
        X.current ? py({
          mode: s,
          target: ae
        }).atEnd ? B = !1 : B ? Jn() - B > tG && (ce || (I.current = ae.scrollTop, c(function() {
          var ve;
          return Xe(ve = ["%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll"]).call(ve, ke(je("navy")), ke(je("orange")));
        }), Ie()), B = !1) : B = Jn() : ae.scrollHeight <= ae.offsetHeight && !X.current && (c(function() {
          var ve;
          return [Xe(ve = ["%cInterval check%c: Container is emptied, setting sticky back to %ctrue%c"]).call(ve, ke(je("navy")), ke(je("purple"))), [{
            offsetHeight: ae.offsetHeight,
            scrollHeight: ae.scrollHeight,
            sticky: X.current
          }]];
        }), Z(!0));
      }, Math.max(cy, n) || cy);
      return function() {
        return clearInterval(te);
      };
    }
  }, [m, n, c, s, Ie, Z, X, C, E]);
  var St = st(function() {
    var B = dy[l] || (dy[l] = sq({
      key: "react-scroll-to-bottom--css-" + Oq(),
      nonce: l
    }));
    return function(te) {
      return B.css(te) + "";
    };
  }, [l]), Et = st(function() {
    return {
      observeScrollPosition: V,
      setTarget: S,
      styleToClassName: St
    };
  }, [V, S, St]), kt = st(function() {
    return {
      atBottom: U,
      atEnd: z,
      atStart: F,
      atTop: y,
      mode: s
    };
  }, [U, z, F, y, s]), ie = st(function() {
    var B = h !== null;
    return {
      animating: B,
      animatingToEnd: B && Fi(h, s),
      sticky: Q
    };
  }, [h, s, Q]), ue = st(function() {
    return uy(uy({}, kt), ie);
  }, [kt, ie]), W = st(function() {
    return {
      scrollTo: se,
      scrollToBottom: fe,
      scrollToEnd: pe,
      scrollToStart: Se,
      scrollToTop: oe
    };
  }, [se, fe, pe, Se, oe]);
  return vt(function() {
    if (C) {
      var B = function() {
        A.current = C.scrollHeight;
      };
      return C.addEventListener("focus", B, {
        capture: !0,
        passive: !0
      }), function() {
        return C.removeEventListener("focus", B);
      };
    }
  }, [C]), c(function() {
    var B;
    return [Xe(B = ["%cRender%c: Render"]).call(B, ke(je("cyan", ""))), {
      animateTo: h,
      animating: h !== null,
      sticky: Q,
      target: C
    }];
  }), /* @__PURE__ */ Le.createElement(Gs.Provider, {
    value: Et
  }, /* @__PURE__ */ Le.createElement(Ld.Provider, {
    value: W
  }, /* @__PURE__ */ Le.createElement(zd.Provider, {
    value: ue
  }, /* @__PURE__ */ Le.createElement(Fd.Provider, {
    value: kt
  }, /* @__PURE__ */ Le.createElement(Bd.Provider, {
    value: ie
  }, r, C && /* @__PURE__ */ Le.createElement(c0, {
    debounce: i,
    name: "scroll",
    onEvent: nt,
    target: C
  }), C && h !== null && /* @__PURE__ */ Le.createElement(f0, {
    name: "scrollTop",
    onEnd: ne,
    target: C,
    value: h
  }))))));
};
lp.defaultProps = {
  checkInterval: 100,
  children: void 0,
  debounce: 17,
  debug: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: Zq
};
lp.propTypes = {
  checkInterval: Te.number,
  children: Te.any,
  debounce: Te.number,
  debug: Te.bool,
  initialScrollBehavior: Te.oneOf(["auto", "smooth"]),
  mode: Te.oneOf(["bottom", "top"]),
  nonce: Te.string,
  scroller: Te.func
};
var rG = {
  height: "100%",
  overflowY: "auto",
  width: "100%"
}, up = function(t) {
  var n = t.children, r = t.className, i = ci(Gs), o = i.setTarget, a = Wd()(rG);
  return /* @__PURE__ */ Le.createElement("div", {
    className: jd(a, (r || "") + ""),
    ref: o
  }, n);
};
up.defaultProps = {
  children: void 0,
  className: void 0
};
up.propTypes = {
  children: Te.any,
  className: Te.string
};
var iG = {
  position: "relative"
}, cp = function(t) {
  var n = t.children, r = t.className, i = t.followButtonClassName, o = t.scrollViewClassName, a = Wd()(iG);
  return /* @__PURE__ */ Le.createElement("div", {
    className: jd(a, (r || "") + "")
  }, /* @__PURE__ */ Le.createElement(up, {
    className: (o || "") + ""
  }, n), /* @__PURE__ */ Le.createElement(Ud, {
    className: (i || "") + ""
  }));
};
cp.defaultProps = {
  children: void 0,
  className: void 0,
  followButtonClassName: void 0,
  scrollViewClassName: void 0
};
cp.propTypes = {
  children: Te.any,
  className: Te.string,
  followButtonClassName: Te.string,
  scrollViewClassName: Te.string
};
var fp = function(t) {
  var n = t.checkInterval, r = t.children, i = t.className, o = t.debounce, a = t.debug, s = t.followButtonClassName, l = t.initialScrollBehavior, u = t.mode, c = t.nonce, f = t.scroller, p = t.scrollViewClassName;
  return /* @__PURE__ */ Le.createElement(lp, {
    checkInterval: n,
    debounce: o,
    debug: a,
    initialScrollBehavior: l,
    mode: u,
    nonce: c,
    scroller: f
  }, /* @__PURE__ */ Le.createElement(cp, {
    className: i,
    followButtonClassName: s,
    scrollViewClassName: p
  }, r));
};
fp.defaultProps = {
  checkInterval: void 0,
  children: void 0,
  className: void 0,
  debounce: void 0,
  debug: void 0,
  followButtonClassName: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: void 0,
  scrollViewClassName: void 0
};
fp.propTypes = {
  checkInterval: Te.number,
  children: Te.any,
  className: Te.string,
  debounce: Te.number,
  debug: Te.bool,
  followButtonClassName: Te.string,
  initialScrollBehavior: Te.oneOf(["auto", "smooth"]),
  mode: Te.oneOf(["bottom", "top"]),
  nonce: Te.string,
  scroller: Te.func,
  scrollViewClassName: Te.string
};
kj();
let d0 = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
const p0 = ds(
  ({
    className: e,
    messages: t = [],
    isTyping: n,
    headerMessage: r,
    renderers: i,
    botAvatar: o,
    botDescription: a,
    botName: s,
    sendMessage: l,
    addMessageFeedback: u,
    showMarquee: c = !0,
    ...f
  }) => {
    var h;
    const { messageList: p } = we, d = st(() => ek(t), [t]), v = st(() => {
      var m;
      const g = d.filter((b) => b.direction === "outgoing" && b.status !== "pending");
      return (m = g[g.length - 1]) == null ? void 0 : m.id;
    }, [d]);
    return /* @__PURE__ */ $.jsxs(
      fp,
      {
        ...f,
        className: oi(p.container.className, e),
        followButtonClassName: p.scrollDownButton.className,
        scrollViewClassName: p.viewPort.className,
        children: [
          r && /* @__PURE__ */ $.jsx("span", { ...p.headerMessage, children: r }),
          c && /* @__PURE__ */ $.jsx(Sj, { botAvatar: o, botDescription: a, botName: s }),
          d.map((g) => {
            var m;
            return /* @__PURE__ */ $.jsx(
              _v,
              {
                renderers: i,
                sendMessage: l,
                addMessageFeedback: u,
                isLastDeliveredMessage: g.id === v,
                ...g
              },
              ((m = g.metadata) == null ? void 0 : m.clientMessageId) || g.id
            );
          }),
          n && /* @__PURE__ */ $.jsx(
            _v,
            {
              id: d0(),
              renderers: i,
              sendMessage: l,
              direction: "incoming",
              timestamp: /* @__PURE__ */ new Date(),
              block: void 0,
              sender: ((h = t.filter((g) => g.direction === "incoming").at(-1)) == null ? void 0 : h.sender) ?? {
                name: s || "Bot",
                avatar: o
              },
              children: /* @__PURE__ */ $.jsx(Pw, {})
            }
          )
        ]
      }
    );
  }
);
p0.displayName = "MessageList";
const oG = ({ className: e, ...t }) => {
  const { className: n } = we.loader;
  return /* @__PURE__ */ $.jsx("div", { ...t, className: oi(e, n) });
};
function aG({ error: e }) {
  let t, n;
  const { error: r } = we;
  return e.type === "configuration" ? (t = "Configuration error", n = /* @__PURE__ */ $.jsx(gP, { ...r.icon })) : e.type === "bot" ? (t = "Bot error", n = /* @__PURE__ */ $.jsx(Th, { ...r.icon })) : e.type === "network" ? (t = "Network error", n = /* @__PURE__ */ $.jsx(CP, { ...r.icon })) : (t = "Unexpected error", n = /* @__PURE__ */ $.jsx(Th, { ...r.icon })), /* @__PURE__ */ $.jsx(sG, { error: e, title: t, icon: n });
}
function sG({ error: e, title: t, icon: n }) {
  const { error: r } = we;
  return /* @__PURE__ */ $.jsxs("div", { ...r.container, children: [
    /* @__PURE__ */ $.jsx("div", { ...r.header, children: `Webchat ${e.type} error` }),
    /* @__PURE__ */ $.jsxs("div", { ...r.content, children: [
      n,
      /* @__PURE__ */ $.jsx("div", { ...r.errorTitle, children: t }),
      /* @__PURE__ */ $.jsx("div", { ...r.errorMessage, children: e.message })
    ] })
  ] });
}
const lG = ({
  connected: e,
  configuration: t,
  isTyping: n,
  messages: r,
  user: i,
  isLoading: o,
  renderers: a,
  isReadOnly: s,
  disableComposer: l,
  allowFileUpload: u,
  error: c,
  participants: f,
  closeWindow: p,
  sendMessage: d,
  uploadFile: v,
  addMessageFeedback: h,
  restartConversation: g,
  ...m
}) => {
  const {
    color: b,
    fontFamily: w,
    radius: C,
    themeMode: S,
    variant: E,
    headerVariant: I,
    botAvatar: N,
    botDescription: A,
    botName: O,
    composerPlaceholder: D,
    footer: U,
    feedbackEnabled: L
  } = t, M = { color: b, fontFamily: w, radius: C, themeMode: S, variant: E, headerVariant: I };
  L || (h = void 0);
  const _ = st(() => i ? ZE(r, f, i.id, O, N) : [], [N, O, r, i, f]);
  return /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    /* @__PURE__ */ $.jsx(QM, { ...M }),
    /* @__PURE__ */ $.jsx(Ew, { connected: e, allowFileUpload: u, uploadFile: v, ...m, children: c ? /* @__PURE__ */ $.jsx(aG, { error: c }) : /* @__PURE__ */ $.jsxs($.Fragment, { children: [
      /* @__PURE__ */ $.jsx(wj, { closeWindow: p, configuration: t, restartConversation: g }),
      o ? /* @__PURE__ */ $.jsx(oG, {}) : /* @__PURE__ */ $.jsx(
        p0,
        {
          botAvatar: N,
          botDescription: A,
          botName: O,
          renderers: a,
          isTyping: n,
          sendMessage: d,
          addMessageFeedback: h,
          messages: _
        }
      ),
      /* @__PURE__ */ $.jsx(
        Y_,
        {
          sendMessage: d,
          uploadFile: v,
          connected: e,
          isReadOnly: s,
          disableComposer: l,
          footer: U,
          composerPlaceholder: D,
          allowFileUpload: u
        }
      )
    ] }) })
  ] });
};
function uG() {
  const [e, t] = ge(!1), n = Ke(null);
  return {
    isTyping: e,
    setIsTyping: (r, i) => {
      if (t(r), !r)
        return () => {
        };
      if (n.current = /* @__PURE__ */ new Date(), !i)
        return () => {
        };
      const o = setTimeout(() => {
        const a = n.current;
        a && (/* @__PURE__ */ new Date()).getTime() - a.getTime() > i && t(!1);
      }, i + 100);
      return () => clearTimeout(o);
    }
  };
}
var cG = Object.defineProperty, fG = (e, t, n) => t in e ? cG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, dG = (e, t, n) => fG(e, t + "", n), pG = async (e, t) => {
  let n = typeof t == "function" ? await t(e) : t;
  if (n) return e.scheme === "bearer" ? `Bearer ${n}` : e.scheme === "basic" ? `Basic ${btoa(n)}` : n;
}, hG = { bodySerializer: (e) => JSON.stringify(e, (t, n) => typeof n == "bigint" ? n.toString() : n) }, vG = (e) => {
  switch (e) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
}, mG = (e) => {
  switch (e) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
}, gG = (e) => {
  switch (e) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
}, h0 = ({ allowReserved: e, explode: t, name: n, style: r, value: i }) => {
  if (!t) {
    let s = (e ? i : i.map((l) => encodeURIComponent(l))).join(mG(r));
    switch (r) {
      case "label":
        return `.${s}`;
      case "matrix":
        return `;${n}=${s}`;
      case "simple":
        return s;
      default:
        return `${n}=${s}`;
    }
  }
  let o = vG(r), a = i.map((s) => r === "label" || r === "simple" ? e ? s : encodeURIComponent(s) : rl({ allowReserved: e, name: n, value: s })).join(o);
  return r === "label" || r === "matrix" ? o + a : a;
}, rl = ({ allowReserved: e, name: t, value: n }) => {
  if (n == null) return "";
  if (typeof n == "object") throw new Error("Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.");
  return `${t}=${e ? n : encodeURIComponent(n)}`;
}, v0 = ({ allowReserved: e, explode: t, name: n, style: r, value: i }) => {
  if (i instanceof Date) return `${n}=${i.toISOString()}`;
  if (r !== "deepObject" && !t) {
    let s = [];
    Object.entries(i).forEach(([u, c]) => {
      s = [...s, u, e ? c : encodeURIComponent(c)];
    });
    let l = s.join(",");
    switch (r) {
      case "form":
        return `${n}=${l}`;
      case "label":
        return `.${l}`;
      case "matrix":
        return `;${n}=${l}`;
      default:
        return l;
    }
  }
  let o = gG(r), a = Object.entries(i).map(([s, l]) => rl({ allowReserved: e, name: r === "deepObject" ? `${n}[${s}]` : s, value: l })).join(o);
  return r === "label" || r === "matrix" ? o + a : a;
}, yG = /\{[^{}]+\}/g, bG = ({ path: e, url: t }) => {
  let n = t, r = t.match(yG);
  if (r) for (let i of r) {
    let o = !1, a = i.substring(1, i.length - 1), s = "simple";
    a.endsWith("*") && (o = !0, a = a.substring(0, a.length - 1)), a.startsWith(".") ? (a = a.substring(1), s = "label") : a.startsWith(";") && (a = a.substring(1), s = "matrix");
    let l = e[a];
    if (l == null) continue;
    if (Array.isArray(l)) {
      n = n.replace(i, h0({ explode: o, name: a, style: s, value: l }));
      continue;
    }
    if (typeof l == "object") {
      n = n.replace(i, v0({ explode: o, name: a, style: s, value: l }));
      continue;
    }
    if (s === "matrix") {
      n = n.replace(i, `;${rl({ name: a, value: l })}`);
      continue;
    }
    let u = encodeURIComponent(s === "label" ? `.${l}` : l);
    n = n.replace(i, u);
  }
  return n;
}, m0 = ({ allowReserved: e, array: t, object: n } = {}) => (r) => {
  let i = [];
  if (r && typeof r == "object") for (let o in r) {
    let a = r[o];
    if (a != null) {
      if (Array.isArray(a)) {
        i = [...i, h0({ allowReserved: e, explode: !0, name: o, style: "form", value: a, ...t })];
        continue;
      }
      if (typeof a == "object") {
        i = [...i, v0({ allowReserved: e, explode: !0, name: o, style: "deepObject", value: a, ...n })];
        continue;
      }
      i = [...i, rl({ allowReserved: e, name: o, value: a })];
    }
  }
  return i.join("&");
}, xG = (e) => {
  var t;
  if (!e) return "stream";
  let n = (t = e.split(";")[0]) == null ? void 0 : t.trim();
  if (n) {
    if (n.startsWith("application/json") || n.endsWith("+json")) return "json";
    if (n === "multipart/form-data") return "formData";
    if (["application/", "audio/", "image/", "video/"].some((r) => n.startsWith(r))) return "blob";
    if (n.startsWith("text/")) return "text";
  }
}, wG = async ({ security: e, ...t }) => {
  for (let n of e) {
    let r = await pG(n, t.auth);
    if (!r) continue;
    let i = n.name ?? "Authorization";
    switch (n.in) {
      case "query":
        t.query || (t.query = {}), t.query[i] = r;
        break;
      case "cookie":
        t.headers.append("Cookie", `${i}=${r}`);
        break;
      case "header":
      default:
        t.headers.set(i, r);
        break;
    }
    return;
  }
}, hy = (e) => SG({ baseUrl: e.baseUrl, path: e.path, query: e.query, querySerializer: typeof e.querySerializer == "function" ? e.querySerializer : m0(e.querySerializer), url: e.url }), SG = ({ baseUrl: e, path: t, query: n, querySerializer: r, url: i }) => {
  let o = i.startsWith("/") ? i : `/${i}`, a = (e ?? "") + o;
  t && (a = bG({ path: t, url: a }));
  let s = n ? r(n) : "";
  return s.startsWith("?") && (s = s.substring(1)), s && (a += `?${s}`), a;
}, vy = (e, t) => {
  var n;
  let r = { ...e, ...t };
  return (n = r.baseUrl) != null && n.endsWith("/") && (r.baseUrl = r.baseUrl.substring(0, r.baseUrl.length - 1)), r.headers = g0(e.headers, t.headers), r;
}, g0 = (...e) => {
  let t = new Headers();
  for (let n of e) {
    if (!n || typeof n != "object") continue;
    let r = n instanceof Headers ? n.entries() : Object.entries(n);
    for (let [i, o] of r) if (o === null) t.delete(i);
    else if (Array.isArray(o)) for (let a of o) t.append(i, a);
    else o !== void 0 && t.set(i, typeof o == "object" ? JSON.stringify(o) : o);
  }
  return t;
}, zu = class {
  constructor() {
    dG(this, "_fns"), this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  exists(t) {
    return this._fns.indexOf(t) !== -1;
  }
  eject(t) {
    let n = this._fns.indexOf(t);
    n !== -1 && (this._fns = [...this._fns.slice(0, n), ...this._fns.slice(n + 1)]);
  }
  use(t) {
    this._fns = [...this._fns, t];
  }
}, EG = () => ({ error: new zu(), request: new zu(), response: new zu() }), kG = /* @__PURE__ */ m0({ allowReserved: !1, array: { explode: !0, style: "form" }, object: { explode: !0, style: "deepObject" } }), CG = { "Content-Type": "application/json" }, y0 = (e = {}) => ({ ...hG, headers: CG, parseAs: "auto", querySerializer: kG, ...e }), $G = (e = {}) => {
  let t = vy(y0(), e), n = () => ({ ...t }), r = (a) => (t = vy(t, a), n()), i = EG(), o = async (a) => {
    let s = { ...t, ...a, fetch: a.fetch ?? t.fetch ?? globalThis.fetch, headers: g0(t.headers, a.headers) };
    s.security && await wG({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === "") && s.headers.delete("Content-Type");
    let l = hy(s), u = { redirect: "follow", ...s }, c = new Request(l, u);
    for (let g of i.request._fns) c = await g(c, s);
    let f = s.fetch, p = await f(c);
    for (let g of i.response._fns) p = await g(p, c, s);
    let d = { request: c, response: p };
    if (p.ok) {
      if (p.status === 204 || p.headers.get("Content-Length") === "0") return { data: {}, ...d };
      let g = (s.parseAs === "auto" ? xG(p.headers.get("Content-Type")) : s.parseAs) ?? "json";
      if (g === "stream") return { data: p.body, ...d };
      let m = await p[g]();
      return g === "json" && (s.responseValidator && await s.responseValidator(m), s.responseTransformer && (m = await s.responseTransformer(m))), { data: m, ...d };
    }
    let v = await p.text();
    try {
      v = JSON.parse(v);
    } catch {
    }
    let h = v;
    for (let g of i.error._fns) h = await g(v, p, c, s);
    if (h = h || {}, s.throwOnError) throw h;
    return { error: h, ...d };
  };
  return { buildUrl: hy, connect: (a) => o({ ...a, method: "CONNECT" }), delete: (a) => o({ ...a, method: "DELETE" }), get: (a) => o({ ...a, method: "GET" }), getConfig: n, head: (a) => o({ ...a, method: "HEAD" }), interceptors: i, options: (a) => o({ ...a, method: "OPTIONS" }), patch: (a) => o({ ...a, method: "PATCH" }), post: (a) => o({ ...a, method: "POST" }), put: (a) => o({ ...a, method: "PUT" }), request: o, setConfig: r, trace: (a) => o({ ...a, method: "TRACE" }) };
}, TG = $G, OG = y0;
const IG = (e) => ({
  ...e,
  withCredentials: !0,
  timeout: 6e4,
  maxBodyLength: 104857600,
  maxContentLength: 104857600,
  throwOnError: !0
}), Fe = /* @__PURE__ */ TG(/* @__PURE__ */ IG(/* @__PURE__ */ OG({
  baseUrl: "https://webchat.botpress.cloud/"
}))), RG = (e) => (e.client ?? Fe).delete({
  url: "/conversations/{id}",
  ...e
}), PG = (e) => (e.client ?? Fe).get({
  url: "/conversations/{id}",
  ...e
}), AG = (e) => (e.client ?? Fe).get({
  url: "/conversations",
  ...e
}), DG = (e) => (e.client ?? Fe).post({
  url: "/conversations",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), _G = (e) => (e.client ?? Fe).get({
  url: "/conversations/{id}/messages",
  ...e
}), MG = (e) => (e.client ?? Fe).get({
  url: "/conversations/{id}/participants",
  ...e
}), jG = (e) => (e.client ?? Fe).post({
  url: "/conversations/{id}/participants",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), NG = (e) => (e.client ?? Fe).delete({
  url: "/conversations/{id}/participants/{userId}",
  ...e
}), LG = (e) => (e.client ?? Fe).get({
  url: "/conversations/{id}/participants/{userId}",
  ...e
}), FG = (e) => (e.client ?? Fe).delete({
  url: "/messages/{id}",
  ...e
}), BG = (e) => (e.client ?? Fe).get({
  url: "/messages/{id}",
  ...e
}), zG = (e) => (e.client ?? Fe).put({
  url: "/messages/{id}",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), WG = (e) => (e.client ?? Fe).post({
  url: "/messages",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), UG = (e) => (e.client ?? Fe).delete({
  url: "/messages/{id}/feedback",
  ...e
}), HG = (e) => (e.client ?? Fe).put({
  url: "/messages/{id}/feedback",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), VG = (e) => (e.client ?? Fe).delete({
  url: "/users/me",
  ...e
}), KG = (e) => (e.client ?? Fe).get({
  url: "/users/me",
  ...e
}), qG = (e) => (e.client ?? Fe).put({
  url: "/users/me",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), b0 = (e) => ((e == null ? void 0 : e.client) ?? Fe).post({
  url: "/users",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), GG = (e) => (e.client ?? Fe).get({
  url: "/events/{id}",
  ...e
}), YG = (e) => (e.client ?? Fe).post({
  url: "/events",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), XG = (e) => (e.client ?? Fe).post({
  url: "/files",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
});
let my = class extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
};
function Wu(e) {
}
function JG(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = Wu, onError: n = Wu, onRetry: r = Wu, onComment: i } = e;
  let o = "", a = !0, s, l = "", u = "";
  function c(h) {
    const g = a ? h.replace(/^\xEF\xBB\xBF/, "") : h, [m, b] = QG(`${o}${g}`);
    for (const w of m)
      f(w);
    o = b, a = !1;
  }
  function f(h) {
    if (h === "") {
      d();
      return;
    }
    if (h.startsWith(":")) {
      i && i(h.slice(h.startsWith(": ") ? 2 : 1));
      return;
    }
    const g = h.indexOf(":");
    if (g !== -1) {
      const m = h.slice(0, g), b = h[g + 1] === " " ? 2 : 1, w = h.slice(g + b);
      p(m, w, h);
      return;
    }
    p(h, "", h);
  }
  function p(h, g, m) {
    switch (h) {
      case "event":
        u = g;
        break;
      case "data":
        l = `${l}${g}
`;
        break;
      case "id":
        s = g.includes("\0") ? void 0 : g;
        break;
      case "retry":
        /^\d+$/.test(g) ? r(parseInt(g, 10)) : n(
          new my(`Invalid \`retry\` value: "${g}"`, {
            type: "invalid-retry",
            value: g,
            line: m
          })
        );
        break;
      default:
        n(
          new my(
            `Unknown field "${h.length > 20 ? `${h.slice(0, 20)}…` : h}"`,
            { type: "unknown-field", field: h, value: g, line: m }
          )
        );
        break;
    }
  }
  function d() {
    l.length > 0 && t({
      id: s,
      event: u || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: l.endsWith(`
`) ? l.slice(0, -1) : l
    }), s = void 0, l = "", u = "";
  }
  function v(h = {}) {
    o && h.consume && f(o), a = !0, s = void 0, l = "", u = "", o = "";
  }
  return { feed: c, reset: v };
}
function QG(e) {
  const t = [];
  let n = "", r = 0;
  for (; r < e.length; ) {
    const i = e.indexOf("\r", r), o = e.indexOf(`
`, r);
    let a = -1;
    if (i !== -1 && o !== -1 ? a = Math.min(i, o) : i !== -1 ? a = i : o !== -1 && (a = o), a === -1) {
      n = e.slice(r);
      break;
    } else {
      const s = e.slice(r, a);
      t.push(s), r = a + 1, e[r - 1] === "\r" && e[r] === `
` && r++;
    }
  }
  return [t, n];
}
class gy extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(t, n) {
    var r, i;
    super(t), this.code = (r = n == null ? void 0 : n.code) != null ? r : void 0, this.message = (i = n == null ? void 0 : n.message) != null ? i : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](t, n, r) {
    return r(yy(this), n);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](t, n) {
    return t(yy(this), n);
  }
}
function ZG(e) {
  const t = globalThis.DOMException;
  return typeof t == "function" ? new t(e, "SyntaxError") : new SyntaxError(e);
}
function ef(e) {
  return e instanceof Error ? "errors" in e && Array.isArray(e.errors) ? e.errors.map(ef).join(", ") : "cause" in e && e.cause instanceof Error ? `${e}: ${ef(e.cause)}` : e.message : `${e}`;
}
function yy(e) {
  return {
    type: e.type,
    message: e.message,
    code: e.code,
    defaultPrevented: e.defaultPrevented,
    cancelable: e.cancelable,
    timeStamp: e.timeStamp
  };
}
var x0 = (e) => {
  throw TypeError(e);
}, dp = (e, t, n) => t.has(e) || x0("Cannot " + n), ye = (e, t, n) => (dp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), ut = (e, t, n) => t.has(e) ? x0("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), Ve = (e, t, n, r) => (dp(e, t, "write to private field"), t.set(e, n), n), Pn = (e, t, n) => (dp(e, t, "access private method"), n), Nt, hr, Fr, Da, cs, Yi, Hr, Xi, Vn, Br, Xr, zr, Wi, tn, tf, nf, rf, by, of, af, Ui, sf, lf;
class _a extends EventTarget {
  constructor(t, n) {
    var r, i;
    super(), ut(this, tn), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, ut(this, Nt), ut(this, hr), ut(this, Fr), ut(this, Da), ut(this, cs), ut(this, Yi), ut(this, Hr), ut(this, Xi, null), ut(this, Vn), ut(this, Br), ut(this, Xr, null), ut(this, zr, null), ut(this, Wi, null), ut(this, nf, async (o) => {
      var a;
      ye(this, Br).reset();
      const { body: s, redirected: l, status: u, headers: c } = o;
      if (u === 204) {
        Pn(this, tn, Ui).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (l ? Ve(this, Fr, new URL(o.url)) : Ve(this, Fr, void 0), u !== 200) {
        Pn(this, tn, Ui).call(this, `Non-200 status code (${u})`, u);
        return;
      }
      if (!(c.get("content-type") || "").startsWith("text/event-stream")) {
        Pn(this, tn, Ui).call(this, 'Invalid content type, expected "text/event-stream"', u);
        return;
      }
      if (ye(this, Nt) === this.CLOSED)
        return;
      Ve(this, Nt, this.OPEN);
      const f = new Event("open");
      if ((a = ye(this, Wi)) == null || a.call(this, f), this.dispatchEvent(f), typeof s != "object" || !s || !("getReader" in s)) {
        Pn(this, tn, Ui).call(this, "Invalid response body, expected a web ReadableStream", u), this.close();
        return;
      }
      const p = new TextDecoder(), d = s.getReader();
      let v = !0;
      do {
        const { done: h, value: g } = await d.read();
        g && ye(this, Br).feed(p.decode(g, { stream: !h })), h && (v = !1, ye(this, Br).reset(), Pn(this, tn, sf).call(this));
      } while (v);
    }), ut(this, rf, (o) => {
      Ve(this, Vn, void 0), !(o.name === "AbortError" || o.type === "aborted") && Pn(this, tn, sf).call(this, ef(o));
    }), ut(this, of, (o) => {
      typeof o.id == "string" && Ve(this, Xi, o.id);
      const a = new MessageEvent(o.event || "message", {
        data: o.data,
        origin: ye(this, Fr) ? ye(this, Fr).origin : ye(this, hr).origin,
        lastEventId: o.id || ""
      });
      ye(this, zr) && (!o.event || o.event === "message") && ye(this, zr).call(this, a), this.dispatchEvent(a);
    }), ut(this, af, (o) => {
      Ve(this, Yi, o);
    }), ut(this, lf, () => {
      Ve(this, Hr, void 0), ye(this, Nt) === this.CONNECTING && Pn(this, tn, tf).call(this);
    });
    try {
      if (t instanceof URL)
        Ve(this, hr, t);
      else if (typeof t == "string")
        Ve(this, hr, new URL(t, eY()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw ZG("An invalid or illegal string was specified");
    }
    Ve(this, Br, JG({
      onEvent: ye(this, of),
      onRetry: ye(this, af)
    })), Ve(this, Nt, this.CONNECTING), Ve(this, Yi, 3e3), Ve(this, cs, (r = n == null ? void 0 : n.fetch) != null ? r : globalThis.fetch), Ve(this, Da, (i = n == null ? void 0 : n.withCredentials) != null ? i : !1), Pn(this, tn, tf).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return ye(this, Nt);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return ye(this, hr).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return ye(this, Da);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return ye(this, Xr);
  }
  set onerror(t) {
    Ve(this, Xr, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return ye(this, zr);
  }
  set onmessage(t) {
    Ve(this, zr, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return ye(this, Wi);
  }
  set onopen(t) {
    Ve(this, Wi, t);
  }
  addEventListener(t, n, r) {
    const i = n;
    super.addEventListener(t, i, r);
  }
  removeEventListener(t, n, r) {
    const i = n;
    super.removeEventListener(t, i, r);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    ye(this, Hr) && clearTimeout(ye(this, Hr)), ye(this, Nt) !== this.CLOSED && (ye(this, Vn) && ye(this, Vn).abort(), Ve(this, Nt, this.CLOSED), Ve(this, Vn, void 0));
  }
}
Nt = /* @__PURE__ */ new WeakMap(), hr = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), cs = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakMap(), Hr = /* @__PURE__ */ new WeakMap(), Xi = /* @__PURE__ */ new WeakMap(), Vn = /* @__PURE__ */ new WeakMap(), Br = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap(), zr = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
tf = function() {
  Ve(this, Nt, this.CONNECTING), Ve(this, Vn, new AbortController()), ye(this, cs)(ye(this, hr), Pn(this, tn, by).call(this)).then(ye(this, nf)).catch(ye(this, rf));
}, nf = /* @__PURE__ */ new WeakMap(), rf = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
by = function() {
  var e;
  const t = {
    // [spec] Let `corsAttributeState` be `Anonymous`…
    // [spec] …will have their mode set to "cors"…
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...ye(this, Xi) ? { "Last-Event-ID": ye(this, Xi) } : void 0 },
    cache: "no-store",
    signal: (e = ye(this, Vn)) == null ? void 0 : e.signal
  };
  return "window" in globalThis && (t.credentials = this.withCredentials ? "include" : "same-origin"), t;
}, of = /* @__PURE__ */ new WeakMap(), af = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
Ui = function(e, t) {
  var n;
  ye(this, Nt) !== this.CLOSED && Ve(this, Nt, this.CLOSED);
  const r = new gy("error", { code: t, message: e });
  (n = ye(this, Xr)) == null || n.call(this, r), this.dispatchEvent(r);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
sf = function(e, t) {
  var n;
  if (ye(this, Nt) === this.CLOSED)
    return;
  Ve(this, Nt, this.CONNECTING);
  const r = new gy("error", { code: t, message: e });
  (n = ye(this, Xr)) == null || n.call(this, r), this.dispatchEvent(r), Ve(this, Hr, setTimeout(ye(this, lf), ye(this, Yi)));
}, lf = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
_a.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
_a.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
_a.CLOSED = 2;
function eY() {
  const e = "document" in globalThis ? globalThis.document : void 0;
  return e && typeof e == "object" && "baseURI" in e && typeof e.baseURI == "string" ? e.baseURI : void 0;
}
async function w0(e) {
  var t;
  const n = await e.clone().json();
  if ((t = n == null ? void 0 : n.id) != null && t.startsWith("err_")) {
    const r = new Error(n.message);
    throw r.id = n.id, r.code = n.code, r.type = n.type, r;
  }
  return e;
}
const tY = () => {
  const e = {};
  return { on: (t, n) => {
    var r;
    return e[t] || (e[t] = /* @__PURE__ */ new Set()), (r = e[t]) == null || r.add(n), () => {
      var i;
      return (i = e[t]) == null ? void 0 : i.delete(n);
    };
  }, emit: (t, n) => {
    var r, i;
    (r = e[t]) == null || r.forEach((o) => o(n)), (i = e["*"]) == null || i.forEach((o) => o({ type: t, payload: n }));
  } };
}, Ye = (e) => e.data, S0 = {
  throwOnError: !0
}, nY = ({ clientId: e, apiUrl: t }) => {
  const n = `${t || Fe.getConfig().baseUrl}/${e}`;
  Fe.interceptors.response._fns.length === 0 && Fe.interceptors.response.use(w0);
  const r = {
    ...S0,
    baseUrl: n
  };
  return b0({ ...r, body: {} }).then(Ye);
}, rY = ({
  userKey: e,
  clientId: t,
  apiUrl: n
}) => {
  const r = {
    "x-user-key": e
  }, i = `${n || Fe.getConfig().baseUrl}/${t}`, o = {
    ...S0,
    baseUrl: i
  };
  return Fe.interceptors.response._fns.length === 0 && Fe.interceptors.response.use(w0), {
    createConversation: () => DG({ ...o, headers: r, body: {} }).then(Ye),
    getConversation: ({ conversationId: a }) => PG({ ...o, headers: r, path: { id: a } }).then(Ye),
    deleteConversation: ({ conversationId: a }) => RG({ ...o, headers: r, path: { id: a } }).then(Ye),
    listConversations: ({ nextToken: a }) => AG({ ...o, headers: r, query: { nextToken: a } }).then(Ye),
    listConversationMessages: ({ conversationId: a, nextToken: s }) => _G({
      ...o,
      headers: r,
      path: { id: a },
      query: { nextToken: s }
    }).then(Ye),
    addParticipant: ({ conversationId: a, userId: s }) => jG({ ...o, headers: r, path: { id: a }, body: { userId: s } }).then(Ye),
    removeParticipant: ({ conversationId: a, userId: s }) => NG({ ...o, headers: r, path: { id: a, userId: s } }).then(Ye),
    getParticipant: ({ conversationId: a, userId: s }) => LG({ ...o, headers: r, path: { id: a, userId: s } }).then(Ye),
    listParticipants: ({ conversationId: a, nextToken: s }) => MG({ ...o, headers: r, path: { id: a }, query: { nextToken: s } }).then(Ye),
    createMessage: (a) => WG({ ...o, headers: r, body: a }).then(Ye),
    updateMessage: ({ messageId: a, ...s }) => zG({ ...o, headers: r, path: { id: a }, body: s }).then(Ye),
    getMessage: ({ messageId: a }) => BG({ ...o, headers: r, path: { id: a } }).then(Ye),
    deleteMessage: ({ messageId: a }) => FG({ ...o, headers: r, path: { id: a } }).then(Ye),
    createFile: (a) => XG({ ...o, headers: r, body: a }).then(Ye),
    createUser: (a) => b0({ ...o, headers: r, body: a }).then(Ye),
    getUser: () => KG({ ...o, headers: r }).then(Ye),
    updateUser: (a) => qG({ ...o, headers: r, body: a }).then(Ye),
    deleteUser: () => VG({ ...o, headers: r }).then(Ye),
    createEvent: (a) => YG({ ...o, headers: r, body: a }).then(Ye),
    getEvent: ({ eventId: a }) => GG({ ...o, headers: r, path: { id: a } }).then(Ye),
    addMessageFeedback: ({ messageId: a, ...s }) => HG({ ...o, headers: r, path: { id: a }, body: s }).then(Ye),
    removeMessageFeedback: ({ messageId: a }) => UG({ ...o, headers: r, path: { id: a } }).then(Ye),
    listenConversation: ({ conversationId: a }) => {
      let s = 0, l = null;
      const u = tY(), c = () => {
        l && l.close();
        const f = `${i}/conversations/${a}/listen`;
        l = new _a(f, {
          fetch: (p, d) => fetch(p, {
            ...d,
            headers: {
              ...d == null ? void 0 : d.headers,
              ...r,
              timeout: "60_000"
            }
          })
        }), l.onopen = () => u.emit("open"), l.onerror = (p) => {
          u.emit("error", p), s < 10 && (s++, setTimeout(() => c(), 3e3));
        }, l.onmessage = (p) => {
          const d = iY(p.data);
          u.emit(d.type, d.data);
        };
      };
      return c(), u.on;
    }
  };
}, iY = (e) => {
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
};
function oY({
  apiUrl: e = "https://webchat.botpress.cloud",
  clientId: t,
  storageKey: n,
  storageLocation: r,
  ...i
}) {
  const o = eA(n, r), a = o((T) => T.conversationId), s = o((T) => T.user), l = o((T) => T.setConversationId), u = o((T) => T.setUser), c = cr((T) => T.messages), f = cr((T) => T.saveMessage), p = cr((T) => T.updateMessage), d = cr((T) => T.fetchMessages), v = cr((T) => T.setMessages), h = cr((T) => T.clearMessages), g = cr((T) => T.isFetching), m = Go((T) => T.participants), b = Go((T) => T.setParticipants), w = Go((T) => T.addParticipant), C = Go((T) => T.removeParticipant), [S, E] = ge("connecting"), { isTyping: I, setIsTyping: N } = uG(), A = st(() => vx(), []), [O, D] = ge(i.conversationId), [U, L] = ge(i.user), [M, _] = ge(void 0), [z, q] = ge(!1), [H, P] = ge(void 0);
  if (vt(() => {
    P(void 0);
  }, [i.conversationId, i.user, t, e]), xx(async () => {
    if (!t) {
      P({ type: "configuration", message: fk });
      return;
    }
    if (!e || !e.startsWith("https://")) {
      P({ type: "configuration", message: dk });
      return;
    }
    async function T() {
      const j = i.user || s;
      let x = j, F = i.conversationId || a;
      const G = !!F;
      if (!x) {
        const { key: Q, user: Z } = await nY({ clientId: t, apiUrl: e });
        x = { userId: Z.id, userToken: Q };
      }
      const K = rY({
        userKey: x.userToken,
        clientId: t,
        apiUrl: e
      });
      if ((!F || !j) && (F = await xy(K), q(!0)), G) {
        const Q = await d({ client: K, conversationId: F });
        v(Q);
      }
      const { participants: Y } = await K.listParticipants({ conversationId: F });
      b(Y), _(K), D(F), l(F), L(x), u(x), E("connected");
    }
    try {
      await T();
    } catch (j) {
      h(), P(sl(j)), E("error");
    }
  }, [i.user, i.conversationId]), vt(() => {
    if (!M || !O) return;
    const T = M.listenConversation({ conversationId: O }), j = [
      T("open", () => {
        E("connected"), z && (M.createEvent({
          conversationId: O,
          payload: {
            type: "conversation_started",
            data: {}
          }
        }), A.emit("conversation"), q(!1));
      }),
      T("error", (x) => {
        P((F) => F || sl(x)), A.emit("error", new Error(`Connection to conversation lost: ${x.message}`)), E("error");
      }),
      T("message_created", (x) => {
        const F = dc(x);
        (U == null ? void 0 : U.userId) !== F.authorId && (N(!1), A.emit("isTyping", { isTyping: !1, timeout: 0 })), f(F), A.emit("message", F);
      }),
      T("message_status_changed", (x) => {
        x.newStatus === "processing" && (N(!0), A.emit("isTyping", { isTyping: !0, timeout: 5e3 }), p(x.message.metadata.clientMessageId, { status: x.newStatus }));
      }),
      T("participant_added", (x) => {
        w(x.participant), A.emit("participantAdded", x.participant);
      }),
      T("participant_removed", (x) => {
        C(x.participantId), A.emit("participantRemoved", x.participantId);
      }),
      T("webchat_visibility", (x) => A.emit("webchatVisibility", x.visibility)),
      T("webchat_config", (x) => A.emit("webchatConfig", x.config)),
      T("custom", (x) => A.emit("customEvent", x.event))
    ];
    return () => {
      j.forEach((x) => x());
    };
  }, [O, M]), H)
    return {
      clientState: "error",
      on: A.on,
      client: void 0,
      messages: [],
      conversationId: void 0,
      newConversation: async () => {
      },
      user: void 0,
      isTyping: void 0,
      isFetchingMessages: g,
      participants: [],
      error: H
    };
  if (S === "connecting" || !U || !O || !M)
    return {
      clientState: "connecting",
      on: A.on,
      client: void 0,
      messages: [],
      conversationId: void 0,
      newConversation: async () => {
      },
      user: void 0,
      isTyping: void 0,
      isFetchingMessages: g,
      participants: []
    };
  const y = {
    sendMessage: async (T) => {
      const j = d0(), x = {
        id: j,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        userId: U.userId,
        conversationId: O,
        payload: T,
        metadata: {
          clientMessageId: j,
          delivered: !1
        }
      }, F = dc(x);
      F.status = "pending", f(F), await M.createMessage({
        conversationId: O,
        payload: T,
        metadata: {
          clientMessageId: j
        }
      }).catch((G) => A.emit("error", G));
    },
    sendEvent: async (T) => {
      await M.createEvent({
        conversationId: O,
        payload: {
          type: "custom",
          data: T
        }
      });
    },
    uploadFile: async (T) => {
      const { size: j, name: x } = T, G = await ((V) => new Promise((ne, se) => {
        const fe = new FileReader();
        fe.onload = (oe) => {
          var pe;
          return ne((pe = oe.target) == null ? void 0 : pe.result);
        }, fe.onerror = (oe) => {
          var pe;
          return se((pe = oe.target) == null ? void 0 : pe.error);
        }, fe.readAsArrayBuffer(V);
      }))(T), K = /* @__PURE__ */ new Date();
      K.setDate(K.getDate() + 30);
      const {
        file: { uploadUrl: Y, contentType: Q, url: Z }
      } = await M.createFile({
        size: j,
        key: x,
        accessPolicies: ["public_content"],
        index: !1,
        tags: { source: "integration", integrationName: "webchat" },
        expiresAt: K.toISOString()
      });
      await fetch(Y, {
        method: "PUT",
        headers: {
          "x-amz-tagging": "public=true"
        },
        body: G
      });
      const X = Q.split("/").shift() ?? "", J = ck(X) ? X : "file";
      return { fileUrl: Z, name: x, type: J };
    },
    addMessageFeedback: async (T, j) => {
      p(T, { feedback: j.value }), await M.addMessageFeedback({
        messageId: T,
        ...j
      });
    },
    getUser: async () => {
      const { user: T } = await M.getUser();
      return T;
    },
    updateUser: async (T) => {
      const { user: j } = await M.updateUser({
        name: T.name,
        pictureUrl: T.pictureUrl,
        userData: T.data
      });
      return j;
    }
  };
  return {
    clientState: S,
    on: A.on,
    client: y,
    messages: c,
    conversationId: O,
    newConversation: async () => {
      try {
        h();
        const T = await xy(M);
        q(!0), D(T), l(T);
      } catch (T) {
        P(sl(T));
      }
    },
    user: s,
    isTyping: I,
    isFetchingMessages: g,
    participants: m,
    error: H
  };
}
const xy = async (e) => {
  const { conversation: t } = await e.createConversation();
  return t.id;
}, jX = ({
  clientId: e,
  storageKey: t,
  configuration: n,
  allowFileUpload: r,
  apiUrl: i,
  user: o,
  conversationId: a,
  ...s
}) => {
  const l = t || `bp-webchat-${e}`, {
    clientState: u,
    client: c,
    isFetchingMessages: f,
    isTyping: p,
    newConversation: d,
    messages: v,
    participants: h,
    user: g,
    error: m
  } = oY({
    clientId: e,
    apiUrl: i,
    conversationId: a,
    user: o,
    storageKey: l,
    storageLocation: n == null ? void 0 : n.storageLocation
  }), { sendMessage: b, uploadFile: w, addMessageFeedback: C } = c ?? {};
  return /* @__PURE__ */ $.jsx(
    lG,
    {
      configuration: n ?? {},
      user: g != null && g.userId ? { id: g == null ? void 0 : g.userId } : void 0,
      isLoading: f || u === "connecting",
      isTyping: p,
      connected: u === "connected" ? !0 : u === "disconnected" ? !1 : void 0,
      messages: v,
      sendMessage: b,
      uploadFile: w,
      addMessageFeedback: C,
      allowFileUpload: r,
      restartConversation: d,
      participants: h,
      error: m,
      ...s
    }
  );
};
function aY(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qn(e);
  k.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var sY = "DismissableLayer", uf = "dismissableLayer.update", lY = "dismissableLayer.pointerDownOutside", uY = "dismissableLayer.focusOutside", wy, E0 = k.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), k0 = k.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: o,
      onInteractOutside: a,
      onDismiss: s,
      ...l
    } = e, u = k.useContext(E0), [c, f] = k.useState(null), p = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, d] = k.useState({}), v = nr(t, (I) => f(I)), h = Array.from(u.layers), [g] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), m = h.indexOf(g), b = c ? h.indexOf(c) : -1, w = u.layersWithOutsidePointerEventsDisabled.size > 0, C = b >= m, S = dY((I) => {
      const N = I.target, A = [...u.branches].some((O) => O.contains(N));
      !C || A || (i == null || i(I), a == null || a(I), I.defaultPrevented || s == null || s());
    }, p), E = pY((I) => {
      const N = I.target;
      [...u.branches].some((O) => O.contains(N)) || (o == null || o(I), a == null || a(I), I.defaultPrevented || s == null || s());
    }, p);
    return aY((I) => {
      b === u.layers.size - 1 && (r == null || r(I), !I.defaultPrevented && s && (I.preventDefault(), s()));
    }, p), k.useEffect(() => {
      if (c)
        return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (wy = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), Sy(), () => {
          n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = wy);
        };
    }, [c, p, n, u]), k.useEffect(() => () => {
      c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), Sy());
    }, [c, u]), k.useEffect(() => {
      const I = () => d({});
      return document.addEventListener(uf, I), () => document.removeEventListener(uf, I);
    }, []), /* @__PURE__ */ $.jsx(
      fn.div,
      {
        ...l,
        ref: v,
        style: {
          pointerEvents: w ? C ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: _n(e.onFocusCapture, E.onFocusCapture),
        onBlurCapture: _n(e.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: _n(
          e.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
k0.displayName = sY;
var cY = "DismissableLayerBranch", fY = k.forwardRef((e, t) => {
  const n = k.useContext(E0), r = k.useRef(null), i = nr(t, r);
  return k.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ $.jsx(fn.div, { ...e, ref: i });
});
fY.displayName = cY;
function dY(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qn(e), r = k.useRef(!1), i = k.useRef(() => {
  });
  return k.useEffect(() => {
    const o = (s) => {
      if (s.target && !r.current) {
        let l = function() {
          C0(
            lY,
            n,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: s };
        s.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, a = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(a), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function pY(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Qn(e), r = k.useRef(!1);
  return k.useEffect(() => {
    const i = (o) => {
      o.target && !r.current && C0(uY, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function Sy() {
  const e = new CustomEvent(uf);
  document.dispatchEvent(e);
}
function C0(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? lj(i, o) : i.dispatchEvent(o);
}
var Uu = "focusScope.autoFocusOnMount", Hu = "focusScope.autoFocusOnUnmount", Ey = { bubbles: !1, cancelable: !0 }, hY = "FocusScope", $0 = k.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o,
    ...a
  } = e, [s, l] = k.useState(null), u = Qn(i), c = Qn(o), f = k.useRef(null), p = nr(t, (h) => l(h)), d = k.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  k.useEffect(() => {
    if (r) {
      let h = function(w) {
        if (d.paused || !s) return;
        const C = w.target;
        s.contains(C) ? f.current = C : Un(f.current, { select: !0 });
      }, g = function(w) {
        if (d.paused || !s) return;
        const C = w.relatedTarget;
        C !== null && (s.contains(C) || Un(f.current, { select: !0 }));
      }, m = function(w) {
        if (document.activeElement === document.body)
          for (const S of w)
            S.removedNodes.length > 0 && Un(s);
      };
      document.addEventListener("focusin", h), document.addEventListener("focusout", g);
      const b = new MutationObserver(m);
      return s && b.observe(s, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", h), document.removeEventListener("focusout", g), b.disconnect();
      };
    }
  }, [r, s, d.paused]), k.useEffect(() => {
    if (s) {
      Cy.add(d);
      const h = document.activeElement;
      if (!s.contains(h)) {
        const m = new CustomEvent(Uu, Ey);
        s.addEventListener(Uu, u), s.dispatchEvent(m), m.defaultPrevented || (vY(xY(T0(s)), { select: !0 }), document.activeElement === h && Un(s));
      }
      return () => {
        s.removeEventListener(Uu, u), setTimeout(() => {
          const m = new CustomEvent(Hu, Ey);
          s.addEventListener(Hu, c), s.dispatchEvent(m), m.defaultPrevented || Un(h ?? document.body, { select: !0 }), s.removeEventListener(Hu, c), Cy.remove(d);
        }, 0);
      };
    }
  }, [s, u, c, d]);
  const v = k.useCallback(
    (h) => {
      if (!n && !r || d.paused) return;
      const g = h.key === "Tab" && !h.altKey && !h.ctrlKey && !h.metaKey, m = document.activeElement;
      if (g && m) {
        const b = h.currentTarget, [w, C] = mY(b);
        w && C ? !h.shiftKey && m === C ? (h.preventDefault(), n && Un(w, { select: !0 })) : h.shiftKey && m === w && (h.preventDefault(), n && Un(C, { select: !0 })) : m === b && h.preventDefault();
      }
    },
    [n, r, d.paused]
  );
  return /* @__PURE__ */ $.jsx(fn.div, { tabIndex: -1, ...a, ref: p, onKeyDown: v });
});
$0.displayName = hY;
function vY(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Un(r, { select: t }), document.activeElement !== n) return;
}
function mY(e) {
  const t = T0(e), n = ky(t, e), r = ky(t.reverse(), e);
  return [n, r];
}
function T0(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function ky(e, t) {
  for (const n of e)
    if (!gY(n, { upTo: t })) return n;
}
function gY(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function yY(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Un(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && yY(e) && t && e.select();
  }
}
var Cy = bY();
function bY() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = $y(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = $y(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function $y(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function xY(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Vu = 0;
function wY() {
  k.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Ty()), document.body.insertAdjacentElement("beforeend", e[1] ?? Ty()), Vu++, () => {
      Vu === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Vu--;
    };
  }, []);
}
function Ty() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Ma = "right-scroll-bar-position", ja = "width-before-scroll-bar", SY = "with-scroll-bars-hidden", EY = "--removed-body-scroll-bar-size";
function Ku(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function kY(e, t) {
  var n = ge(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var CY = typeof window < "u" ? k.useLayoutEffect : k.useEffect, Oy = /* @__PURE__ */ new WeakMap();
function $Y(e, t) {
  var n = kY(null, function(r) {
    return e.forEach(function(i) {
      return Ku(i, r);
    });
  });
  return CY(function() {
    var r = Oy.get(n);
    if (r) {
      var i = new Set(r), o = new Set(e), a = n.current;
      i.forEach(function(s) {
        o.has(s) || Ku(s, null);
      }), o.forEach(function(s) {
        i.has(s) || Ku(s, a);
      });
    }
    Oy.set(n, e);
  }, [e]), n;
}
function TY(e) {
  return e;
}
function OY(e, t) {
  t === void 0 && (t = TY);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var a = t(o, r);
      return n.push(a), function() {
        n = n.filter(function(s) {
          return s !== a;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var a = n;
        n = [], a.forEach(o);
      }
      n = {
        push: function(s) {
          return o(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var a = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(o), a = n;
      }
      var l = function() {
        var c = a;
        a = [], c.forEach(o);
      }, u = function() {
        return Promise.resolve().then(l);
      };
      u(), n = {
        push: function(c) {
          a.push(c), u();
        },
        filter: function(c) {
          return a = a.filter(c), n;
        }
      };
    }
  };
  return i;
}
function IY(e) {
  e === void 0 && (e = {});
  var t = OY(null);
  return t.options = Jt({ async: !0, ssr: !1 }, e), t;
}
var O0 = function(e) {
  var t = e.sideCar, n = bx(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return k.createElement(r, Jt({}, n));
};
O0.isSideCarExport = !0;
function RY(e, t) {
  return e.useMedium(t), O0;
}
var I0 = IY(), qu = function() {
}, il = k.forwardRef(function(e, t) {
  var n = k.useRef(null), r = k.useState({
    onScrollCapture: qu,
    onWheelCapture: qu,
    onTouchMoveCapture: qu
  }), i = r[0], o = r[1], a = e.forwardProps, s = e.children, l = e.className, u = e.removeScrollBar, c = e.enabled, f = e.shards, p = e.sideCar, d = e.noIsolation, v = e.inert, h = e.allowPinchZoom, g = e.as, m = g === void 0 ? "div" : g, b = e.gapMode, w = bx(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), C = p, S = $Y([n, t]), E = Jt(Jt({}, w), i);
  return k.createElement(
    k.Fragment,
    null,
    c && k.createElement(C, { sideCar: I0, removeScrollBar: u, shards: f, noIsolation: d, inert: v, setCallbacks: o, allowPinchZoom: !!h, lockRef: n, gapMode: b }),
    a ? k.cloneElement(k.Children.only(s), Jt(Jt({}, E), { ref: S })) : k.createElement(m, Jt({}, E, { className: l, ref: S }), s)
  );
});
il.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
il.classNames = {
  fullWidth: ja,
  zeroRight: Ma
};
var PY = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function AY() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = PY();
  return t && e.setAttribute("nonce", t), e;
}
function DY(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function _Y(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var MY = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = AY()) && (DY(t, n), _Y(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, jY = function() {
  var e = MY();
  return function(t, n) {
    k.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, R0 = function() {
  var e = jY(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, NY = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Gu = function(e) {
  return parseInt(e || "", 10) || 0;
}, LY = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Gu(n), Gu(r), Gu(i)];
}, FY = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return NY;
  var t = LY(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, BY = R0(), Jr = "data-scroll-locked", zY = function(e, t, n, r) {
  var i = e.left, o = e.top, a = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(SY, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(Jr, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Ma, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(ja, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Ma, " .").concat(Ma, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(ja, " .").concat(ja, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Jr, `] {
    `).concat(EY, ": ").concat(s, `px;
  }
`);
}, Iy = function() {
  var e = parseInt(document.body.getAttribute(Jr) || "0", 10);
  return isFinite(e) ? e : 0;
}, WY = function() {
  k.useEffect(function() {
    return document.body.setAttribute(Jr, (Iy() + 1).toString()), function() {
      var e = Iy() - 1;
      e <= 0 ? document.body.removeAttribute(Jr) : document.body.setAttribute(Jr, e.toString());
    };
  }, []);
}, UY = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  WY();
  var o = k.useMemo(function() {
    return FY(i);
  }, [i]);
  return k.createElement(BY, { styles: zY(o, !t, i, n ? "" : "!important") });
}, cf = !1;
if (typeof window < "u")
  try {
    var va = Object.defineProperty({}, "passive", {
      get: function() {
        return cf = !0, !0;
      }
    });
    window.addEventListener("test", va, va), window.removeEventListener("test", va, va);
  } catch {
    cf = !1;
  }
var Mr = cf ? { passive: !1 } : !1, HY = function(e) {
  return e.tagName === "TEXTAREA";
}, P0 = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !HY(e) && n[t] === "visible")
  );
}, VY = function(e) {
  return P0(e, "overflowY");
}, KY = function(e) {
  return P0(e, "overflowX");
}, Ry = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = A0(e, r);
    if (i) {
      var o = D0(e, r), a = o[1], s = o[2];
      if (a > s)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, qY = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, GY = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, A0 = function(e, t) {
  return e === "v" ? VY(t) : KY(t);
}, D0 = function(e, t) {
  return e === "v" ? qY(t) : GY(t);
}, YY = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, XY = function(e, t, n, r, i) {
  var o = YY(e, window.getComputedStyle(t).direction), a = o * r, s = n.target, l = t.contains(s), u = !1, c = a > 0, f = 0, p = 0;
  do {
    var d = D0(e, s), v = d[0], h = d[1], g = d[2], m = h - g - o * v;
    (v || m) && A0(e, s) && (f += m, p += v), s instanceof ShadowRoot ? s = s.host : s = s.parentNode;
  } while (
    // portaled content
    !l && s !== document.body || // self content
    l && (t.contains(s) || t === s)
  );
  return (c && (Math.abs(f) < 1 || !i) || !c && (Math.abs(p) < 1 || !i)) && (u = !0), u;
}, ma = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Py = function(e) {
  return [e.deltaX, e.deltaY];
}, Ay = function(e) {
  return e && "current" in e ? e.current : e;
}, JY = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, QY = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, ZY = 0, jr = [];
function eX(e) {
  var t = k.useRef([]), n = k.useRef([0, 0]), r = k.useRef(), i = k.useState(ZY++)[0], o = k.useState(R0)[0], a = k.useRef(e);
  k.useEffect(function() {
    a.current = e;
  }, [e]), k.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var h = hc([e.lockRef.current], (e.shards || []).map(Ay), !0).filter(Boolean);
      return h.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), h.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = k.useCallback(function(h, g) {
    if ("touches" in h && h.touches.length === 2 || h.type === "wheel" && h.ctrlKey)
      return !a.current.allowPinchZoom;
    var m = ma(h), b = n.current, w = "deltaX" in h ? h.deltaX : b[0] - m[0], C = "deltaY" in h ? h.deltaY : b[1] - m[1], S, E = h.target, I = Math.abs(w) > Math.abs(C) ? "h" : "v";
    if ("touches" in h && I === "h" && E.type === "range")
      return !1;
    var N = Ry(I, E);
    if (!N)
      return !0;
    if (N ? S = I : (S = I === "v" ? "h" : "v", N = Ry(I, E)), !N)
      return !1;
    if (!r.current && "changedTouches" in h && (w || C) && (r.current = S), !S)
      return !0;
    var A = r.current || S;
    return XY(A, g, h, A === "h" ? w : C, !0);
  }, []), l = k.useCallback(function(h) {
    var g = h;
    if (!(!jr.length || jr[jr.length - 1] !== o)) {
      var m = "deltaY" in g ? Py(g) : ma(g), b = t.current.filter(function(S) {
        return S.name === g.type && (S.target === g.target || g.target === S.shadowParent) && JY(S.delta, m);
      })[0];
      if (b && b.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!b) {
        var w = (a.current.shards || []).map(Ay).filter(Boolean).filter(function(S) {
          return S.contains(g.target);
        }), C = w.length > 0 ? s(g, w[0]) : !a.current.noIsolation;
        C && g.cancelable && g.preventDefault();
      }
    }
  }, []), u = k.useCallback(function(h, g, m, b) {
    var w = { name: h, delta: g, target: m, should: b, shadowParent: tX(m) };
    t.current.push(w), setTimeout(function() {
      t.current = t.current.filter(function(C) {
        return C !== w;
      });
    }, 1);
  }, []), c = k.useCallback(function(h) {
    n.current = ma(h), r.current = void 0;
  }, []), f = k.useCallback(function(h) {
    u(h.type, Py(h), h.target, s(h, e.lockRef.current));
  }, []), p = k.useCallback(function(h) {
    u(h.type, ma(h), h.target, s(h, e.lockRef.current));
  }, []);
  k.useEffect(function() {
    return jr.push(o), e.setCallbacks({
      onScrollCapture: f,
      onWheelCapture: f,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", l, Mr), document.addEventListener("touchmove", l, Mr), document.addEventListener("touchstart", c, Mr), function() {
      jr = jr.filter(function(h) {
        return h !== o;
      }), document.removeEventListener("wheel", l, Mr), document.removeEventListener("touchmove", l, Mr), document.removeEventListener("touchstart", c, Mr);
    };
  }, []);
  var d = e.removeScrollBar, v = e.inert;
  return k.createElement(
    k.Fragment,
    null,
    v ? k.createElement(o, { styles: QY(i) }) : null,
    d ? k.createElement(UY, { gapMode: e.gapMode }) : null
  );
}
function tX(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const nX = RY(I0, eX);
var _0 = k.forwardRef(function(e, t) {
  return k.createElement(il, Jt({}, e, { ref: t, sideCar: nX }));
});
_0.classNames = il.classNames;
var rX = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Nr = /* @__PURE__ */ new WeakMap(), ga = /* @__PURE__ */ new WeakMap(), ya = {}, Yu = 0, M0 = function(e) {
  return e && (e.host || M0(e.parentNode));
}, iX = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = M0(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, oX = function(e, t, n, r) {
  var i = iX(t, Array.isArray(e) ? e : [e]);
  ya[n] || (ya[n] = /* @__PURE__ */ new WeakMap());
  var o = ya[n], a = [], s = /* @__PURE__ */ new Set(), l = new Set(i), u = function(f) {
    !f || s.has(f) || (s.add(f), u(f.parentNode));
  };
  i.forEach(u);
  var c = function(f) {
    !f || l.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (s.has(p))
        c(p);
      else
        try {
          var d = p.getAttribute(r), v = d !== null && d !== "false", h = (Nr.get(p) || 0) + 1, g = (o.get(p) || 0) + 1;
          Nr.set(p, h), o.set(p, g), a.push(p), h === 1 && v && ga.set(p, !0), g === 1 && p.setAttribute(n, "true"), v || p.setAttribute(r, "true");
        } catch (m) {
          console.error("aria-hidden: cannot operate on ", p, m);
        }
    });
  };
  return c(t), s.clear(), Yu++, function() {
    a.forEach(function(f) {
      var p = Nr.get(f) - 1, d = o.get(f) - 1;
      Nr.set(f, p), o.set(f, d), p || (ga.has(f) || f.removeAttribute(r), ga.delete(f)), d || f.removeAttribute(n);
    }), Yu--, Yu || (Nr = /* @__PURE__ */ new WeakMap(), Nr = /* @__PURE__ */ new WeakMap(), ga = /* @__PURE__ */ new WeakMap(), ya = {});
  };
}, aX = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = rX(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), oX(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, pp = "Dialog", [j0, NX] = kw(pp), [sX, In] = j0(pp), N0 = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    modal: a = !0
  } = e, s = k.useRef(null), l = k.useRef(null), [u = !1, c] = Cw({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ $.jsx(
    sX,
    {
      scope: t,
      triggerRef: s,
      contentRef: l,
      contentId: Ca(),
      titleId: Ca(),
      descriptionId: Ca(),
      open: u,
      onOpenChange: c,
      onOpenToggle: k.useCallback(() => c((f) => !f), [c]),
      modal: a,
      children: n
    }
  );
};
N0.displayName = pp;
var L0 = "DialogTrigger", F0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(L0, n), o = nr(t, i.triggerRef);
    return /* @__PURE__ */ $.jsx(
      fn.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": vp(i.open),
        ...r,
        ref: o,
        onClick: _n(e.onClick, i.onOpenToggle)
      }
    );
  }
);
F0.displayName = L0;
var lX = "DialogPortal", [LX, B0] = j0(lX, {
  forceMount: void 0
}), fs = "DialogOverlay", z0 = k.forwardRef(
  (e, t) => {
    const n = B0(fs, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = In(fs, e.__scopeDialog);
    return o.modal ? /* @__PURE__ */ $.jsx(Rs, { present: r || o.open, children: /* @__PURE__ */ $.jsx(uX, { ...i, ref: t }) }) : null;
  }
);
z0.displayName = fs;
var uX = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(fs, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ $.jsx(_0, { as: Zf, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ $.jsx(
        fn.div,
        {
          "data-state": vp(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), br = "DialogContent", W0 = k.forwardRef(
  (e, t) => {
    const n = B0(br, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = In(br, e.__scopeDialog);
    return /* @__PURE__ */ $.jsx(Rs, { present: r || o.open, children: o.modal ? /* @__PURE__ */ $.jsx(cX, { ...i, ref: t }) : /* @__PURE__ */ $.jsx(fX, { ...i, ref: t }) });
  }
);
W0.displayName = br;
var cX = k.forwardRef(
  (e, t) => {
    const n = In(br, e.__scopeDialog), r = k.useRef(null), i = nr(t, n.contentRef, r);
    return k.useEffect(() => {
      const o = r.current;
      if (o) return aX(o);
    }, []), /* @__PURE__ */ $.jsx(
      U0,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: _n(e.onCloseAutoFocus, (o) => {
          var a;
          o.preventDefault(), (a = n.triggerRef.current) == null || a.focus();
        }),
        onPointerDownOutside: _n(e.onPointerDownOutside, (o) => {
          const a = o.detail.originalEvent, s = a.button === 0 && a.ctrlKey === !0;
          (a.button === 2 || s) && o.preventDefault();
        }),
        onFocusOutside: _n(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), fX = k.forwardRef(
  (e, t) => {
    const n = In(br, e.__scopeDialog), r = k.useRef(!1), i = k.useRef(!1);
    return /* @__PURE__ */ $.jsx(
      U0,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          var a, s;
          (a = e.onCloseAutoFocus) == null || a.call(e, o), o.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), o.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (o) => {
          var l, u;
          (l = e.onInteractOutside) == null || l.call(e, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const a = o.target;
          ((u = n.triggerRef.current) == null ? void 0 : u.contains(a)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
        }
      }
    );
  }
), U0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...a } = e, s = In(br, n), l = k.useRef(null), u = nr(t, l);
    return wY(), /* @__PURE__ */ $.jsxs($.Fragment, { children: [
      /* @__PURE__ */ $.jsx(
        $0,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ $.jsx(
            k0,
            {
              role: "dialog",
              id: s.contentId,
              "aria-describedby": s.descriptionId,
              "aria-labelledby": s.titleId,
              "data-state": vp(s.open),
              ...a,
              ref: u,
              onDismiss: () => s.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ $.jsxs($.Fragment, { children: [
        /* @__PURE__ */ $.jsx(dX, { titleId: s.titleId }),
        /* @__PURE__ */ $.jsx(hX, { contentRef: l, descriptionId: s.descriptionId })
      ] })
    ] });
  }
), hp = "DialogTitle", H0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(hp, n);
    return /* @__PURE__ */ $.jsx(fn.h2, { id: i.titleId, ...r, ref: t });
  }
);
H0.displayName = hp;
var V0 = "DialogDescription", K0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(V0, n);
    return /* @__PURE__ */ $.jsx(fn.p, { id: i.descriptionId, ...r, ref: t });
  }
);
K0.displayName = V0;
var q0 = "DialogClose", G0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(q0, n);
    return /* @__PURE__ */ $.jsx(
      fn.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: _n(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
G0.displayName = q0;
function vp(e) {
  return e ? "open" : "closed";
}
var Y0 = "DialogTitleWarning", [FX, X0] = ej(Y0, {
  contentName: br,
  titleName: hp,
  docsSlug: "dialog"
}), dX = ({ titleId: e }) => {
  const t = X0(Y0), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return k.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, pX = "DialogDescriptionWarning", hX = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${X0(pX).contentName}}.`;
  return k.useEffect(() => {
    var o;
    const i = (o = e.current) == null ? void 0 : o.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, vX = N0, mX = F0, gX = z0, yX = W0, bX = H0, xX = K0, wX = G0;
function co({
  open: e,
  onOpenChange: t,
  children: n
}) {
  const { modal: r } = we;
  return /* @__PURE__ */ $.jsxs(vX, { open: e, onOpenChange: t, children: [
    /* @__PURE__ */ $.jsx(gX, { ...r == null ? void 0 : r.overlay }),
    n
  ] });
}
function SX({
  children: e,
  title: t,
  description: n,
  confirmButton: r,
  onConfirm: i,
  cancelButton: o,
  hideModal: a
}) {
  const { modal: s } = we;
  return /* @__PURE__ */ $.jsx($.Fragment, { children: /* @__PURE__ */ $.jsxs(yX, { ...s.dialog.container, children: [
    /* @__PURE__ */ $.jsx(bX, { ...s.dialog.title, children: t }),
    /* @__PURE__ */ $.jsx(xX, { ...s.dialog.description, children: n }),
    /* @__PURE__ */ $.jsx("div", { ...s.dialog.content.container, children: e }),
    /* @__PURE__ */ $.jsxs("div", { ...s.dialog.button.container, children: [
      /* @__PURE__ */ $.jsx("button", { ...s.dialog.button.confirm, type: "button", onClick: i, children: r }),
      /* @__PURE__ */ $.jsx("button", { ...s.dialog.button.cancel, type: "button", onClick: a, children: o })
    ] })
  ] }) });
}
co.Button = mX;
co.Close = wX;
co.Content = SX;
export {
  mf as Avatar,
  vk as BOT_IS_BLOCKED,
  ii as Block,
  AX as CONFIG_ACCESS_DENIED,
  lG as Chat,
  Y_ as Composer,
  Ew as Container,
  aG as ErrorState,
  ZM as Fab,
  wj as Header,
  dk as INVALID_API_URL,
  hk as INVALID_BOTPRESS_URL,
  pk as INVALID_CLIENT_ID,
  PX as INVALID_CONFIGURATION,
  RX as INVALID_CONFIG_URL,
  TX as MISSING_API_URL,
  OX as MISSING_BOT_ID,
  fk as MISSING_CLIENT_ID,
  IX as MISSING_CONFIG_URL,
  _v as Message,
  p0 as MessageList,
  co as Modal,
  Pv as ModalProvider,
  yk as NETWORK_ERROR,
  gk as NOT_A_PARTICIPANT,
  mk as QUOTA_EXCEEDED,
  bj as RestartConversationButton,
  QM as StylesheetProvider,
  Pw as TypingIndicator,
  jX as Webchat,
  ZE as enrichMessage,
  uk as fileTypes,
  sk as generateThemeStylesheet,
  eA as getUseWebchatClientStore,
  sl as handleIntegrationError,
  qP as integrationMessagePayloadToBlockPayload,
  dc as integrationMessageToBlockMessage,
  ck as isFileType,
  O_ as renderers,
  oY as useWebchat,
  Mf as useWebchatStore,
  we as webchatClasses
};
