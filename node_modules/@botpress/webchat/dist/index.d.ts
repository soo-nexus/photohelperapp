import { AddMessageFeedbackBody } from '@botpress/webchat-client';
import { ClassAttributes } from 'react';
import { Client } from '@botpress/webchat-client';
import { ComponentProps } from 'react';
import { ComponentPropsWithRef } from 'react';
import { CSSProperties } from 'react';
import * as Dialog from '@radix-ui/react-dialog';
import { EventEmitter } from '@bpinternal/shared';
import type { FC } from 'react';
import { ForwardRefExoticComponent } from 'react';
import { HTMLAttributes } from 'react';
import { JSX as JSX_2 } from 'react';
import { JSX as JSX_3 } from 'react/jsx-runtime';
import { LatestWebchatConfig } from '@bpinternal/shared';
import { LatestWebchatTheme } from '@bpinternal/shared';
import { MemoExoticComponent } from 'react';
import { Message as Message_2 } from '@botpress/webchat-client';
import { PersistOptions } from 'zustand/middleware';
import { ReactNode } from 'react';
import { Ref } from 'react';
import { RefAttributes } from 'react';
import { RefObject } from 'react';
import { RotateCcw } from 'lucide-react';
import { StoreApi } from 'zustand';
import { UseBoundStore } from 'zustand';
import { User } from '@botpress/webchat-client';
import { UserCredentials } from '@botpress/webchat-client';

declare type AnyEvent = ValueOf<{
    [K in keyof WebchatEvents]: {
        type: K;
        payload: WebchatEvents[K];
    };
}>;

export declare type AudioBlock = {
    type: 'audio';
    url: string;
};

export declare const Avatar: ForwardRefExoticComponent<Omit<AvatarProps, "ref"> & RefAttributes<HTMLSpanElement>>;

declare type AvatarProps = {
    userId?: string;
    src?: string;
    container: {
        className?: string;
    };
    image: {
        className?: string;
    };
    fallback: {
        className?: string;
    };
} & Omit<ComponentPropsWithRef<'span'>, 'className' | 'style'>;

export declare type BlocIntegrationMessageItems = Extract<IntegrationMessage['payload'], {
    type: 'bloc';
}>['items'];

export declare const Block: <T extends GenericBlock["type"]>({ block, renderers, ...props }: BlockProps<T>) => JSX_2.Element;

export declare type BlockMessage<T = GenericBlock> = {
    id: string;
    timestamp: Date;
    block: T;
    conversationId?: string;
    authorId?: string;
    disableInput?: boolean;
    status?: 'pending' | 'processing' | 'processed' | 'failed' | 'skipped';
    metadata?: {
        clientMessageId?: string;
        delivered?: boolean;
        [k: string]: any;
    };
    feedback?: Feedback['value'];
};

declare type BlockMessagePayload = {
    payload: GenericBlock;
    disableInput?: boolean;
};

export declare type BlockObjects = {
    [T in GenericBlock['type']]: Extract<GenericBlock, {
        type: T;
    }> & CommonBlockProps;
};

declare type BlockProps<T extends GenericBlock['type']> = {
    block: BlockObjects[T];
    renderers?: Partial<Renderers>;
};

export declare const BOT_IS_BLOCKED = "This bot is currently blocked or disabled.";

declare type BoundWebchatClientStore = ReturnType<typeof createWebchatClientStore>;

export declare type BubbleBlock = {
    type: 'bubble';
    block: GenericBlock;
};

export declare type BubbleOf<T extends GenericBlock> = Omit<BubbleBlock, 'block'> & {
    block: T;
};

export declare type ButtonBlock = {
    type: 'button';
    variant: 'action' | 'link';
    reusable?: boolean;
    groupId?: string;
    text: string;
    buttonValue: string;
};

declare type ByType<M extends {
    type: string;
}> = {
    [Type in M['type']]: Extract<M, {
        type: Type;
    }>;
};

export declare type CarouselBlock = {
    type: 'carousel';
    blocks: GenericBlock[];
};

export declare const Chat: ({ connected, configuration, isTyping, messages, user, isLoading, renderers, isReadOnly, disableComposer, allowFileUpload, error, participants, closeWindow, sendMessage, uploadFile, addMessageFeedback, restartConversation, ...props }: Props) => JSX_3.Element;

export declare type ColumnBlock = {
    type: 'column';
    blocks: GenericBlock[];
    horizontalAlignment?: 'left' | 'center' | 'right';
    verticalAlignment?: 'top' | 'center' | 'bottom' | 'stretch';
};

export declare type ColumnOf<T extends GenericBlock> = Omit<ColumnBlock, 'blocks'> & {
    blocks: T[];
};

export declare type CommonBlockProps = Pick<RichBlockMessage, 'direction' | 'sender' | 'timestamp' | 'feedback'> & {
    messageId: string;
    metadata?: Record<string, any>;
    isReadOnly?: boolean;
    status?: BlockMessage['status'];
    sendMessage?: (payload: IntegrationMessage['payload']) => void;
    addMessageFeedback?: (messageId: string, feedback: Feedback) => void;
};

export declare type ComposableIntegrationMessagePayload = Extract<IntegrationMessage['payload'], ToPayloadType<ComposableIntegrationMessageTypes>>;

declare type ComposableIntegrationMessageTypes = 'audio' | 'bloc' | 'file' | 'image' | 'location' | 'markdown' | 'text' | 'video';

export declare const Composer: MemoExoticComponent<ForwardRefExoticComponent<Omit<Props_3, "ref"> & RefAttributes<HTMLDivElement>>>;

export declare const CONFIG_ACCESS_DENIED = "Access denied to configuration file. Please check your credentials or your configuration URL and try again.";

declare type configuration = ComponentProps<typeof Chat>['configuration'];

export declare const Container: {
    ({ children, className, connected, uploadFile, allowFileUpload, ...props }: Props_4): JSX_3.Element;
    displayName: string;
};

declare const createWebchatClientStore: (storeName: string, storageLocation?: StorageLocation) => UseBoundStore<Omit<Omit<StoreApi<WebchatClientStore>, "setState"> & {
    setState<A extends string | {
        type: string;
    }>(partial: WebchatClientStore | Partial<WebchatClientStore> | ((state: WebchatClientStore) => WebchatClientStore | Partial<WebchatClientStore>), replace?: boolean | undefined, action?: A | undefined): void;
}, "persist"> & {
    persist: {
        setOptions: (options: Partial<PersistOptions<WebchatClientStore, unknown>>) => void;
        clearStorage: () => void;
        rehydrate: () => Promise<void> | void;
        hasHydrated: () => boolean;
        onHydrate: (fn: (state: WebchatClientStore) => void) => () => void;
        onFinishHydration: (fn: (state: WebchatClientStore) => void) => () => void;
        getOptions: () => Partial<PersistOptions<WebchatClientStore, unknown>>;
    };
}>;

export declare type CustomBlock = {
    type: 'custom';
    url: string;
    name: string;
};

export declare type Dimensions = {
    width: number;
    height: number;
};

export declare type DropdownBlock = {
    label?: string;
    type: 'dropdown';
    reusable?: boolean;
    options: {
        label: string;
        value: string;
    }[];
};

export declare function enrichMessage(messages: BlockMessage[], participants: User[], currentUserId: string, botName?: string, botAvatar?: string): RichBlockMessage[];

declare type ErrorProps = {
    error: WebchatError;
};

export declare function ErrorState({ error }: ErrorProps): JSX_3.Element;

declare type Events = WebchatEvents & {
    '*': AnyEvent;
};

declare type Events_2 = {
    [key: string]: string;
};

export declare const Fab: ForwardRefExoticComponent<Omit<ClassAttributes<HTMLDivElement> & HTMLAttributes<HTMLDivElement> & {
    imgUrl?: string;
}, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type Feedback = AddMessageFeedbackBody;

export declare type FileBlock = {
    type: 'file';
    url: string;
    title?: string;
};

export declare type FileType = (typeof fileTypes)[number];

export declare const fileTypes: readonly ["audio", "file", "image", "video"];

export declare function generateThemeStylesheet(theme: LatestWebchatTheme): string;

export declare type GenericBlock = AudioBlock | BubbleBlock | ButtonBlock | CarouselBlock | ColumnBlock | DropdownBlock | FileBlock | ImageBlock | LocationBlock | RowBlock | TextBlock | VideoBlock | CustomBlock;

export declare const getUseWebchatClientStore: typeof WebchatClientStores.getInstance;

export declare const handleIntegrationError: (error: unknown) => WebchatError;

export declare const Header: ({ defaultOpen, closeWindow, configuration, restartConversation, ...props }: HeaderProps) => JSX_3.Element;

declare type HeaderProps = {
    defaultOpen?: boolean;
    open?: boolean;
    disabled?: boolean;
    onOpenChange?(open: boolean): void;
    restartConversation?: () => void;
    closeWindow?: () => void;
    configuration: Pick<LatestWebchatConfig, 'email' | 'phone' | 'privacyPolicy' | 'website' | 'termsOfService' | 'botAvatar' | 'botDescription' | 'botName'>;
};

export declare type HookResult<T> = {
    data: Simplify<T> | undefined;
    isLoading: boolean;
    error: WebchatError | undefined;
};

export declare type ImageBlock = {
    type: 'image';
    orientation?: 'portrait' | 'landscape' | 'square' | 'auto';
    url: string;
};

export declare type IntegrationMessage = Message_2;

export declare type IntegrationMessagePayloadByType = ByType<IntegrationMessage['payload']>;

export declare const integrationMessagePayloadToBlockPayload: (message: IntegrationMessage["payload"]) => BlockMessagePayload;

export declare function integrationMessageToBlockMessage(message: IntegrationMessage): BlockMessage;

declare type IntegrationMessageTypes = IntegrationMessage['payload']['type'];

export declare const INVALID_API_URL = "Invalid API URL. Please use a valid API URL.";

export declare const INVALID_BOTPRESS_URL = "Invalid URL. Please make sure your client ID and API URL are valid";

export declare const INVALID_CLIENT_ID = "Invalid Client ID. Please use a valid Botpress Client ID.";

export declare const INVALID_CONFIG_URL = "Invalid config URL. Please make sure your config URL is valid";

export declare const INVALID_CONFIGURATION = "Invalid webchat configuration, please make sure your config file is valid";

export declare const isFileType: (type: string) => type is FileType;

export declare type LocationBlock = {
    type: 'location';
    latitude: number;
    longitude: number;
    title?: string;
};

export declare const Message: MemoExoticComponent<ForwardRefExoticComponent<{
    children?: ReactNode;
    renderers?: Partial<Renderers>;
    sendMessage?: (payload: IntegrationMessage["payload"]) => void;
    addMessageFeedback?: (messageId: string, feedback: Feedback) => void;
    isReadOnly?: boolean;
    isLastDeliveredMessage?: boolean;
} & BlockMessage<GenericBlock> & {
    direction: "incoming" | "outgoing" | "system";
    sender: {
        name: string;
        avatar?: string;
    };
} & RefAttributes<HTMLDivElement>>>;

export declare const MessageList: MemoExoticComponent<({ className, messages, isTyping, headerMessage, renderers, botAvatar, botDescription, botName, sendMessage, addMessageFeedback, showMarquee, ...props }: ComponentProps<"ul"> & MessageListProps) => JSX_3.Element>;

declare type MessageListProps = {
    messages?: RichBlockMessage[];
    isTyping?: boolean;
    headerMessage?: string;
    renderers?: Partial<Renderers>;
    botAvatar?: string;
    botDescription?: string;
    botName?: string;
    sendMessage?: (payload: IntegrationMessage['payload']) => void;
    addMessageFeedback?: (messageId: string, feedback: Feedback) => void;
    showMarquee?: boolean;
};

export declare const MISSING_API_URL = "The API url is required to initialize the webchat.";

export declare const MISSING_BOT_ID = "The Bot ID is required to initialize the webchat.";

export declare const MISSING_CLIENT_ID = "The Client ID is required to initialize the webchat.";

export declare const MISSING_CONFIG_URL = "No config URL provided.";

export declare function Modal({ open, onOpenChange, children, }: {
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
    children: ReactNode;
}): JSX_3.Element;

export declare namespace Modal {
    var Button: ForwardRefExoticComponent<Dialog.DialogTriggerProps & RefAttributes<HTMLButtonElement>>;
    var Close: ForwardRefExoticComponent<Dialog.DialogCloseProps & RefAttributes<HTMLButtonElement>>;
    var Content: typeof ModalContent;
}

declare function ModalContent({ children, title, description, confirmButton, onConfirm, cancelButton, hideModal, }: {
    title: string;
    description: string;
    confirmButton: string;
    onConfirm: () => void;
    cancelButton: string;
    hideModal: () => void;
    children: ReactNode;
}): JSX_3.Element;

export declare type ModalProps = {
    title: string | null;
    content: ReactNode | null;
};

export declare const ModalProvider: ({ children }: {
    children: ReactNode;
}) => JSX_3.Element;

export declare const NETWORK_ERROR = "Please check your internet connection and refresh the page.";

export declare const NOT_A_PARTICIPANT = "You are not a participant of this conversation, please clear your local storage.";

export declare type Options = {
    timeout?: number;
};

export declare type Props = {
    className?: string;
    renderers?: Partial<Renderers>;
    configuration: LatestWebchatConfig;
    messages: BlockMessage[];
    participants: User[];
    connected?: boolean;
    disableComposer?: boolean;
    isReadOnly?: boolean;
    isLoading?: boolean;
    isTyping?: boolean;
    lastTypingHeartbeat?: Date | null;
    allowFileUpload?: boolean;
    clientId?: string;
    closeWindow?: () => void;
    restartConversation?: () => void;
    user?: {
        id: string;
    } & Record<string, unknown>;
    sendMessage?: (payload: IntegrationMessage['payload']) => Promise<void>;
    uploadFile?: (file: File) => Promise<{
        fileUrl: string;
        name: string;
        type: FileType;
    }>;
    addMessageFeedback?: (messageId: string, feedback: Feedback) => void;
    error?: WebchatError;
};

declare type Props_2 = {
    user?: UserCredentials;
    conversationId?: string;
    clientId: string;
    apiUrl?: string;
    sseTimeout?: number;
    storageKey?: string;
    storageLocation?: StorageLocation;
};

declare type Props_3 = ComponentProps<'div'> & {
    inputRef?: Ref<HTMLTextAreaElement>;
    disableComposer?: boolean;
    isReadOnly?: boolean;
    allowFileUpload?: boolean;
    connected?: boolean;
    sendMessage?: (payload: IntegrationMessage['payload']) => void;
    uploadFile?: (file: File) => Promise<{
        fileUrl: string;
        name: string;
        type: FileType;
    }>;
} & Pick<LatestWebchatConfig, 'composerPlaceholder' | 'footer'>;

declare type Props_4 = ComponentProps<'div'> & {
    connected?: boolean;
    uploadFile?: (file: File) => Promise<{
        fileUrl: string;
        name: string;
        type: FileType;
    }>;
    allowFileUpload?: boolean;
};

declare type Props_5 = {
    restartConversation: () => void;
} & ComponentProps<typeof RotateCcw>;

declare type Props_6 = {
    clientId: string;
    apiUrl?: string;
    storageKey?: string;
    user?: UserCredentials;
    conversationId?: string;
    configuration?: configuration;
} & Pick<ComponentProps<typeof Chat>, 'allowFileUpload' | 'renderers'> & ComponentProps<'div'>;

declare type Props_7 = Partial<LatestWebchatTheme>;

export declare const QUOTA_EXCEEDED = "This bot has temporarily paused. Please check back later.";

export declare type Renderers = {
    [T in GenericBlock['type']]: FC<BlockObjects[T]>;
};

export declare const renderers: Renderers;

export declare const RestartConversationButton: ({ restartConversation, ...props }: Props_5) => JSX_3.Element;

export declare type RichBlockMessage<T = GenericBlock> = BlockMessage<T> & {
    direction: 'incoming' | 'outgoing' | 'system';
    sender: {
        name: string;
        avatar?: string;
    };
};

export declare type RowBlock = {
    type: 'row';
    blocks: GenericBlock[];
    horizontalAlignment?: 'left' | 'center' | 'right' | 'stretch';
    verticalAlignment?: 'top' | 'center' | 'bottom';
};

export declare type RowOf<T extends GenericBlock> = Omit<RowBlock, 'blocks'> & {
    blocks: T[];
};

declare type ScopedClient = {
    sendMessage: (payload: IntegrationMessage['payload']) => Promise<void>;
    sendEvent: (event: Record<string, any>) => Promise<void>;
    uploadFile: (file: File) => Promise<{
        fileUrl: string;
        name: string;
        type: FileType;
    }>;
    addMessageFeedback: (messageId: string, feedback: Feedback) => Promise<void>;
    getUser: () => Promise<UserResponse>;
    updateUser: (user: UserProfile) => Promise<User>;
};

export declare type Simplify<T> = {
    [KeyType in keyof T]: T[KeyType];
} & {};

declare type StorageLocation = 'sessionStorage' | 'localStorage';

export declare type StyleOptions = {
    className?: string;
    style?: CSSProperties;
};

export declare const StylesheetProvider: ({ color, fontFamily, radius, themeMode, variant, headerVariant }: Props_7) => JSX_3.Element;

export declare type TextBlock = {
    type: 'text';
    text: string;
    value?: string;
};

declare type ToPayloadType<T extends IntegrationMessageTypes> = {
    [K in T]: {
        type: K;
    };
}[T];

export declare const TypingIndicator: MemoExoticComponent<({ ...props }: ComponentProps<"div">) => JSX_3.Element>;

export declare type UseImageSizeResult = [Dimensions | null, {
    loading: boolean;
    error: string | null;
}];

declare type UserProfile = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

declare type UserResponse = Awaited<ReturnType<Client['getUser']>>['user'];

export declare function useWebchat({ apiUrl, clientId, storageKey, storageLocation, ...props }: Props_2): UseWebchatReturn;

declare type UseWebchatReturn = {
    clientState: 'connected' | 'disconnected' | 'error';
    on: EventEmitter<Events>['on'];
    client: ScopedClient;
    messages: BlockMessage[];
    conversationId: string;
    newConversation: () => Promise<void>;
    isFetchingMessages: boolean;
    user?: UserCredentials;
    isTyping: boolean;
    error?: WebchatError;
    participants: User[];
} | {
    clientState: 'connecting' | 'error';
    on: EventEmitter<Events>['on'];
    client: undefined;
    messages: BlockMessage[];
    conversationId: undefined;
    newConversation: () => Promise<void>;
    isFetchingMessages: boolean;
    user: undefined;
    isTyping: undefined;
    error?: WebchatError;
    participants: User[];
};

export declare const useWebchatStore: UseBoundStore<Omit<StoreApi<WebchatStore>, "setState"> & {
    setState<A extends string | {
        type: string;
    }>(partial: WebchatStore | Partial<WebchatStore> | ((state: WebchatStore) => WebchatStore | Partial<WebchatStore>), replace?: boolean | undefined, action?: A | undefined): void;
}>;

declare type ValueOf<T> = T[keyof T];

export declare type VideoBlock = {
    type: 'video';
    url: string;
};

export declare const Webchat: ({ clientId, storageKey, configuration, allowFileUpload, apiUrl, user, conversationId, ...props }: Props_6) => JSX_3.Element;

export declare const webchatClasses: {
    readonly container: {
        readonly className: "bpReset bpContainer bpFont";
        readonly dropzone: {
            readonly overlay: {
                readonly className: "bpDropzoneOverlay";
            };
            readonly container: {
                readonly className: "bpDropzoneContainer";
            };
        };
    };
    readonly loader: {
        readonly className: "bpReset bpLoader";
    };
    readonly modal: {
        readonly overlay: {
            readonly className: "bpModalOverlay";
        };
        readonly dialog: {
            readonly container: {
                readonly className: "bpReset bpModalContainer";
            };
            readonly title: {
                readonly className: "bpModalTitle";
            };
            readonly description: {
                readonly className: "bpModalDescription";
            };
            readonly content: {
                readonly container: {
                    readonly className: "bpModalContentContainer";
                };
                readonly textarea: {
                    readonly className: "bpModalContentTextArea";
                };
            };
            readonly button: {
                readonly container: {
                    readonly className: "bpModalButtonContainer";
                };
                readonly confirm: {
                    readonly className: "bpModalButtonConfirm";
                };
                readonly cancel: {
                    readonly className: "bpModalButtonCancel";
                };
            };
        };
    };
    readonly fab: {
        readonly container: {
            readonly className: "bpReset bpFabContainer";
        };
        readonly icon: {
            readonly className: "bpFabIcon";
        };
        readonly image: {
            readonly className: "bpFabImage";
        };
    };
    readonly notification: {
        readonly container: {
            readonly className: "bpReset bpNotificationContainer";
        };
        readonly title: {
            readonly className: "bpNotificationTitle";
        };
        readonly description: {
            readonly className: "bpNotificationDescription";
        };
        readonly icon: {
            readonly className: "bpNotificationIcon";
        };
        readonly closeIcon: {
            readonly className: "bpNotificationCloseIcon";
        };
    };
    readonly header: {
        readonly container: {
            readonly className: "bpReset bpHeaderContainer bpFont";
        };
        readonly content: {
            readonly container: {
                readonly className: "bpReset bpHeaderContentContainer";
            };
            readonly title: {
                readonly className: "bpHeaderContentTitle";
            };
            readonly description: {
                readonly className: "bpHeaderContentDescription";
            };
            readonly avatar: {
                readonly container: {
                    readonly className: "bpReset bpHeaderContentAvatarContainer";
                };
                readonly image: {
                    readonly className: "bpHeaderContentAvatarImage";
                };
                readonly fallback: {
                    readonly className: "bpHeaderContentAvatarFallback";
                };
            };
            readonly actions: {
                readonly container: {
                    readonly className: "bpReset bpHeaderContentActionsContainer";
                };
                readonly icons: {
                    readonly className: "bpHeaderContentActionsIcons";
                };
            };
        };
        readonly expandedContent: {
            readonly container: {
                readonly className: "bpReset bpHeaderExpandedContentContainer";
            };
            readonly descriptionItems: {
                readonly container: {
                    readonly className: "bpReset bpHeaderExpandedContentDescriptionItemsContainer";
                };
                readonly icon: {
                    readonly className: "bpHeaderExpandedContentDescriptionItemsIcon";
                };
                readonly text: {
                    readonly className: "bpHeaderExpandedContentDescriptionItemsText";
                };
                readonly link: {
                    readonly className: "bpHeaderExpandedContentDescriptionItemsLink";
                };
            };
            readonly group: {
                readonly className: "bpHeaderExpandedContentGroup";
            };
        };
        readonly newConversationIcon: {
            readonly className: "bpHeaderNewConversationIcon";
        };
    };
    readonly composer: {
        readonly wrapper: {
            readonly className: "bpReset bpComposerWrapper";
        };
        readonly container: {
            readonly className: "bpReset bpComposerContainer bpFont";
        };
        readonly footer: {
            readonly className: "bpComposerFooter";
        };
        readonly inputContainer: {
            readonly className: "bpComposerInputContainer";
        };
        readonly input: {
            readonly className: "bpComposerInput";
        };
        readonly sendbutton: {
            readonly className: "bpComposerSendButton";
        };
        readonly uploadButton: {
            readonly className: "bpComposerUploadButton";
        };
        readonly voiceButton: {
            readonly className: "bpComposerVoiceButton";
        };
        readonly fileContainer: {
            readonly className: "bpComposerFileContainer";
        };
        readonly fileWidget: {
            readonly container: {
                readonly className: "bpComposerFileAttachement";
            };
            readonly loader: {
                readonly className: "bpComposerFileLoader";
            };
            readonly fileIcon: {
                readonly container: {
                    readonly className: "bpComposerFileIconWrapper";
                };
                readonly icon: {
                    readonly className: "bpComposerFileIcon";
                };
            };
            readonly metadata: {
                readonly container: {
                    readonly className: "bpComposerFileMetadata";
                };
                readonly name: {
                    readonly className: "bpComposerFileName";
                };
                readonly type: {
                    readonly className: "bpComposerFileExtension";
                };
            };
            readonly removeIcon: {
                readonly className: "bpComposerFileRemoveIcon";
            };
            readonly errorIcon: {
                readonly className: "bpComposerFileErrorIcon";
            };
            readonly previewImage: {
                readonly className: "bpComposerFilePreviewImage";
            };
        };
    };
    readonly messageList: {
        readonly scrollDownButton: {
            readonly className: "bpMessageListScrollDownButton";
        };
        readonly container: {
            readonly className: "bpReset bpMessageListContainer bpFont";
        };
        readonly viewPort: {
            readonly className: "bpMessageListViewport";
        };
        readonly marquee: {
            readonly container: {
                readonly className: "bpReset bpMessageListMarqueeContainer";
            };
            readonly content: {
                readonly className: "bpMessageListMarqueeContent";
            };
            readonly title: {
                readonly className: "bpMessageListMarqueeTitle";
            };
            readonly description: {
                readonly className: "bpMessageListMarqueeDescription";
            };
            readonly avatar: {
                readonly container: {
                    readonly className: "bpReset bpMessageListMarqueeAvatarContainer";
                };
                readonly image: {
                    readonly className: "bpMessageListMarqueeAvatarImage";
                };
                readonly fallback: {
                    readonly className: "bpMessageListMarqueeAvatarFallback";
                };
            };
        };
        readonly headerMessage: {
            readonly className: "bpMessageListHeaderMessage";
        };
    };
    readonly message: {
        readonly container: {
            readonly className: "bpReset bpMessageContainer";
        };
        readonly avatar: {
            readonly container: {
                readonly className: "bpReset bpMessageAvatarContainer";
            };
            readonly image: {
                readonly className: "bpMessageAvatarImage";
            };
            readonly fallback: {
                readonly className: "bpMessageAvatarFallback";
            };
        };
        readonly deliveryStatus: {
            readonly className: "bpMessageDeliveryStatus";
        };
        readonly blocks: {
            readonly text: {
                readonly heading1: {
                    readonly className: "bpMessageBlocksTextHeading1";
                };
                readonly heading2: {
                    readonly className: "bpMessageBlocksTextHeading2";
                };
                readonly heading3: {
                    readonly className: "bpMessageBlocksTextHeading3";
                };
                readonly heading4: {
                    readonly className: "bpMessageBlocksTextHeading4";
                };
                readonly unorderedList: {
                    readonly className: "bpMessageBlocksTextUnorderedList";
                };
                readonly orderedList: {
                    readonly className: "bpMessageBlocksTextOrderedList";
                };
                readonly listItem: {
                    readonly className: "bpMessageBlocksTextListItem";
                };
                readonly link: {
                    readonly className: "bpMessageBlocksTextLink";
                };
                readonly italic: {
                    readonly className: "bpMessageBlocksTextItalic";
                };
                readonly bold: {
                    readonly className: "bpMessageBlocksTextBold";
                };
                readonly text: {
                    readonly className: "bpMessageBlocksTextText";
                };
                readonly image: {
                    readonly className: "bpMessageBlocksTextImage";
                };
                readonly horizontalRule: {
                    readonly className: "bpMessageBlocksTextHorizontalRule";
                };
                readonly lineBreak: {
                    readonly className: "bpMessageBlocksTextLineBreak";
                };
                readonly input: {
                    readonly className: "bpMessageBlocksTextInput";
                };
                readonly codeBlockContainer: {
                    readonly className: "bpMessageBlocksTextCodeBlockContainer";
                };
                readonly codeBlockTitle: {
                    readonly className: "bpMessageBlocksTextCodeBlockTitle";
                };
                readonly codeBlockCopyIcon: {
                    readonly className: "bpMessageBlocksTextCodeBlockCopyIcon";
                };
                readonly codeBlock: {
                    readonly className: "bpMessageBlocksTextCodeBlock";
                };
                readonly code: {
                    readonly className: "bpMessageBlocksTextCode";
                };
                readonly tableContainer: {
                    readonly className: "bpMessageBlocksTextTableContainer";
                };
                readonly table: {
                    readonly className: "bpMessageBlocksTextTable";
                };
                readonly tableHeader: {
                    readonly className: "bpMessageBlocksTextTableHeader";
                };
                readonly tableData: {
                    readonly className: "bpMessageBlocksTextTableData";
                };
                readonly tableRow: {
                    readonly className: "bpMessageBlocksTextTableRow";
                };
            };
            readonly audio: {
                readonly className: "bpMessageBlocksAudio";
            };
            readonly image: {
                readonly image: {
                    readonly className: "bpMessageBlocksImageImage";
                };
                readonly placeholder: {
                    readonly className: "bpMessageBlocksImagePlaceholder";
                };
            };
            readonly video: {
                readonly className: "bpMessageBlocksVideo";
            };
            readonly location: {
                readonly container: {
                    readonly className: "bpMessageBlocksLocationContainer";
                };
                readonly title: {
                    readonly className: "bpMessageBlocksLocationTitle";
                };
                readonly icon: {
                    readonly className: "bpMessageBlocksLocationIcon";
                };
            };
            readonly file: {
                readonly container: {
                    readonly className: "bpMessageBlocksFileContainer";
                };
                readonly title: {
                    readonly className: "bpMessageBlocksFileTitle";
                };
                readonly icon: {
                    readonly className: "bpMessageBlocksFileIcon";
                };
            };
            readonly row: {
                readonly className: "bpMessageBlocksRow";
            };
            readonly column: {
                readonly className: "bpMessageBlocksColumn";
            };
            readonly bubble: {
                readonly container: {
                    readonly className: "bpMessageBlocksBubble";
                };
                readonly feedbackContainer: {
                    readonly className: "bpMessageBlocksBubbleFeedbackContainer";
                };
                readonly feedbackIcon: {
                    readonly className: "bpMessageBlocksBubbleFeedbackIcon";
                };
            };
            readonly carousel: {
                readonly container: {
                    readonly className: "bpMessageBlocksCarouselContainer";
                };
                readonly slidesContainer: {
                    readonly className: "bpMessageBlocksCarouselSlidesContainer";
                };
                readonly backButton: {
                    readonly className: "bpMessageBlocksCarouselBackButton";
                };
                readonly nextButton: {
                    readonly className: "bpMessageBlocksCarouselNextButton";
                };
            };
            readonly dropdown: {
                readonly button: {
                    readonly container: {
                        readonly className: "bpMessageBlocksDropdownButtonContainer";
                    };
                    readonly text: {
                        readonly className: "bpMessageBlocksDropdownButtonText";
                    };
                    readonly icon: {
                        readonly className: "bpMessageBlocksDropdownButtonIcon";
                    };
                };
                readonly content: {
                    readonly container: {
                        readonly className: "bpMessageBlocksDropdownContentContainer";
                    };
                    readonly item: {
                        readonly className: "bpMessageBlocksDropdownContentItem";
                    };
                };
            };
            readonly button: {
                readonly className: "bpMessageBlocksButton";
            };
        };
    };
    readonly error: {
        readonly container: {
            readonly className: "bpReset bpErrorContainer";
        };
        readonly header: {
            readonly className: "bpErrorHeader";
        };
        readonly content: {
            readonly className: "bpErrorContent";
        };
        readonly errorTitle: {
            readonly className: "bpErrorTitle";
        };
        readonly errorMessage: {
            readonly className: "bpErrorMessage";
        };
        readonly icon: {
            readonly className: "bpErrorIcon";
        };
    };
    readonly typingIndicator: {
        readonly container: {
            readonly className: "bpTypingIndicatorContainer";
        };
        readonly loader: {
            readonly className: "bpTypingIndicatorLoader";
        };
    };
};

declare type WebchatClientStore = {
    user?: UserCredentials;
    conversationId?: string;
    setUser: (userId?: UserCredentials) => void;
    setConversationId: (conversationId: string) => void;
    clearAll: () => void;
};

declare class WebchatClientStores {
    private static _instances;
    private constructor();
    static getInstance(name?: string, storageLocation?: StorageLocation): BoundWebchatClientStore;
}

export declare type WebchatError = {
    type: 'configuration';
    message: typeof MISSING_CLIENT_ID | typeof MISSING_API_URL | typeof MISSING_BOT_ID | typeof INVALID_CLIENT_ID | typeof INVALID_CONFIGURATION | typeof MISSING_CONFIG_URL;
} | {
    type: 'bot';
    message: typeof BOT_IS_BLOCKED | typeof QUOTA_EXCEEDED | typeof NOT_A_PARTICIPANT;
} | {
    type: 'network';
    message: typeof NETWORK_ERROR;
} | {
    type: string;
    message: string;
};

export declare type WebchatEvents = {
    conversation: string | undefined;
    message: BlockMessage;
    messageSent: IntegrationMessage['payload'];
    error: Error;
    webchatVisibility: 'show' | 'hide' | 'toggle';
    webchatConfig: Record<string, any>;
    customEvent: Record<string, any>;
    isTyping: {
        isTyping: boolean;
        timeout: number;
    };
    participantAdded: User;
    participantRemoved: User;
};

declare type WebchatStore = {
    messageContainerRef: RefObject<HTMLDivElement>;
    setMessageContainerRef: (ref: RefObject<HTMLDivElement>) => void;
    eventEmitter: EventEmitter<Events_2>;
};

export { }
